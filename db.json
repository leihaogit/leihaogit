{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/link.yml","hash":"22f28aba86083268a97e3ed64d5cc5b72e7bcaf1","modified":1689758624792},{"_id":"source/_posts/Java_01_Java集合框架体系概述.md","hash":"afdeb03a0ce29209688dede9250721105d60d0f1","modified":1695624698958},{"_id":"source/_posts/Kotlin_01_初识Kotlin.md","hash":"f9630cd579f0805a7eb4ac32e54456e04c1e36f6","modified":1695625291510},{"_id":"source/_posts/动态规划_01_爬楼梯.md","hash":"c3974972a1bee851edb79f800500ec0d0fd26712","modified":1695625638279},{"_id":"source/_posts/Kotlin_03_Kotlin中的空安全设计详解.md","hash":"6dd4e431dc80ba07d199e4b99bb42e076f2a1cad","modified":1695624567456},{"_id":"source/_posts/动态规划_02_不同路径.md","hash":"8e7669b6fe0fc0bd29ba3212f1ee62e0c1159ff8","modified":1695622712560},{"_id":"source/_posts/安卓_01_安卓多线程异步任务处理的两种方案.md","hash":"dcbe3373e5da21fb9f1b42ad82dd53f5e74e73d5","modified":1695625699338},{"_id":"source/_posts/安卓_03_初识Jetpack.md","hash":"bff8c4568717df5d6b4d0f232b92ca280b7618d5","modified":1695625076519},{"_id":"source/_posts/安卓_04_Navigation.md","hash":"469f057e5a2be54de3cc7778260d731aa28bb47e","modified":1695624998555},{"_id":"source/_posts/安卓_05_Jetpack组件联合使用示例.md","hash":"14d8ad2b1b6d9f7149dae1bd921650a5249d9afa","modified":1695624824156},{"_id":"source/_posts/安卓_02_OrmLite框架的简单使用.md","hash":"20d2ca854c5a8982244dd1b3f28f7f0408928269","modified":1695625386612},{"_id":"source/_posts/安卓_06_Room.md","hash":"521f2f90163c0db3946bdec78030d80395ebe6b9","modified":1695624507096},{"_id":"source/_posts/贪心_01_拆分成最多数目的正偶数之和.md","hash":"6c9de1a01af75d7a3de9dfd1104330d2473c95e3","modified":1695624631769},{"_id":"source/_posts/安卓_07_ViewPager和ViewPager2的使用.md","hash":"bf06af96061c592a93a20c0e735fce79b5aad76b","modified":1695624095653},{"_id":"source/_posts/链表_01_相交链表.md","hash":"94b97965225a98c168d12ba3fec7a5be0abf08d0","modified":1695625809476},{"_id":"source/_posts/Kotlin_02_Kotlin函数式编程思想概述.md","hash":"5d6e22d82062e41cf30e619c509964810dde3fe4","modified":1695625178791},{"_id":"source/_posts/安卓_08_安卓开发中常用的几种动画介绍.md","hash":"c21d0a43b0e6cddcf1745050c9f5f292a8e30b6d","modified":1695625752869},{"_id":"source/_posts/Kotlin_04_Kotlin中那些和Java不一样的写法.md","hash":"aaab3327729467596582ab7b502d597d543369a5","modified":1695624256704},{"_id":"source/tags/index.md","hash":"f1dab83ccaf3f68a6530933e670d3fc76981aec2","modified":1695624874240},{"_id":"source/categories/index.md","hash":"a8adef611a3fcc523eddb72be81843a987faf05b","modified":1695624874243},{"_id":"source/link/index.md","hash":"52e5f7bd9692704ed5b265599770c1b8da79124d","modified":1689758624801},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1689758624804},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1689758624854},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1689758624805},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1689758624804},{"_id":"themes/butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1689758624805},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1689758624806},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1689758624806},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1689758624806},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1689758624854},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1689758624806},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1689758624806},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1689758624807},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1689758624852},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1689758624853},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1689758624853},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1689758624853},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1689758624803},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1689758624803},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1689758624802},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1689758624804},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1689758624810},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1689758624811},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1689758624813},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1689758624814},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1689758624824},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1689758624857},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1689758624858},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1689758624858},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1689758624859},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1689758624858},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1689758624854},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1689758624855},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1689758624856},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1689758624860},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1689758624859},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1689758624862},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1689758624864},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1689758624864},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1689758624825},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1689758624803},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1689758624825},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1689758624884},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1689758624883},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1689758624889},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1689758624887},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1689758624891},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1689758624887},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1689758624888},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1689758624816},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1689758624890},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1689758624816},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1689758624819},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1689758624823},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1689758624823},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1689758624865},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1689758624865},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1689758624866},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1689758624868},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1689758624823},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1689758624869},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1689758624869},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1689758624869},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1689758624870},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1689758624872},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1689758624873},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1689758624872},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1689758624873},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1689758624874},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1689758624874},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1689758624823},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1689758624874},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1689758624874},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1689758624837},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1689758624844},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1689758624876},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1689758624826},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1689758624877},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1689758624877},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1689758624843},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1689758624877},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1689758624847},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1689758624848},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1689758624849},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1689758624848},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1689758624849},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1689758624849},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1689758624851},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1689758624851},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1689758624882},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1689758624882},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1689758624882},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1689758624852},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1689758624851},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1689758624878},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1689758624883},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1689758624879},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1689758624890},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1689758624878},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1689758624867},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1689758624867},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1689758624889},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1689758624824},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1689758624867},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1689758624824},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1689758624868},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1689758624868},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1689758624825},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1689758624825},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1689758624832},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1689758624832},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1689758624835},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1689758624829},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1689758624831},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1689758624831},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1689758624844},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1689758624846},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1689758624846},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1689758624847},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1689758624847},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1689758624841},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1689758624839},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1689758624826},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1689758624837},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1689758624841},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1689758624852},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1689758624828},{"_id":"public/search.xml","hash":"2b45981d2b71af7e00e0c3d71bd10690bf5bb813","modified":1695632047759},{"_id":"public/link/index.html","hash":"ac1c5a66213fc7b1e7102e82fe473e0f5ad9ae5e","modified":1695632047759},{"_id":"public/tags/index.html","hash":"970bc0ad4e982bb176afb609bcdee1761d5398c0","modified":1695632047759},{"_id":"public/categories/index.html","hash":"517d7890d5ad3527c3a3e52f3ec80c9b3ccf4309","modified":1695632047759},{"_id":"public/2023/09/07/安卓_08_安卓开发中常用的几种动画介绍/index.html","hash":"432a83f9783d6b6f35b007055e71ceb53a6524d0","modified":1695632047759},{"_id":"public/2023/07/24/Kotlin_04_Kotlin中那些和Java不一样的写法/index.html","hash":"25bc25ced0717415ffb4188c63ceac40217e05d0","modified":1695632047759},{"_id":"public/2023/08/15/安卓_07_ViewPager和ViewPager2的使用/index.html","hash":"31f2f42bf516b2a7350135e1211ddbe958297a7d","modified":1695632047759},{"_id":"public/2023/07/22/安卓_06_Room/index.html","hash":"6a6e91d29447fcdbe3424e500c3945b09c24ada3","modified":1695632047759},{"_id":"public/2023/07/19/Kotlin_03_Kotlin中的空安全设计详解/index.html","hash":"60ebfb1d0404d77290e03b4484cc8f0571a5ae46","modified":1695632047759},{"_id":"public/2023/07/03/Java_01_Java集合框架体系概述/index.html","hash":"131e7715f526b6151514ea08f7385b5fca2b7500","modified":1695632047759},{"_id":"public/2023/06/27/安卓_05_Jetpack组件联合使用示例/index.html","hash":"ec80e5b5664db4320a57f7decb97627e36362aba","modified":1695632047759},{"_id":"public/2023/07/06/贪心_01_拆分成最多数目的正偶数之和/index.html","hash":"4b4be8cd240e227584a8eaa664876ed868b3268e","modified":1695632047759},{"_id":"public/2023/05/13/安卓_04_Navigation/index.html","hash":"c4f6459b627166faa55b37592f85c0dd06a1f3e8","modified":1695632047759},{"_id":"public/2023/05/12/安卓_03_初识Jetpack/index.html","hash":"f5a58ba234ae4c3c3e494b723dec6e4197d10018","modified":1695632047759},{"_id":"public/2023/04/19/安卓_02_OrmLite框架的简单使用/index.html","hash":"3a6b0c32570326fe67bd2a4fc39b5a429fe8f287","modified":1695632047759},{"_id":"public/2023/04/10/Kotlin_02_Kotlin函数式编程思想概述/index.html","hash":"92dcffbedb536a8b250a25a3c4171d135907dd2e","modified":1695632047759},{"_id":"public/2023/04/08/Kotlin_01_初识Kotlin/index.html","hash":"b44760d8882bc9201a994077c8dc9f66f9b95a4f","modified":1695632047759},{"_id":"public/2023/04/08/链表_01_相交链表/index.html","hash":"515d56a43a804666777ebe0dbc948c798982000f","modified":1695632047759},{"_id":"public/2023/04/03/动态规划_02_不同路径/index.html","hash":"12b83fd7151e612f3e889172539f02c00f7fcbce","modified":1695632047759},{"_id":"public/2023/04/01/动态规划_01_爬楼梯/index.html","hash":"11e5ec7144fd0ad30b9ad2f1f6e74d6287bee9c6","modified":1695632047759},{"_id":"public/2023/03/31/安卓_01_安卓多线程异步任务处理的两种方案/index.html","hash":"c851ec7c46ec0d187ba3ea06544d543c613068b5","modified":1695632047759},{"_id":"public/archives/index.html","hash":"241b65834d50e6ca9c0dca7f7c1b991d05637d6f","modified":1695632047759},{"_id":"public/archives/page/2/index.html","hash":"fb00ed11d1fd4d3e7a161112b1c00cb7db230161","modified":1695632047759},{"_id":"public/archives/2023/index.html","hash":"fd4fc625cc413af47bf4549f016dd4175f98938b","modified":1695632047759},{"_id":"public/archives/2023/page/2/index.html","hash":"b984d63823b16a81fc58485d2ab3520102586ab3","modified":1695632047759},{"_id":"public/archives/2023/03/index.html","hash":"49ac1c2ed40a7169c2f03aa17fee7f85cd4e9241","modified":1695632047759},{"_id":"public/archives/2023/04/index.html","hash":"4e81f201cbe42290d284cd75500be80c01d5ce68","modified":1695632047759},{"_id":"public/archives/2023/05/index.html","hash":"b68da83fcfee03fe18d893886ece515a2f64ac32","modified":1695632047759},{"_id":"public/archives/2023/06/index.html","hash":"713a79f241f2331d5c1e608bd70c9c24949209df","modified":1695632047759},{"_id":"public/archives/2023/07/index.html","hash":"6ae8d02b0a48f135bfa61026780427dbc267968c","modified":1695632047759},{"_id":"public/archives/2023/08/index.html","hash":"31ce196a5409f9c03f5b330e9a5082ab1acc7741","modified":1695632047759},{"_id":"public/archives/2023/09/index.html","hash":"59a7d9f6c2c95fa8781dac7613dc18f362182298","modified":1695632047759},{"_id":"public/categories/编程开发/index.html","hash":"5f5a7dd39563b9fee4b871a555b2f870134e576e","modified":1695632047759},{"_id":"public/categories/编程开发/page/2/index.html","hash":"692c58ea6c2295280e6ce755fa9d62c095406e43","modified":1695632047759},{"_id":"public/categories/数据结构与算法/index.html","hash":"7849408e393c06006626c9904226e0e490fe506e","modified":1695632047759},{"_id":"public/categories/数据库/index.html","hash":"391f78eab93b4c9cb62855d77891d7c85d2b1cbf","modified":1695632047759},{"_id":"public/index.html","hash":"5c60bb09627816d059575429febf9798bbebbcf7","modified":1695632047759},{"_id":"public/page/2/index.html","hash":"2d22a529cb999ce484c3764952602b8559e159a5","modified":1695632047759},{"_id":"public/tags/Java/index.html","hash":"f93307f1838710e5d7ca987abc2ee1d4f332c401","modified":1695632047759},{"_id":"public/tags/Kotlin/index.html","hash":"bb3fdd5f6717ed34c3dd4c90d93e36161e99bcb7","modified":1695632047759},{"_id":"public/tags/面向对象编程/index.html","hash":"e1451205a30b22f54821de8da5aa05cb0f7ee5a8","modified":1695632047759},{"_id":"public/tags/函数式编程/index.html","hash":"9f8e18532de2697c00e4a6329ba2d878003d6a43","modified":1695632047759},{"_id":"public/tags/数据结构与算法/index.html","hash":"f85ac57d26cead74578a1bb8789859d647ed8cf3","modified":1695632047759},{"_id":"public/tags/动态规划/index.html","hash":"45a8cc9a6e2c75e49dcc722e1378804b6f624279","modified":1695632047759},{"_id":"public/tags/Android/index.html","hash":"1cc893e1c80be96b3fb89e165d520d51c2622a20","modified":1695632047759},{"_id":"public/tags/数据库/index.html","hash":"a12fbf690fca4afaccff839f9627e09416910558","modified":1695632047759},{"_id":"public/tags/SQLite/index.html","hash":"e0dd9daf6a359630085c0ad17693b3420a37653d","modified":1695632047759},{"_id":"public/tags/并发编程/index.html","hash":"30f06e36832ff30085eb332690260ba1faa61e88","modified":1695632047759},{"_id":"public/tags/Jetpack/index.html","hash":"8e3abbf0edbe565e1a2a4b0779bd6d7db49c84fe","modified":1695632047759},{"_id":"public/tags/贪心/index.html","hash":"e6444ab0ef2751b06110430ee18f5d3f4b96bc23","modified":1695632047759},{"_id":"public/tags/链表/index.html","hash":"b5d09dc1381b18d8d9f271f2b907b22fcc3ef227","modified":1695632047759},{"_id":"public/tags/双指针/index.html","hash":"d9e15c8df5dcc4a42a1a8c9565d7aba4ebf9db71","modified":1695632047759},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1695632047759},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1695632047759},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1695632047759},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1695632047759},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1695632047759},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1695632047759},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1695632047759},{"_id":"public/css/index.css","hash":"73fab15294f019f903e184f5e20308ce8959a045","modified":1695632047759},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1695632047759},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1695632047759}],"Category":[{"name":"编程开发","_id":"clmynji51000427ho5tp03wrb"},{"name":"数据结构与算法","_id":"clmynji5b000m27ho9erx5rlo"},{"name":"数据库","_id":"clmynji5g000z27ho200s7qdf"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}],"Page":[{"title":"友情链接","date":"2023-03-30T16:00:00.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2023-03-31\ntype: \"link\"\n---\n","updated":"2023-07-19T09:23:44.801Z","path":"link/index.html","comments":1,"layout":"page","_id":"clmynji4t000027ho3k8ohfvm","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"标签","date":"2023-03-30T16:00:00.000Z","type":"tags","_content":"---\ntitle: Android\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Java\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Kotlin\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: Jetpack\ndate: 2023-05-12\ntype: \"tags\"\n---\n---\ntitle: 面向对象编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 函数式编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 并发编程\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 动态规划\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数组\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 二叉树\ndate: 2023-04-11\ntype: \"tags\"\n---\n---\ntitle: 链表\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 双指针\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 栈\ndate: 2023-04-28\ntype: \"tags\"\n------\ntitle: 回溯\ndate: 2023-05-10\ntype: \"tags\"\n---\n---\ntitle: 贪心\ndate: 2023-07-06\ntype: \"tags\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: SQLite\ndate: 2023-04-19\ntype: \"tags\"\n---","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Android\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Java\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Kotlin\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: Jetpack\ndate: 2023-05-12\ntype: \"tags\"\n---\n---\ntitle: 面向对象编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 函数式编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 并发编程\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 动态规划\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数组\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 二叉树\ndate: 2023-04-11\ntype: \"tags\"\n---\n---\ntitle: 链表\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 双指针\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 栈\ndate: 2023-04-28\ntype: \"tags\"\n------\ntitle: 回溯\ndate: 2023-05-10\ntype: \"tags\"\n---\n---\ntitle: 贪心\ndate: 2023-07-06\ntype: \"tags\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: SQLite\ndate: 2023-04-19\ntype: \"tags\"\n---","updated":"2023-09-25T06:54:34.240Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clmynji4z000227ho0hgadqai","content":"<hr>\n<p>title: Android<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Java<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Kotlin<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Jetpack<br>date: 2023-05-12<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 面向对象编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 函数式编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 并发编程<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据结构与算法<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 动态规划<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数组<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 二叉树<br>date: 2023-04-11<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 链表<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 双指针<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 栈<br>date: 2023-04-28<br>type: “tags”</p>\n<hr>\n<p>title: 回溯<br>date: 2023-05-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 贪心<br>date: 2023-07-06<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: SQLite<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":"<hr>\n<p>title: Android<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Java<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Kotlin<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Jetpack<br>date: 2023-05-12<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 面向对象编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 函数式编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 并发编程<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据结构与算法<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 动态规划<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数组<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 二叉树<br>date: 2023-04-11<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 链表<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 双指针<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 栈<br>date: 2023-04-28<br>type: “tags”</p>\n<hr>\n<p>title: 回溯<br>date: 2023-05-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 贪心<br>date: 2023-07-06<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: SQLite<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n"},{"title":"分类","date":"2023-03-30T16:00:00.000Z","type":"categories","_content":"---\ntitle: 数据结构与算法\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 编程开发\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"categories\"\n---","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 编程开发\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"categories\"\n---","updated":"2023-09-25T06:54:34.243Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clmynji52000627ho2gbrh28r","content":"<hr>\n<p>title: 数据结构与算法<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 编程开发<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “categories”</p>\n<hr>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":"<hr>\n<p>title: 数据结构与算法<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 编程开发<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “categories”</p>\n<hr>\n"}],"Post":[{"title":"Java集合框架体系概述","date":"2023-07-03T00:00:00.000Z","description":"介绍 Java 编程语言中的集合框架，包括列表、集合、队列、映射等。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/o42YST.webp","_content":"\n# 一、集合的概念及分类\n\n## 1.1 集合的概念\n\n- 在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。\n- 在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。\n\n## 1.2 集合的分类\n\n- 集合有多种分类方式，根据`是否有序`、`是否可变`、`是否线程安全`、`单列集合或者双列集合`、`实现的接口`等等，可以分出很多类别。\n- 一般来说，使用较多的分类方式是根据`实现的接口`进行分类：\n  1. List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。\n  2. Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。\n  3. Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。\n  4. Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。\n\n- `List`、`Set`、`Map`、`Queue`四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。\n\n# 二、List 接口\n\n## 2.1 总述\n\n- **概念**：继承自 `Collection` 接口，主要用于存储和操作一组对象。\n- **特点**：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。\n- **常见实现类**：\n  1. ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。\n  2. LinkedList：基于链表实现，它支持高效的插入和删除操作。\n  3. Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。\n  4. Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。\n- **实现类特点**：\n  1. 有序\n  2. 线程安全/不安全都有\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 2.2 ArrayList\n\n- **概念**：基于动态数组实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。 \n  2. 线程安全：线程`不安全`。 \n  3. 可否为null：`允许存储null`元素。 \n  4. 可否元素重复：`允许重复`元素。 \n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`1.5倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到ArrayList的末尾。 \n  2. remove(Object element)：从ArrayList中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取ArrayList中元素的数量。 \n  6. isEmpty()：检查ArrayList是否为空。 \n  7. clear()：清空ArrayList中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 \n  10. contains(Object element)：判断ArrayList是否包含指定的元素。 \n  11. toArray()：将ArrayList转换为数组。\n\n## 2.3 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。\n  2. addFirst(E element)：将指定元素添加到链表的头部。\n  3. addLast(E element)：将指定元素添加到链表的末尾。\n  4. remove()：移除并返回链表的第一个元素。\n  5. removeFirst()：移除并返回链表的第一个元素。\n  6. removeLast()：移除并返回链表的最后一个元素。\n  7. get(int index)：返回链表指定位置处的元素。\n  8. getFirst()：返回链表的第一个元素，但不移除。\n  9. getLast()：返回链表的最后一个元素，但不移除。\n  10. size()：获取链表的大小（元素个数）。\n\n## 2.4 Vector\n\n- **概念**：基于动态数组实现的集合类，与ArrayList类似。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到Vector的末尾。 \n  2. remove(Object element)：从Vector中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取Vector中元素的数量。 \n  6. isEmpty()：检查Vector是否为空。 \n  7. clear()：清空Vector中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 \n  10. contains(Object element)：判断Vector是否包含指定的元素。 \n  11. iterator()：返回对Vector中元素进行迭代的迭代器。\n\n## 2.5 Stack\n\n- **概念**：基于Vector实现的后进先出（LIFO）的堆栈数据结构。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。\n  7. 应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。\n- **常用方法**：\n  1. push(E element)：将元素推入栈顶。 \n  2. pop()：弹出栈顶元素并返回该值。 \n  3. peek()：获取栈顶元素的值，但不从栈中移除它。 \n  4. empty()：检查栈是否为空。 \n  5. search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）\n\n# 三、Set 接口\n\n## 3.1 总述\n\n- **概念**：继承自`Collection`接口，用于存储一组唯一的对象，不允许包含重复元素。\n- **特点**：每个元素都必须是唯一的。\n- **常见实现类**：\n  1. HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。\n  2. TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全\n  3. 可以存储 null 元素（但只能为一个）\n  4. 不允许重复元素\n\n## 3.2 HashSet\n\n- **概念**：基于哈希表实现的集合类，通过哈希算法存储和查找元素。\n- **特点**：\n  1. 是否有序：`无序`，不按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`哈希表`作为内部数据结构，通过哈希值实现快速查找。\n  7. 应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到HashSet中。 \n  2. remove(Object element)：从HashSet中移除指定的元素。 \n  3. contains(Object element)：判断HashSet是否包含指定的元素。 \n  4. size()：获取HashSet中元素的数量。 \n  5. isEmpty()：检查HashSet是否为空。 \n  6. clear()：清空HashSet中的所有元素。 \n  7. iterator()：返回对HashSet中元素进行迭代的迭代器。\n\n## 3.3 TreeSet\n\n- **概念**：基于红黑树实现的有序集合类，可以对元素进行排序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：红黑树结构`不需要扩容`。\n  6. 底层原理：使用`红黑树`作为内部数据结构，保持有序性。\n  7. 应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到TreeSet中。 \n  2. remove(Object element)：从TreeSet中移除指定的元素。 \n  3. contains(Object element)：判断TreeSet是否包含指定的元素。 \n  4. size()：获取TreeSet中元素的数量。 \n  5. isEmpty()：检查TreeSet是否为空。 \n  6. clear()：清空TreeSet中的所有元素。 \n  7. iterator()：返回对TreeSet中元素进行迭代的迭代器。 \n  8. first()：获取TreeSet中的第一个元素。 \n  9. last()：获取TreeSet中的最后一个元素。 \n  10. higher(E element)：获取严格大于指定元素的最小元素。 \n  11. lower(E element)：获取严格小于指定元素的最大元素。\n\n## 3.4 LinkedHashSet\n\n- **概念**：基于链表和哈希表实现的集合类，保留元素插入的顺序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`链表和哈希表组合实现`，通过哈希值和链表维护插入顺序与查找性能。\n  7. 应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到LinkedHashSet中。 \n  2. remove(Object element)：从LinkedHashSet中移除指定的元素。 \n  3. contains(Object element)：判断LinkedHashSet是否包含指定的元素。 \n  4. size()：获取LinkedHashSet中元素的数量。 \n  5. isEmpty()：检查LinkedHashSet是否为空。 \n  6. clear()：清空LinkedHashSet中的所有元素。 \n  7. iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 \n  8. forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。\n\n# 四、Map 接口\n\n## 4.1 总述\n\n- **概念**：用于保存键值对的集合。\n- **特点**：每个键都必须是唯一的，但值可以重复。\n- **常见实现类**：\n  1. HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。\n  2. TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。\n  4. HashTable：基于哈希表实现，类似于HashMap，但线程安全。\n  5. Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全（可通过 Collections 提供的方法进行同步操作）\n  3. 允许键为null（但只能有一个），值可以为null\n  4. 键唯一，值可重复\n\n## 4.2 HashMap \n\n- **概念**：基于哈希表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，不保证元素的插入顺序和迭代顺序一致。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`允许存储null键和null值`（键只能储存一个）。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，但并非每次都会触发扩容操作（需要 HashMap 的大小 < 64，并且桶上的元素个数小于8）\n  6. 底层原理：使用`数组和链表`或`红黑树（JDK8+）`作为内部数据结构，通过哈希算法来存储和查找键值对。\n  7. 应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在HashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断HashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断HashMap是否包含指定的值。 \n  6. size()：获取HashMap中键值对的数量。 \n  7. isEmpty()：检查HashMap是否为空。 \n  8. keySet()：返回HashMap中所有键的Set集合。 \n  9. values()：返回HashMap中所有值的Collection集合。 \n  10. entrySet()：返回HashMap中所有键值对的Set集合。\n\n## 4.3 TreeMap\n\n- **概念**：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：没有固定的扩容机制。\n  6. 底层原理：使用`红黑树`作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。\n  7. 应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在TreeMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断TreeMap是否包含指定的键。 \n  5. containsValue(Object value)：判断TreeMap是否包含指定的值。 \n  6. size()：获取TreeMap中键值对的数量。 \n  7. isEmpty()：检查TreeMap是否为空。 \n  8. keySet()：返回TreeMap中所有键的Set集合。 \n  9. values()：返回TreeMap中所有值的Collection集合。 \n  10. entrySet()：返回TreeMap中所有键值对的Set集合。\n\n## 4.4 LinkedHashMap\n\n- **概念**：基于哈希表和双向链表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，并根据插入顺序或访问顺序进行调整。\n  6. 底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。\n  7. 应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 \n  6. size()：获取LinkedHashMap中键值对的数量。 \n  7. isEmpty()：检查LinkedHashMap是否为空。 \n  8. keySet()：返回LinkedHashMap中所有键的Set集合。 \n  9. values()：返回LinkedHashMap中所有值的Collection集合。 \n  10. entrySet()：返回LinkedHashMap中所有键值对的Set集合。\n\n## 4.5 HashTable\n\n- **概念**：基于哈希算法实现的数据结构，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`安全`。HashTable中的所有操作都是同步的（synchronized修饰）。\n  3. 可否为null：`不允许存储null键和null值`，如果存储会抛出NullPointerException。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在Hashtable中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断Hashtable是否包含指定的键。 \n  5. containsValue(Object value)：判断Hashtable是否包含指定的值。 \n  6. size()：获取Hashtable中键值对的数量。 \n  7. isEmpty()：检查Hashtable是否为空。 \n  8. keys()：返回包含所有键的枚举（Enumeration）对象。 \n  9. values()：返回包含所有值的Collection对象。 \n  10. clear()：清空Hashtable中的所有键值对。\n\n## 4.6 Properties\n\n- **概念**：继承自Hashtable类，用于处理属性文件（.properties）的操作。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程` 不安全`\n  3. 可否为null：`允许存储null键和null值`。\n  4. 可否元素重复：`允许重复`的键，值也可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。\n- **常用方法**：\n  1. setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 \n  2. getProperty(String key)：根据键获取属性的值。 \n  3. getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 \n  4. load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 \n  5. store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 \n  6. getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 \n  7. stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 \n  8. remove(Object key)：根据键移除属性。 \n  9. containsKey(Object key)：检查属性列表是否包含指定的键。 \n  10. containsValue(Object value)：检查属性列表是否包含指定的值。\n\n# 五、Queue 接口\n\n## 5.1 总述\n\n- **概念**：用于表示队列（先进先出）的接口，即保存元素的集合。\n- **特点**：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。\n- **常见实现类**：\n  1. LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。\n  2. ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。\n  3. PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。\n- **实现类特点**：\n  1. 有序\n  2. 线程不安全\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 5.2 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。 \n  2. addFirst(E element)：将指定元素添加到链表的头部。 \n  3. addLast(E element)：将指定元素添加到链表的末尾。 \n  4. remove()：移除并返回链表的第一个元素。 \n  5. removeFirst()：移除并返回链表的第一个元素。 \n  6. removeLast()：移除并返回链表的最后一个元素。 \n  7. get(int index)：返回链表指定位置处的元素。 \n  8. getFirst()：返回链表的第一个元素，但不移除。 \n  9. getLast()：返回链表的最后一个元素，但不移除。 \n  10. size()：获取链表的大小（元素个数）。\n\n## 5.3 ArrayDeque\n\n- **概念**：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的`2倍`。\n  6. 底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. addFirst(E element)：将指定元素插入到双端队列的头部。\n  2. addLast(E element)：将指定元素插入到双端队列的尾部。 \n  3. offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 \n  4. offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 \n  5. removeFirst()：移除并返回双端队列的头部元素。 \n  6. removeLast()：移除并返回双端队列的尾部元素。 \n  7. pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 \n  8. pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 \n  9. getFirst()：返回双端队列的头部元素，但不移除。 \n  10. getLast()：返回双端队列的尾部元素，但不移除。 \n  11. peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 \n  12. peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 \n  13. size()：获取双端队列的大小（元素个数）。 \n  14. isEmpty()：检查双端队列是否为空。\n\n## 5.4 PriorityQueue\n\n- **概念**：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。\n- **特点**：\n  1. 是否有序：`有序`，元素按照优先级进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会根据策略进行自动扩容。\n  6. 底层原理：通常使用`堆（Heap）`数据结构来实现，具体可以是`二叉堆`或`斐波那契堆`等。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. add(E element) / offer(E element)：将指定元素插入到队列中。 \n  2. remove() / poll()：移除并返回队列头部的元素。 \n  3. peek()：返回队列头部的元素，但不移除。 \n  4. size()：获取队列的大小（元素个数）。 \n  5. isEmpty()：检查队列是否为空。 \n  6. clear()：清空队列中的所有元素。 \n  7. iterator()：返回用于遍历队列的迭代器。\n\n# 六、总结\n\n- 当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。\n  1. `List接口`实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 \n  2. `Set接口`实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 \n  3. `Map接口`实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 \n  4. `Queue接口`实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。\n- Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。","source":"_posts/Java_01_Java集合框架体系概述.md","raw":"---\ntitle: 'Java集合框架体系概述'\ndate: '2023-07-03'\ndescription: '介绍 Java 编程语言中的集合框架，包括列表、集合、队列、映射等。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/o42YST.webp'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Java\n\n---\n\n# 一、集合的概念及分类\n\n## 1.1 集合的概念\n\n- 在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。\n- 在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。\n\n## 1.2 集合的分类\n\n- 集合有多种分类方式，根据`是否有序`、`是否可变`、`是否线程安全`、`单列集合或者双列集合`、`实现的接口`等等，可以分出很多类别。\n- 一般来说，使用较多的分类方式是根据`实现的接口`进行分类：\n  1. List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。\n  2. Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。\n  3. Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。\n  4. Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。\n\n- `List`、`Set`、`Map`、`Queue`四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。\n\n# 二、List 接口\n\n## 2.1 总述\n\n- **概念**：继承自 `Collection` 接口，主要用于存储和操作一组对象。\n- **特点**：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。\n- **常见实现类**：\n  1. ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。\n  2. LinkedList：基于链表实现，它支持高效的插入和删除操作。\n  3. Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。\n  4. Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。\n- **实现类特点**：\n  1. 有序\n  2. 线程安全/不安全都有\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 2.2 ArrayList\n\n- **概念**：基于动态数组实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。 \n  2. 线程安全：线程`不安全`。 \n  3. 可否为null：`允许存储null`元素。 \n  4. 可否元素重复：`允许重复`元素。 \n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`1.5倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到ArrayList的末尾。 \n  2. remove(Object element)：从ArrayList中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取ArrayList中元素的数量。 \n  6. isEmpty()：检查ArrayList是否为空。 \n  7. clear()：清空ArrayList中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 \n  10. contains(Object element)：判断ArrayList是否包含指定的元素。 \n  11. toArray()：将ArrayList转换为数组。\n\n## 2.3 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。\n  2. addFirst(E element)：将指定元素添加到链表的头部。\n  3. addLast(E element)：将指定元素添加到链表的末尾。\n  4. remove()：移除并返回链表的第一个元素。\n  5. removeFirst()：移除并返回链表的第一个元素。\n  6. removeLast()：移除并返回链表的最后一个元素。\n  7. get(int index)：返回链表指定位置处的元素。\n  8. getFirst()：返回链表的第一个元素，但不移除。\n  9. getLast()：返回链表的最后一个元素，但不移除。\n  10. size()：获取链表的大小（元素个数）。\n\n## 2.4 Vector\n\n- **概念**：基于动态数组实现的集合类，与ArrayList类似。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到Vector的末尾。 \n  2. remove(Object element)：从Vector中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取Vector中元素的数量。 \n  6. isEmpty()：检查Vector是否为空。 \n  7. clear()：清空Vector中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 \n  10. contains(Object element)：判断Vector是否包含指定的元素。 \n  11. iterator()：返回对Vector中元素进行迭代的迭代器。\n\n## 2.5 Stack\n\n- **概念**：基于Vector实现的后进先出（LIFO）的堆栈数据结构。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。\n  7. 应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。\n- **常用方法**：\n  1. push(E element)：将元素推入栈顶。 \n  2. pop()：弹出栈顶元素并返回该值。 \n  3. peek()：获取栈顶元素的值，但不从栈中移除它。 \n  4. empty()：检查栈是否为空。 \n  5. search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）\n\n# 三、Set 接口\n\n## 3.1 总述\n\n- **概念**：继承自`Collection`接口，用于存储一组唯一的对象，不允许包含重复元素。\n- **特点**：每个元素都必须是唯一的。\n- **常见实现类**：\n  1. HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。\n  2. TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全\n  3. 可以存储 null 元素（但只能为一个）\n  4. 不允许重复元素\n\n## 3.2 HashSet\n\n- **概念**：基于哈希表实现的集合类，通过哈希算法存储和查找元素。\n- **特点**：\n  1. 是否有序：`无序`，不按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`哈希表`作为内部数据结构，通过哈希值实现快速查找。\n  7. 应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到HashSet中。 \n  2. remove(Object element)：从HashSet中移除指定的元素。 \n  3. contains(Object element)：判断HashSet是否包含指定的元素。 \n  4. size()：获取HashSet中元素的数量。 \n  5. isEmpty()：检查HashSet是否为空。 \n  6. clear()：清空HashSet中的所有元素。 \n  7. iterator()：返回对HashSet中元素进行迭代的迭代器。\n\n## 3.3 TreeSet\n\n- **概念**：基于红黑树实现的有序集合类，可以对元素进行排序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：红黑树结构`不需要扩容`。\n  6. 底层原理：使用`红黑树`作为内部数据结构，保持有序性。\n  7. 应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到TreeSet中。 \n  2. remove(Object element)：从TreeSet中移除指定的元素。 \n  3. contains(Object element)：判断TreeSet是否包含指定的元素。 \n  4. size()：获取TreeSet中元素的数量。 \n  5. isEmpty()：检查TreeSet是否为空。 \n  6. clear()：清空TreeSet中的所有元素。 \n  7. iterator()：返回对TreeSet中元素进行迭代的迭代器。 \n  8. first()：获取TreeSet中的第一个元素。 \n  9. last()：获取TreeSet中的最后一个元素。 \n  10. higher(E element)：获取严格大于指定元素的最小元素。 \n  11. lower(E element)：获取严格小于指定元素的最大元素。\n\n## 3.4 LinkedHashSet\n\n- **概念**：基于链表和哈希表实现的集合类，保留元素插入的顺序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`链表和哈希表组合实现`，通过哈希值和链表维护插入顺序与查找性能。\n  7. 应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到LinkedHashSet中。 \n  2. remove(Object element)：从LinkedHashSet中移除指定的元素。 \n  3. contains(Object element)：判断LinkedHashSet是否包含指定的元素。 \n  4. size()：获取LinkedHashSet中元素的数量。 \n  5. isEmpty()：检查LinkedHashSet是否为空。 \n  6. clear()：清空LinkedHashSet中的所有元素。 \n  7. iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 \n  8. forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。\n\n# 四、Map 接口\n\n## 4.1 总述\n\n- **概念**：用于保存键值对的集合。\n- **特点**：每个键都必须是唯一的，但值可以重复。\n- **常见实现类**：\n  1. HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。\n  2. TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。\n  4. HashTable：基于哈希表实现，类似于HashMap，但线程安全。\n  5. Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全（可通过 Collections 提供的方法进行同步操作）\n  3. 允许键为null（但只能有一个），值可以为null\n  4. 键唯一，值可重复\n\n## 4.2 HashMap \n\n- **概念**：基于哈希表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，不保证元素的插入顺序和迭代顺序一致。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`允许存储null键和null值`（键只能储存一个）。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，但并非每次都会触发扩容操作（需要 HashMap 的大小 < 64，并且桶上的元素个数小于8）\n  6. 底层原理：使用`数组和链表`或`红黑树（JDK8+）`作为内部数据结构，通过哈希算法来存储和查找键值对。\n  7. 应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在HashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断HashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断HashMap是否包含指定的值。 \n  6. size()：获取HashMap中键值对的数量。 \n  7. isEmpty()：检查HashMap是否为空。 \n  8. keySet()：返回HashMap中所有键的Set集合。 \n  9. values()：返回HashMap中所有值的Collection集合。 \n  10. entrySet()：返回HashMap中所有键值对的Set集合。\n\n## 4.3 TreeMap\n\n- **概念**：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：没有固定的扩容机制。\n  6. 底层原理：使用`红黑树`作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。\n  7. 应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在TreeMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断TreeMap是否包含指定的键。 \n  5. containsValue(Object value)：判断TreeMap是否包含指定的值。 \n  6. size()：获取TreeMap中键值对的数量。 \n  7. isEmpty()：检查TreeMap是否为空。 \n  8. keySet()：返回TreeMap中所有键的Set集合。 \n  9. values()：返回TreeMap中所有值的Collection集合。 \n  10. entrySet()：返回TreeMap中所有键值对的Set集合。\n\n## 4.4 LinkedHashMap\n\n- **概念**：基于哈希表和双向链表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，并根据插入顺序或访问顺序进行调整。\n  6. 底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。\n  7. 应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 \n  6. size()：获取LinkedHashMap中键值对的数量。 \n  7. isEmpty()：检查LinkedHashMap是否为空。 \n  8. keySet()：返回LinkedHashMap中所有键的Set集合。 \n  9. values()：返回LinkedHashMap中所有值的Collection集合。 \n  10. entrySet()：返回LinkedHashMap中所有键值对的Set集合。\n\n## 4.5 HashTable\n\n- **概念**：基于哈希算法实现的数据结构，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`安全`。HashTable中的所有操作都是同步的（synchronized修饰）。\n  3. 可否为null：`不允许存储null键和null值`，如果存储会抛出NullPointerException。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在Hashtable中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断Hashtable是否包含指定的键。 \n  5. containsValue(Object value)：判断Hashtable是否包含指定的值。 \n  6. size()：获取Hashtable中键值对的数量。 \n  7. isEmpty()：检查Hashtable是否为空。 \n  8. keys()：返回包含所有键的枚举（Enumeration）对象。 \n  9. values()：返回包含所有值的Collection对象。 \n  10. clear()：清空Hashtable中的所有键值对。\n\n## 4.6 Properties\n\n- **概念**：继承自Hashtable类，用于处理属性文件（.properties）的操作。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程` 不安全`\n  3. 可否为null：`允许存储null键和null值`。\n  4. 可否元素重复：`允许重复`的键，值也可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。\n- **常用方法**：\n  1. setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 \n  2. getProperty(String key)：根据键获取属性的值。 \n  3. getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 \n  4. load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 \n  5. store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 \n  6. getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 \n  7. stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 \n  8. remove(Object key)：根据键移除属性。 \n  9. containsKey(Object key)：检查属性列表是否包含指定的键。 \n  10. containsValue(Object value)：检查属性列表是否包含指定的值。\n\n# 五、Queue 接口\n\n## 5.1 总述\n\n- **概念**：用于表示队列（先进先出）的接口，即保存元素的集合。\n- **特点**：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。\n- **常见实现类**：\n  1. LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。\n  2. ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。\n  3. PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。\n- **实现类特点**：\n  1. 有序\n  2. 线程不安全\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 5.2 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。 \n  2. addFirst(E element)：将指定元素添加到链表的头部。 \n  3. addLast(E element)：将指定元素添加到链表的末尾。 \n  4. remove()：移除并返回链表的第一个元素。 \n  5. removeFirst()：移除并返回链表的第一个元素。 \n  6. removeLast()：移除并返回链表的最后一个元素。 \n  7. get(int index)：返回链表指定位置处的元素。 \n  8. getFirst()：返回链表的第一个元素，但不移除。 \n  9. getLast()：返回链表的最后一个元素，但不移除。 \n  10. size()：获取链表的大小（元素个数）。\n\n## 5.3 ArrayDeque\n\n- **概念**：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的`2倍`。\n  6. 底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. addFirst(E element)：将指定元素插入到双端队列的头部。\n  2. addLast(E element)：将指定元素插入到双端队列的尾部。 \n  3. offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 \n  4. offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 \n  5. removeFirst()：移除并返回双端队列的头部元素。 \n  6. removeLast()：移除并返回双端队列的尾部元素。 \n  7. pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 \n  8. pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 \n  9. getFirst()：返回双端队列的头部元素，但不移除。 \n  10. getLast()：返回双端队列的尾部元素，但不移除。 \n  11. peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 \n  12. peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 \n  13. size()：获取双端队列的大小（元素个数）。 \n  14. isEmpty()：检查双端队列是否为空。\n\n## 5.4 PriorityQueue\n\n- **概念**：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。\n- **特点**：\n  1. 是否有序：`有序`，元素按照优先级进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会根据策略进行自动扩容。\n  6. 底层原理：通常使用`堆（Heap）`数据结构来实现，具体可以是`二叉堆`或`斐波那契堆`等。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. add(E element) / offer(E element)：将指定元素插入到队列中。 \n  2. remove() / poll()：移除并返回队列头部的元素。 \n  3. peek()：返回队列头部的元素，但不移除。 \n  4. size()：获取队列的大小（元素个数）。 \n  5. isEmpty()：检查队列是否为空。 \n  6. clear()：清空队列中的所有元素。 \n  7. iterator()：返回用于遍历队列的迭代器。\n\n# 六、总结\n\n- 当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。\n  1. `List接口`实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 \n  2. `Set接口`实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 \n  3. `Map接口`实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 \n  4. `Queue接口`实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。\n- Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。","slug":"Java_01_Java集合框架体系概述","published":1,"updated":"2023-09-25T06:51:38.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji4w000127hoge2vc7rd","content":"<h1 id=\"一、集合的概念及分类\"><a href=\"#一、集合的概念及分类\" class=\"headerlink\" title=\"一、集合的概念及分类\"></a>一、集合的概念及分类</h1><h2 id=\"1-1-集合的概念\"><a href=\"#1-1-集合的概念\" class=\"headerlink\" title=\"1.1 集合的概念\"></a>1.1 集合的概念</h2><ul>\n<li>在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。</li>\n<li>在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。</li>\n</ul>\n<h2 id=\"1-2-集合的分类\"><a href=\"#1-2-集合的分类\" class=\"headerlink\" title=\"1.2 集合的分类\"></a>1.2 集合的分类</h2><ul>\n<li><p>集合有多种分类方式，根据<code>是否有序</code>、<code>是否可变</code>、<code>是否线程安全</code>、<code>单列集合或者双列集合</code>、<code>实现的接口</code>等等，可以分出很多类别。</p>\n</li>\n<li><p>一般来说，使用较多的分类方式是根据<code>实现的接口</code>进行分类：</p>\n<ol>\n<li>List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。</li>\n<li>Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。</li>\n<li>Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。</li>\n<li>Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。</li>\n</ol>\n</li>\n<li><p><code>List</code>、<code>Set</code>、<code>Map</code>、<code>Queue</code>四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。</p>\n</li>\n</ul>\n<h1 id=\"二、List-接口\"><a href=\"#二、List-接口\" class=\"headerlink\" title=\"二、List 接口\"></a>二、List 接口</h1><h2 id=\"2-1-总述\"><a href=\"#2-1-总述\" class=\"headerlink\" title=\"2.1 总述\"></a>2.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自 <code>Collection</code> 接口，主要用于存储和操作一组对象。</li>\n<li><strong>特点</strong>：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。</li>\n<li>LinkedList：基于链表实现，它支持高效的插入和删除操作。</li>\n<li>Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。</li>\n<li>Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程安全/不安全都有</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-ArrayList\"><a href=\"#2-2-ArrayList\" class=\"headerlink\" title=\"2.2 ArrayList\"></a>2.2 ArrayList</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。 </li>\n<li>线程安全：线程<code>不安全</code>。 </li>\n<li>可否为null：<code>允许存储null</code>元素。 </li>\n<li>可否元素重复：<code>允许重复</code>元素。 </li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>1.5倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到ArrayList的末尾。 </li>\n<li>remove(Object element)：从ArrayList中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取ArrayList中元素的数量。 </li>\n<li>isEmpty()：检查ArrayList是否为空。 </li>\n<li>clear()：清空ArrayList中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 </li>\n<li>contains(Object element)：判断ArrayList是否包含指定的元素。 </li>\n<li>toArray()：将ArrayList转换为数组。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-LinkedList\"><a href=\"#2-3-LinkedList\" class=\"headerlink\" title=\"2.3 LinkedList\"></a>2.3 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。</li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。</li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。</li>\n<li>remove()：移除并返回链表的第一个元素。</li>\n<li>removeFirst()：移除并返回链表的第一个元素。</li>\n<li>removeLast()：移除并返回链表的最后一个元素。</li>\n<li>get(int index)：返回链表指定位置处的元素。</li>\n<li>getFirst()：返回链表的第一个元素，但不移除。</li>\n<li>getLast()：返回链表的最后一个元素，但不移除。</li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-Vector\"><a href=\"#2-4-Vector\" class=\"headerlink\" title=\"2.4 Vector\"></a>2.4 Vector</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类，与ArrayList类似。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到Vector的末尾。 </li>\n<li>remove(Object element)：从Vector中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取Vector中元素的数量。 </li>\n<li>isEmpty()：检查Vector是否为空。 </li>\n<li>clear()：清空Vector中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 </li>\n<li>contains(Object element)：判断Vector是否包含指定的元素。 </li>\n<li>iterator()：返回对Vector中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-Stack\"><a href=\"#2-5-Stack\" class=\"headerlink\" title=\"2.5 Stack\"></a>2.5 Stack</h2><ul>\n<li><strong>概念</strong>：基于Vector实现的后进先出（LIFO）的堆栈数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。</li>\n<li>应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>push(E element)：将元素推入栈顶。 </li>\n<li>pop()：弹出栈顶元素并返回该值。 </li>\n<li>peek()：获取栈顶元素的值，但不从栈中移除它。 </li>\n<li>empty()：检查栈是否为空。 </li>\n<li>search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、Set-接口\"><a href=\"#三、Set-接口\" class=\"headerlink\" title=\"三、Set 接口\"></a>三、Set 接口</h1><h2 id=\"3-1-总述\"><a href=\"#3-1-总述\" class=\"headerlink\" title=\"3.1 总述\"></a>3.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自<code>Collection</code>接口，用于存储一组唯一的对象，不允许包含重复元素。</li>\n<li><strong>特点</strong>：每个元素都必须是唯一的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。</li>\n<li>TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素（但只能为一个）</li>\n<li>不允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，通过哈希算法存储和查找元素。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>哈希表</code>作为内部数据结构，通过哈希值实现快速查找。</li>\n<li>应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到HashSet中。 </li>\n<li>remove(Object element)：从HashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断HashSet是否包含指定的元素。 </li>\n<li>size()：获取HashSet中元素的数量。 </li>\n<li>isEmpty()：检查HashSet是否为空。 </li>\n<li>clear()：清空HashSet中的所有元素。 </li>\n<li>iterator()：返回对HashSet中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-3-TreeSet\"><a href=\"#3-3-TreeSet\" class=\"headerlink\" title=\"3.3 TreeSet\"></a>3.3 TreeSet</h2><ul>\n<li><strong>概念</strong>：基于红黑树实现的有序集合类，可以对元素进行排序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：红黑树结构<code>不需要扩容</code>。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，保持有序性。</li>\n<li>应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到TreeSet中。 </li>\n<li>remove(Object element)：从TreeSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断TreeSet是否包含指定的元素。 </li>\n<li>size()：获取TreeSet中元素的数量。 </li>\n<li>isEmpty()：检查TreeSet是否为空。 </li>\n<li>clear()：清空TreeSet中的所有元素。 </li>\n<li>iterator()：返回对TreeSet中元素进行迭代的迭代器。 </li>\n<li>first()：获取TreeSet中的第一个元素。 </li>\n<li>last()：获取TreeSet中的最后一个元素。 </li>\n<li>higher(E element)：获取严格大于指定元素的最小元素。 </li>\n<li>lower(E element)：获取严格小于指定元素的最大元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-4-LinkedHashSet\"><a href=\"#3-4-LinkedHashSet\" class=\"headerlink\" title=\"3.4 LinkedHashSet\"></a>3.4 LinkedHashSet</h2><ul>\n<li><strong>概念</strong>：基于链表和哈希表实现的集合类，保留元素插入的顺序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>链表和哈希表组合实现</code>，通过哈希值和链表维护插入顺序与查找性能。</li>\n<li>应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到LinkedHashSet中。 </li>\n<li>remove(Object element)：从LinkedHashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断LinkedHashSet是否包含指定的元素。 </li>\n<li>size()：获取LinkedHashSet中元素的数量。 </li>\n<li>isEmpty()：检查LinkedHashSet是否为空。 </li>\n<li>clear()：清空LinkedHashSet中的所有元素。 </li>\n<li>iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 </li>\n<li>forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、Map-接口\"><a href=\"#四、Map-接口\" class=\"headerlink\" title=\"四、Map 接口\"></a>四、Map 接口</h1><h2 id=\"4-1-总述\"><a href=\"#4-1-总述\" class=\"headerlink\" title=\"4.1 总述\"></a>4.1 总述</h2><ul>\n<li><strong>概念</strong>：用于保存键值对的集合。</li>\n<li><strong>特点</strong>：每个键都必须是唯一的，但值可以重复。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。</li>\n<li>TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。</li>\n<li>HashTable：基于哈希表实现，类似于HashMap，但线程安全。</li>\n<li>Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全（可通过 Collections 提供的方法进行同步操作）</li>\n<li>允许键为null（但只能有一个），值可以为null</li>\n<li>键唯一，值可重复</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-2-HashMap\"><a href=\"#4-2-HashMap\" class=\"headerlink\" title=\"4.2 HashMap\"></a>4.2 HashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不保证元素的插入顺序和迭代顺序一致。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>允许存储null键和null值</code>（键只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，但并非每次都会触发扩容操作（需要 HashMap 的大小 &lt; 64，并且桶上的元素个数小于8）</li>\n<li>底层原理：使用<code>数组和链表</code>或<code>红黑树（JDK8+）</code>作为内部数据结构，通过哈希算法来存储和查找键值对。</li>\n<li>应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在HashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断HashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断HashMap是否包含指定的值。 </li>\n<li>size()：获取HashMap中键值对的数量。 </li>\n<li>isEmpty()：检查HashMap是否为空。 </li>\n<li>keySet()：返回HashMap中所有键的Set集合。 </li>\n<li>values()：返回HashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回HashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-3-TreeMap\"><a href=\"#4-3-TreeMap\" class=\"headerlink\" title=\"4.3 TreeMap\"></a>4.3 TreeMap</h2><ul>\n<li><strong>概念</strong>：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：没有固定的扩容机制。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。</li>\n<li>应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在TreeMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断TreeMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断TreeMap是否包含指定的值。 </li>\n<li>size()：获取TreeMap中键值对的数量。 </li>\n<li>isEmpty()：检查TreeMap是否为空。 </li>\n<li>keySet()：返回TreeMap中所有键的Set集合。 </li>\n<li>values()：返回TreeMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回TreeMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-4-LinkedHashMap\"><a href=\"#4-4-LinkedHashMap\" class=\"headerlink\" title=\"4.4 LinkedHashMap\"></a>4.4 LinkedHashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表和双向链表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，并根据插入顺序或访问顺序进行调整。</li>\n<li>底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。</li>\n<li>应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 </li>\n<li>size()：获取LinkedHashMap中键值对的数量。 </li>\n<li>isEmpty()：检查LinkedHashMap是否为空。 </li>\n<li>keySet()：返回LinkedHashMap中所有键的Set集合。 </li>\n<li>values()：返回LinkedHashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回LinkedHashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-5-HashTable\"><a href=\"#4-5-HashTable\" class=\"headerlink\" title=\"4.5 HashTable\"></a>4.5 HashTable</h2><ul>\n<li><strong>概念</strong>：基于哈希算法实现的数据结构，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>安全</code>。HashTable中的所有操作都是同步的（synchronized修饰）。</li>\n<li>可否为null：<code>不允许存储null键和null值</code>，如果存储会抛出NullPointerException。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在Hashtable中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断Hashtable是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断Hashtable是否包含指定的值。 </li>\n<li>size()：获取Hashtable中键值对的数量。 </li>\n<li>isEmpty()：检查Hashtable是否为空。 </li>\n<li>keys()：返回包含所有键的枚举（Enumeration）对象。 </li>\n<li>values()：返回包含所有值的Collection对象。 </li>\n<li>clear()：清空Hashtable中的所有键值对。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-6-Properties\"><a href=\"#4-6-Properties\" class=\"headerlink\" title=\"4.6 Properties\"></a>4.6 Properties</h2><ul>\n<li><strong>概念</strong>：继承自Hashtable类，用于处理属性文件（.properties）的操作。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code> 不安全</code></li>\n<li>可否为null：<code>允许存储null键和null值</code>。</li>\n<li>可否元素重复：<code>允许重复</code>的键，值也可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 </li>\n<li>getProperty(String key)：根据键获取属性的值。 </li>\n<li>getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 </li>\n<li>load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 </li>\n<li>store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 </li>\n<li>getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 </li>\n<li>stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 </li>\n<li>remove(Object key)：根据键移除属性。 </li>\n<li>containsKey(Object key)：检查属性列表是否包含指定的键。 </li>\n<li>containsValue(Object value)：检查属性列表是否包含指定的值。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"五、Queue-接口\"><a href=\"#五、Queue-接口\" class=\"headerlink\" title=\"五、Queue 接口\"></a>五、Queue 接口</h1><h2 id=\"5-1-总述\"><a href=\"#5-1-总述\" class=\"headerlink\" title=\"5.1 总述\"></a>5.1 总述</h2><ul>\n<li><strong>概念</strong>：用于表示队列（先进先出）的接口，即保存元素的集合。</li>\n<li><strong>特点</strong>：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。</li>\n<li>ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。</li>\n<li>PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-LinkedList\"><a href=\"#5-2-LinkedList\" class=\"headerlink\" title=\"5.2 LinkedList\"></a>5.2 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。 </li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。 </li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。 </li>\n<li>remove()：移除并返回链表的第一个元素。 </li>\n<li>removeFirst()：移除并返回链表的第一个元素。 </li>\n<li>removeLast()：移除并返回链表的最后一个元素。 </li>\n<li>get(int index)：返回链表指定位置处的元素。 </li>\n<li>getFirst()：返回链表的第一个元素，但不移除。 </li>\n<li>getLast()：返回链表的最后一个元素，但不移除。 </li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-3-ArrayDeque\"><a href=\"#5-3-ArrayDeque\" class=\"headerlink\" title=\"5.3 ArrayDeque\"></a>5.3 ArrayDeque</h2><ul>\n<li><strong>概念</strong>：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的<code>2倍</code>。</li>\n<li>底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>addFirst(E element)：将指定元素插入到双端队列的头部。</li>\n<li>addLast(E element)：将指定元素插入到双端队列的尾部。 </li>\n<li>offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 </li>\n<li>offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 </li>\n<li>removeFirst()：移除并返回双端队列的头部元素。 </li>\n<li>removeLast()：移除并返回双端队列的尾部元素。 </li>\n<li>pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>getFirst()：返回双端队列的头部元素，但不移除。 </li>\n<li>getLast()：返回双端队列的尾部元素，但不移除。 </li>\n<li>peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>size()：获取双端队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查双端队列是否为空。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-4-PriorityQueue\"><a href=\"#5-4-PriorityQueue\" class=\"headerlink\" title=\"5.4 PriorityQueue\"></a>5.4 PriorityQueue</h2><ul>\n<li><strong>概念</strong>：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素按照优先级进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会根据策略进行自动扩容。</li>\n<li>底层原理：通常使用<code>堆（Heap）</code>数据结构来实现，具体可以是<code>二叉堆</code>或<code>斐波那契堆</code>等。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element) / offer(E element)：将指定元素插入到队列中。 </li>\n<li>remove() / poll()：移除并返回队列头部的元素。 </li>\n<li>peek()：返回队列头部的元素，但不移除。 </li>\n<li>size()：获取队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查队列是否为空。 </li>\n<li>clear()：清空队列中的所有元素。 </li>\n<li>iterator()：返回用于遍历队列的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h1><ul>\n<li>当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。<ol>\n<li><code>List接口</code>实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 </li>\n<li><code>Set接口</code>实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 </li>\n<li><code>Map接口</code>实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 </li>\n<li><code>Queue接口</code>实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。</li>\n</ol>\n</li>\n<li>Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、集合的概念及分类\"><a href=\"#一、集合的概念及分类\" class=\"headerlink\" title=\"一、集合的概念及分类\"></a>一、集合的概念及分类</h1><h2 id=\"1-1-集合的概念\"><a href=\"#1-1-集合的概念\" class=\"headerlink\" title=\"1.1 集合的概念\"></a>1.1 集合的概念</h2><ul>\n<li>在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。</li>\n<li>在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。</li>\n</ul>\n<h2 id=\"1-2-集合的分类\"><a href=\"#1-2-集合的分类\" class=\"headerlink\" title=\"1.2 集合的分类\"></a>1.2 集合的分类</h2><ul>\n<li><p>集合有多种分类方式，根据<code>是否有序</code>、<code>是否可变</code>、<code>是否线程安全</code>、<code>单列集合或者双列集合</code>、<code>实现的接口</code>等等，可以分出很多类别。</p>\n</li>\n<li><p>一般来说，使用较多的分类方式是根据<code>实现的接口</code>进行分类：</p>\n<ol>\n<li>List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。</li>\n<li>Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。</li>\n<li>Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。</li>\n<li>Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。</li>\n</ol>\n</li>\n<li><p><code>List</code>、<code>Set</code>、<code>Map</code>、<code>Queue</code>四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。</p>\n</li>\n</ul>\n<h1 id=\"二、List-接口\"><a href=\"#二、List-接口\" class=\"headerlink\" title=\"二、List 接口\"></a>二、List 接口</h1><h2 id=\"2-1-总述\"><a href=\"#2-1-总述\" class=\"headerlink\" title=\"2.1 总述\"></a>2.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自 <code>Collection</code> 接口，主要用于存储和操作一组对象。</li>\n<li><strong>特点</strong>：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。</li>\n<li>LinkedList：基于链表实现，它支持高效的插入和删除操作。</li>\n<li>Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。</li>\n<li>Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程安全/不安全都有</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-ArrayList\"><a href=\"#2-2-ArrayList\" class=\"headerlink\" title=\"2.2 ArrayList\"></a>2.2 ArrayList</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。 </li>\n<li>线程安全：线程<code>不安全</code>。 </li>\n<li>可否为null：<code>允许存储null</code>元素。 </li>\n<li>可否元素重复：<code>允许重复</code>元素。 </li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>1.5倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到ArrayList的末尾。 </li>\n<li>remove(Object element)：从ArrayList中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取ArrayList中元素的数量。 </li>\n<li>isEmpty()：检查ArrayList是否为空。 </li>\n<li>clear()：清空ArrayList中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 </li>\n<li>contains(Object element)：判断ArrayList是否包含指定的元素。 </li>\n<li>toArray()：将ArrayList转换为数组。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-LinkedList\"><a href=\"#2-3-LinkedList\" class=\"headerlink\" title=\"2.3 LinkedList\"></a>2.3 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。</li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。</li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。</li>\n<li>remove()：移除并返回链表的第一个元素。</li>\n<li>removeFirst()：移除并返回链表的第一个元素。</li>\n<li>removeLast()：移除并返回链表的最后一个元素。</li>\n<li>get(int index)：返回链表指定位置处的元素。</li>\n<li>getFirst()：返回链表的第一个元素，但不移除。</li>\n<li>getLast()：返回链表的最后一个元素，但不移除。</li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-Vector\"><a href=\"#2-4-Vector\" class=\"headerlink\" title=\"2.4 Vector\"></a>2.4 Vector</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类，与ArrayList类似。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到Vector的末尾。 </li>\n<li>remove(Object element)：从Vector中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取Vector中元素的数量。 </li>\n<li>isEmpty()：检查Vector是否为空。 </li>\n<li>clear()：清空Vector中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 </li>\n<li>contains(Object element)：判断Vector是否包含指定的元素。 </li>\n<li>iterator()：返回对Vector中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-Stack\"><a href=\"#2-5-Stack\" class=\"headerlink\" title=\"2.5 Stack\"></a>2.5 Stack</h2><ul>\n<li><strong>概念</strong>：基于Vector实现的后进先出（LIFO）的堆栈数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。</li>\n<li>应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>push(E element)：将元素推入栈顶。 </li>\n<li>pop()：弹出栈顶元素并返回该值。 </li>\n<li>peek()：获取栈顶元素的值，但不从栈中移除它。 </li>\n<li>empty()：检查栈是否为空。 </li>\n<li>search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、Set-接口\"><a href=\"#三、Set-接口\" class=\"headerlink\" title=\"三、Set 接口\"></a>三、Set 接口</h1><h2 id=\"3-1-总述\"><a href=\"#3-1-总述\" class=\"headerlink\" title=\"3.1 总述\"></a>3.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自<code>Collection</code>接口，用于存储一组唯一的对象，不允许包含重复元素。</li>\n<li><strong>特点</strong>：每个元素都必须是唯一的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。</li>\n<li>TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素（但只能为一个）</li>\n<li>不允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，通过哈希算法存储和查找元素。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>哈希表</code>作为内部数据结构，通过哈希值实现快速查找。</li>\n<li>应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到HashSet中。 </li>\n<li>remove(Object element)：从HashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断HashSet是否包含指定的元素。 </li>\n<li>size()：获取HashSet中元素的数量。 </li>\n<li>isEmpty()：检查HashSet是否为空。 </li>\n<li>clear()：清空HashSet中的所有元素。 </li>\n<li>iterator()：返回对HashSet中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-3-TreeSet\"><a href=\"#3-3-TreeSet\" class=\"headerlink\" title=\"3.3 TreeSet\"></a>3.3 TreeSet</h2><ul>\n<li><strong>概念</strong>：基于红黑树实现的有序集合类，可以对元素进行排序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：红黑树结构<code>不需要扩容</code>。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，保持有序性。</li>\n<li>应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到TreeSet中。 </li>\n<li>remove(Object element)：从TreeSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断TreeSet是否包含指定的元素。 </li>\n<li>size()：获取TreeSet中元素的数量。 </li>\n<li>isEmpty()：检查TreeSet是否为空。 </li>\n<li>clear()：清空TreeSet中的所有元素。 </li>\n<li>iterator()：返回对TreeSet中元素进行迭代的迭代器。 </li>\n<li>first()：获取TreeSet中的第一个元素。 </li>\n<li>last()：获取TreeSet中的最后一个元素。 </li>\n<li>higher(E element)：获取严格大于指定元素的最小元素。 </li>\n<li>lower(E element)：获取严格小于指定元素的最大元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-4-LinkedHashSet\"><a href=\"#3-4-LinkedHashSet\" class=\"headerlink\" title=\"3.4 LinkedHashSet\"></a>3.4 LinkedHashSet</h2><ul>\n<li><strong>概念</strong>：基于链表和哈希表实现的集合类，保留元素插入的顺序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>链表和哈希表组合实现</code>，通过哈希值和链表维护插入顺序与查找性能。</li>\n<li>应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到LinkedHashSet中。 </li>\n<li>remove(Object element)：从LinkedHashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断LinkedHashSet是否包含指定的元素。 </li>\n<li>size()：获取LinkedHashSet中元素的数量。 </li>\n<li>isEmpty()：检查LinkedHashSet是否为空。 </li>\n<li>clear()：清空LinkedHashSet中的所有元素。 </li>\n<li>iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 </li>\n<li>forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、Map-接口\"><a href=\"#四、Map-接口\" class=\"headerlink\" title=\"四、Map 接口\"></a>四、Map 接口</h1><h2 id=\"4-1-总述\"><a href=\"#4-1-总述\" class=\"headerlink\" title=\"4.1 总述\"></a>4.1 总述</h2><ul>\n<li><strong>概念</strong>：用于保存键值对的集合。</li>\n<li><strong>特点</strong>：每个键都必须是唯一的，但值可以重复。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。</li>\n<li>TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。</li>\n<li>HashTable：基于哈希表实现，类似于HashMap，但线程安全。</li>\n<li>Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全（可通过 Collections 提供的方法进行同步操作）</li>\n<li>允许键为null（但只能有一个），值可以为null</li>\n<li>键唯一，值可重复</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-2-HashMap\"><a href=\"#4-2-HashMap\" class=\"headerlink\" title=\"4.2 HashMap\"></a>4.2 HashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不保证元素的插入顺序和迭代顺序一致。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>允许存储null键和null值</code>（键只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，但并非每次都会触发扩容操作（需要 HashMap 的大小 &lt; 64，并且桶上的元素个数小于8）</li>\n<li>底层原理：使用<code>数组和链表</code>或<code>红黑树（JDK8+）</code>作为内部数据结构，通过哈希算法来存储和查找键值对。</li>\n<li>应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在HashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断HashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断HashMap是否包含指定的值。 </li>\n<li>size()：获取HashMap中键值对的数量。 </li>\n<li>isEmpty()：检查HashMap是否为空。 </li>\n<li>keySet()：返回HashMap中所有键的Set集合。 </li>\n<li>values()：返回HashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回HashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-3-TreeMap\"><a href=\"#4-3-TreeMap\" class=\"headerlink\" title=\"4.3 TreeMap\"></a>4.3 TreeMap</h2><ul>\n<li><strong>概念</strong>：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：没有固定的扩容机制。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。</li>\n<li>应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在TreeMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断TreeMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断TreeMap是否包含指定的值。 </li>\n<li>size()：获取TreeMap中键值对的数量。 </li>\n<li>isEmpty()：检查TreeMap是否为空。 </li>\n<li>keySet()：返回TreeMap中所有键的Set集合。 </li>\n<li>values()：返回TreeMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回TreeMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-4-LinkedHashMap\"><a href=\"#4-4-LinkedHashMap\" class=\"headerlink\" title=\"4.4 LinkedHashMap\"></a>4.4 LinkedHashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表和双向链表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，并根据插入顺序或访问顺序进行调整。</li>\n<li>底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。</li>\n<li>应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 </li>\n<li>size()：获取LinkedHashMap中键值对的数量。 </li>\n<li>isEmpty()：检查LinkedHashMap是否为空。 </li>\n<li>keySet()：返回LinkedHashMap中所有键的Set集合。 </li>\n<li>values()：返回LinkedHashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回LinkedHashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-5-HashTable\"><a href=\"#4-5-HashTable\" class=\"headerlink\" title=\"4.5 HashTable\"></a>4.5 HashTable</h2><ul>\n<li><strong>概念</strong>：基于哈希算法实现的数据结构，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>安全</code>。HashTable中的所有操作都是同步的（synchronized修饰）。</li>\n<li>可否为null：<code>不允许存储null键和null值</code>，如果存储会抛出NullPointerException。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在Hashtable中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断Hashtable是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断Hashtable是否包含指定的值。 </li>\n<li>size()：获取Hashtable中键值对的数量。 </li>\n<li>isEmpty()：检查Hashtable是否为空。 </li>\n<li>keys()：返回包含所有键的枚举（Enumeration）对象。 </li>\n<li>values()：返回包含所有值的Collection对象。 </li>\n<li>clear()：清空Hashtable中的所有键值对。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-6-Properties\"><a href=\"#4-6-Properties\" class=\"headerlink\" title=\"4.6 Properties\"></a>4.6 Properties</h2><ul>\n<li><strong>概念</strong>：继承自Hashtable类，用于处理属性文件（.properties）的操作。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code> 不安全</code></li>\n<li>可否为null：<code>允许存储null键和null值</code>。</li>\n<li>可否元素重复：<code>允许重复</code>的键，值也可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 </li>\n<li>getProperty(String key)：根据键获取属性的值。 </li>\n<li>getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 </li>\n<li>load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 </li>\n<li>store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 </li>\n<li>getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 </li>\n<li>stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 </li>\n<li>remove(Object key)：根据键移除属性。 </li>\n<li>containsKey(Object key)：检查属性列表是否包含指定的键。 </li>\n<li>containsValue(Object value)：检查属性列表是否包含指定的值。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"五、Queue-接口\"><a href=\"#五、Queue-接口\" class=\"headerlink\" title=\"五、Queue 接口\"></a>五、Queue 接口</h1><h2 id=\"5-1-总述\"><a href=\"#5-1-总述\" class=\"headerlink\" title=\"5.1 总述\"></a>5.1 总述</h2><ul>\n<li><strong>概念</strong>：用于表示队列（先进先出）的接口，即保存元素的集合。</li>\n<li><strong>特点</strong>：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。</li>\n<li>ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。</li>\n<li>PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-LinkedList\"><a href=\"#5-2-LinkedList\" class=\"headerlink\" title=\"5.2 LinkedList\"></a>5.2 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。 </li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。 </li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。 </li>\n<li>remove()：移除并返回链表的第一个元素。 </li>\n<li>removeFirst()：移除并返回链表的第一个元素。 </li>\n<li>removeLast()：移除并返回链表的最后一个元素。 </li>\n<li>get(int index)：返回链表指定位置处的元素。 </li>\n<li>getFirst()：返回链表的第一个元素，但不移除。 </li>\n<li>getLast()：返回链表的最后一个元素，但不移除。 </li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-3-ArrayDeque\"><a href=\"#5-3-ArrayDeque\" class=\"headerlink\" title=\"5.3 ArrayDeque\"></a>5.3 ArrayDeque</h2><ul>\n<li><strong>概念</strong>：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的<code>2倍</code>。</li>\n<li>底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>addFirst(E element)：将指定元素插入到双端队列的头部。</li>\n<li>addLast(E element)：将指定元素插入到双端队列的尾部。 </li>\n<li>offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 </li>\n<li>offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 </li>\n<li>removeFirst()：移除并返回双端队列的头部元素。 </li>\n<li>removeLast()：移除并返回双端队列的尾部元素。 </li>\n<li>pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>getFirst()：返回双端队列的头部元素，但不移除。 </li>\n<li>getLast()：返回双端队列的尾部元素，但不移除。 </li>\n<li>peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>size()：获取双端队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查双端队列是否为空。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-4-PriorityQueue\"><a href=\"#5-4-PriorityQueue\" class=\"headerlink\" title=\"5.4 PriorityQueue\"></a>5.4 PriorityQueue</h2><ul>\n<li><strong>概念</strong>：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素按照优先级进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会根据策略进行自动扩容。</li>\n<li>底层原理：通常使用<code>堆（Heap）</code>数据结构来实现，具体可以是<code>二叉堆</code>或<code>斐波那契堆</code>等。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element) / offer(E element)：将指定元素插入到队列中。 </li>\n<li>remove() / poll()：移除并返回队列头部的元素。 </li>\n<li>peek()：返回队列头部的元素，但不移除。 </li>\n<li>size()：获取队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查队列是否为空。 </li>\n<li>clear()：清空队列中的所有元素。 </li>\n<li>iterator()：返回用于遍历队列的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h1><ul>\n<li>当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。<ol>\n<li><code>List接口</code>实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 </li>\n<li><code>Set接口</code>实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 </li>\n<li><code>Map接口</code>实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 </li>\n<li><code>Queue接口</code>实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。</li>\n</ol>\n</li>\n<li>Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。</li>\n</ul>\n"},{"title":"初识 Kotlin","date":"2023-04-08T00:00:00.000Z","description":"Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/8076fbdd283d34cfd1b67d534375c513.jpeg","_content":"\n# 一、为什么要学习Kotlin？\n\n## 1.1 更加简洁的语法\n\n- Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。\n\n1. **简化的字符串模版**\n   在 Kotlin 中，我们可以使用 \"$\" 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。\n   例如：\n\n```kotlin\nval name = \"Kotlin\"\nprintln(\"Hello, $name!\") // prints \"Hello, Kotlin!\"\n```\n\n2. **数据类**\n   在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和\n   hashCode() 等一些通用的方法，减少了我们写重复代码的机会。\n   例如：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\n3. **Lambda 表达式**\n   Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。\n   例如：\n\n```kotlin\nval fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\nfruits.filter { it.startsWith(\"a\") }\n    .sortedBy { it }\n    .map { it.toUpperCase() }\n    .forEach { println(it) }\n``` \n\n## 1.2 更好的安全性\n\n- Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。\n\n1. **空安全**\n\n- 在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 \"?\" 操作符来标识可空性。\n  例如，以下代码中的变量 maybeNull 就可以为空：\n\n```kotlin\nvar maybeNull: String? = null\n```\n\n- 如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用\"!!\" 操作符来进行转换。如下例：\n\n```kotlin\nvar notNullVar: String?\nnotNullVar = \"Hello World\" // 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）\nvar length = notNullVar!!.length // 使用 !! 操作符将 notNullVar 转换为非空类型\n```\n\n- 通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。\n\n2. **类型推断**\n\n- Kotlin 会自动推断变量的类型。\n  例如，以下代码中的变量 name 的类型是 String：\n\n```kotlin\nval name = \"Kotlin\"\n```\n\n- 这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。\n\n3. **严格的空安全检查**\n\n- Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。\n  如，以下代码会得到编译时错误：\n\n```kotlin\n// 可能为空的变量\nvar maybeNull: String?\n// 访问变量，需要进行非空检查\nprintln(maybeNull.length)\n```\n\n- 以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 \"?\" 来实现：\n\n```kotlin\nprintln(maybeNull?.length)\n```\n\n- 这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。\n\n## 1.3 更好的互操作性\n\n- Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。\n\n1. **兼容 Java 类库和框架**\n\n- Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java\n  应用程序一起部署和运行。\n\n2. **直接使用 Java 类和方法**\n\n- 在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：\n\n```kotlin\nval pi = Math.PI\n```\n\n3. **使用 JavaBean**\n\n- 在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：\n\n```kotlin\nclass Person {\n    var name: String? = null\n    var age: Int = 0\n}\n```\n\n- 由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。\n\n4. **Kotlin 和 Java 代码混合编写**\n\n- Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。\n\n## 1.4 更加良好的函数式编程体验\n\n- Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。\n\n1. **支持函数类型**\n\n- 在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：\n\n```kotlin\nval sum: (Int, Int) -> Int = { x, y -> x + y }\n```\n\n- 这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -> Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。\n\n2. **高阶函数**\n\n- Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：\n\n```kotlin\nfun <T> List<T>.filter(predicate: (T) -> Boolean): List<T> {\n    val result = mutableListOf<T>()\n    for (item in this) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n```\n\n- 该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。\n\n3. **Lambda 表达式**\n\n- Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval evenNumbers = numbers.filter { it % 2 == 0 }\n```\n\n- 以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。\n\n4. **常用函数式操作符**\n\n- Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。\n\n# 二、 Kotlin 的应用场景\n\n- 由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：\n\n## 2.1 Android 开发\n\n- Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda\n  表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。\n\n## 2.2 Web 开发\n\n- Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如\n  Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。\n\n## 2.3 数据分析\n\n- Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark\n  配合使用，可以实现高效的数据处理和可视化。\n\n## 2.4 游戏开发\n\n- Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin\n  作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin\n  进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。\n\n# 三、总结\n\n- 作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。\n- Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android\n  开发中，Kotlin 已经成为了一种备受热爱的编程语言。\n- 总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。\n- 即使是初学者，也可以通过阅读 [Kotlin 的官方文档和教程](https://www.kotlincn.net/docs/reference/)\n  来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。\n      ","source":"_posts/Kotlin_01_初识Kotlin.md","raw":"---\ntitle: '初识 Kotlin'\ndate: '2023-04-08'\ndescription: 'Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/8076fbdd283d34cfd1b67d534375c513.jpeg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n# 一、为什么要学习Kotlin？\n\n## 1.1 更加简洁的语法\n\n- Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。\n\n1. **简化的字符串模版**\n   在 Kotlin 中，我们可以使用 \"$\" 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。\n   例如：\n\n```kotlin\nval name = \"Kotlin\"\nprintln(\"Hello, $name!\") // prints \"Hello, Kotlin!\"\n```\n\n2. **数据类**\n   在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和\n   hashCode() 等一些通用的方法，减少了我们写重复代码的机会。\n   例如：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\n3. **Lambda 表达式**\n   Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。\n   例如：\n\n```kotlin\nval fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\nfruits.filter { it.startsWith(\"a\") }\n    .sortedBy { it }\n    .map { it.toUpperCase() }\n    .forEach { println(it) }\n``` \n\n## 1.2 更好的安全性\n\n- Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。\n\n1. **空安全**\n\n- 在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 \"?\" 操作符来标识可空性。\n  例如，以下代码中的变量 maybeNull 就可以为空：\n\n```kotlin\nvar maybeNull: String? = null\n```\n\n- 如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用\"!!\" 操作符来进行转换。如下例：\n\n```kotlin\nvar notNullVar: String?\nnotNullVar = \"Hello World\" // 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）\nvar length = notNullVar!!.length // 使用 !! 操作符将 notNullVar 转换为非空类型\n```\n\n- 通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。\n\n2. **类型推断**\n\n- Kotlin 会自动推断变量的类型。\n  例如，以下代码中的变量 name 的类型是 String：\n\n```kotlin\nval name = \"Kotlin\"\n```\n\n- 这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。\n\n3. **严格的空安全检查**\n\n- Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。\n  如，以下代码会得到编译时错误：\n\n```kotlin\n// 可能为空的变量\nvar maybeNull: String?\n// 访问变量，需要进行非空检查\nprintln(maybeNull.length)\n```\n\n- 以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 \"?\" 来实现：\n\n```kotlin\nprintln(maybeNull?.length)\n```\n\n- 这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。\n\n## 1.3 更好的互操作性\n\n- Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。\n\n1. **兼容 Java 类库和框架**\n\n- Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java\n  应用程序一起部署和运行。\n\n2. **直接使用 Java 类和方法**\n\n- 在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：\n\n```kotlin\nval pi = Math.PI\n```\n\n3. **使用 JavaBean**\n\n- 在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：\n\n```kotlin\nclass Person {\n    var name: String? = null\n    var age: Int = 0\n}\n```\n\n- 由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。\n\n4. **Kotlin 和 Java 代码混合编写**\n\n- Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。\n\n## 1.4 更加良好的函数式编程体验\n\n- Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。\n\n1. **支持函数类型**\n\n- 在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：\n\n```kotlin\nval sum: (Int, Int) -> Int = { x, y -> x + y }\n```\n\n- 这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -> Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。\n\n2. **高阶函数**\n\n- Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：\n\n```kotlin\nfun <T> List<T>.filter(predicate: (T) -> Boolean): List<T> {\n    val result = mutableListOf<T>()\n    for (item in this) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n```\n\n- 该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。\n\n3. **Lambda 表达式**\n\n- Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval evenNumbers = numbers.filter { it % 2 == 0 }\n```\n\n- 以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。\n\n4. **常用函数式操作符**\n\n- Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。\n\n# 二、 Kotlin 的应用场景\n\n- 由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：\n\n## 2.1 Android 开发\n\n- Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda\n  表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。\n\n## 2.2 Web 开发\n\n- Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如\n  Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。\n\n## 2.3 数据分析\n\n- Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark\n  配合使用，可以实现高效的数据处理和可视化。\n\n## 2.4 游戏开发\n\n- Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin\n  作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin\n  进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。\n\n# 三、总结\n\n- 作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。\n- Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android\n  开发中，Kotlin 已经成为了一种备受热爱的编程语言。\n- 总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。\n- 即使是初学者，也可以通过阅读 [Kotlin 的官方文档和教程](https://www.kotlincn.net/docs/reference/)\n  来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。\n      ","slug":"Kotlin_01_初识Kotlin","published":1,"updated":"2023-09-25T07:01:31.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji4z000327hogtlp8z7l","content":"<h1 id=\"一、为什么要学习Kotlin？\"><a href=\"#一、为什么要学习Kotlin？\" class=\"headerlink\" title=\"一、为什么要学习Kotlin？\"></a>一、为什么要学习Kotlin？</h1><h2 id=\"1-1-更加简洁的语法\"><a href=\"#1-1-更加简洁的语法\" class=\"headerlink\" title=\"1.1 更加简洁的语法\"></a>1.1 更加简洁的语法</h2><ul>\n<li>Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。</li>\n</ul>\n<ol>\n<li><strong>简化的字符串模版</strong><br>在 Kotlin 中，我们可以使用 “$” 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br><span class=\"line\">println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>) <span class=\"comment\">// prints &quot;Hello, Kotlin!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>数据类</strong><br>在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和<br>hashCode() 等一些通用的方法，减少了我们写重复代码的机会。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong><br>Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fruits = listOf(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"string\">&quot;avocado&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;kiwifruit&quot;</span>)</span><br><span class=\"line\">fruits.filter &#123; it.startsWith(<span class=\"string\">&quot;a&quot;</span>) &#125;</span><br><span class=\"line\">    .sortedBy &#123; it &#125;</span><br><span class=\"line\">    .map &#123; it.toUpperCase() &#125;</span><br><span class=\"line\">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-更好的安全性\"><a href=\"#1-2-更好的安全性\" class=\"headerlink\" title=\"1.2 更好的安全性\"></a>1.2 更好的安全性</h2><ul>\n<li>Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。</li>\n</ul>\n<ol>\n<li><strong>空安全</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 “?” 操作符来标识可空性。<br>例如，以下代码中的变量 maybeNull 就可以为空：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String? = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用”!!” 操作符来进行转换。如下例：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> notNullVar: String?</span><br><span class=\"line\">notNullVar = <span class=\"string\">&quot;Hello World&quot;</span> <span class=\"comment\">// 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> length = notNullVar!!.length <span class=\"comment\">// 使用 !! 操作符将 notNullVar 转换为非空类型</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>类型推断</strong></li>\n</ol>\n<ul>\n<li>Kotlin 会自动推断变量的类型。<br>例如，以下代码中的变量 name 的类型是 String：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>严格的空安全检查</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。<br>如，以下代码会得到编译时错误：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可能为空的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String?</span><br><span class=\"line\"><span class=\"comment\">// 访问变量，需要进行非空检查</span></span><br><span class=\"line\">println(maybeNull.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 “?” 来实现：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(maybeNull?.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。</li>\n</ul>\n<h2 id=\"1-3-更好的互操作性\"><a href=\"#1-3-更好的互操作性\" class=\"headerlink\" title=\"1.3 更好的互操作性\"></a>1.3 更好的互操作性</h2><ul>\n<li>Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。</li>\n</ul>\n<ol>\n<li><strong>兼容 Java 类库和框架</strong></li>\n</ol>\n<ul>\n<li>Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java<br>应用程序一起部署和运行。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>直接使用 Java 类和方法</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pi = Math.PI</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>使用 JavaBean</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Kotlin 和 Java 代码混合编写</strong></li>\n</ol>\n<ul>\n<li>Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。</li>\n</ul>\n<h2 id=\"1-4-更加良好的函数式编程体验\"><a href=\"#1-4-更加良好的函数式编程体验\" class=\"headerlink\" title=\"1.4 更加良好的函数式编程体验\"></a>1.4 更加良好的函数式编程体验</h2><ul>\n<li>Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。</li>\n</ul>\n<ol>\n<li><strong>支持函数类型</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sum: (<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -&gt; Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>高阶函数</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">filter</span><span class=\"params\">(predicate: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = mutableListOf&lt;T&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            result.add(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> evenNumbers = numbers.filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用函数式操作符</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。</li>\n</ul>\n<h1 id=\"二、-Kotlin-的应用场景\"><a href=\"#二、-Kotlin-的应用场景\" class=\"headerlink\" title=\"二、 Kotlin 的应用场景\"></a>二、 Kotlin 的应用场景</h1><ul>\n<li>由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：</li>\n</ul>\n<h2 id=\"2-1-Android-开发\"><a href=\"#2-1-Android-开发\" class=\"headerlink\" title=\"2.1 Android 开发\"></a>2.1 Android 开发</h2><ul>\n<li>Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda<br>表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。</li>\n</ul>\n<h2 id=\"2-2-Web-开发\"><a href=\"#2-2-Web-开发\" class=\"headerlink\" title=\"2.2 Web 开发\"></a>2.2 Web 开发</h2><ul>\n<li>Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如<br>Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。</li>\n</ul>\n<h2 id=\"2-3-数据分析\"><a href=\"#2-3-数据分析\" class=\"headerlink\" title=\"2.3 数据分析\"></a>2.3 数据分析</h2><ul>\n<li>Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark<br>配合使用，可以实现高效的数据处理和可视化。</li>\n</ul>\n<h2 id=\"2-4-游戏开发\"><a href=\"#2-4-游戏开发\" class=\"headerlink\" title=\"2.4 游戏开发\"></a>2.4 游戏开发</h2><ul>\n<li>Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin<br>作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin<br>进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。</li>\n<li>Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android<br>开发中，Kotlin 已经成为了一种备受热爱的编程语言。</li>\n<li>总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。</li>\n<li>即使是初学者，也可以通过阅读 <a href=\"https://www.kotlincn.net/docs/reference/\">Kotlin 的官方文档和教程</a><br>来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、为什么要学习Kotlin？\"><a href=\"#一、为什么要学习Kotlin？\" class=\"headerlink\" title=\"一、为什么要学习Kotlin？\"></a>一、为什么要学习Kotlin？</h1><h2 id=\"1-1-更加简洁的语法\"><a href=\"#1-1-更加简洁的语法\" class=\"headerlink\" title=\"1.1 更加简洁的语法\"></a>1.1 更加简洁的语法</h2><ul>\n<li>Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。</li>\n</ul>\n<ol>\n<li><strong>简化的字符串模版</strong><br>在 Kotlin 中，我们可以使用 “$” 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br><span class=\"line\">println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>) <span class=\"comment\">// prints &quot;Hello, Kotlin!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>数据类</strong><br>在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和<br>hashCode() 等一些通用的方法，减少了我们写重复代码的机会。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong><br>Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fruits = listOf(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"string\">&quot;avocado&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;kiwifruit&quot;</span>)</span><br><span class=\"line\">fruits.filter &#123; it.startsWith(<span class=\"string\">&quot;a&quot;</span>) &#125;</span><br><span class=\"line\">    .sortedBy &#123; it &#125;</span><br><span class=\"line\">    .map &#123; it.toUpperCase() &#125;</span><br><span class=\"line\">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-更好的安全性\"><a href=\"#1-2-更好的安全性\" class=\"headerlink\" title=\"1.2 更好的安全性\"></a>1.2 更好的安全性</h2><ul>\n<li>Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。</li>\n</ul>\n<ol>\n<li><strong>空安全</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 “?” 操作符来标识可空性。<br>例如，以下代码中的变量 maybeNull 就可以为空：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String? = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用”!!” 操作符来进行转换。如下例：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> notNullVar: String?</span><br><span class=\"line\">notNullVar = <span class=\"string\">&quot;Hello World&quot;</span> <span class=\"comment\">// 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> length = notNullVar!!.length <span class=\"comment\">// 使用 !! 操作符将 notNullVar 转换为非空类型</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>类型推断</strong></li>\n</ol>\n<ul>\n<li>Kotlin 会自动推断变量的类型。<br>例如，以下代码中的变量 name 的类型是 String：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>严格的空安全检查</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。<br>如，以下代码会得到编译时错误：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可能为空的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String?</span><br><span class=\"line\"><span class=\"comment\">// 访问变量，需要进行非空检查</span></span><br><span class=\"line\">println(maybeNull.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 “?” 来实现：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(maybeNull?.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。</li>\n</ul>\n<h2 id=\"1-3-更好的互操作性\"><a href=\"#1-3-更好的互操作性\" class=\"headerlink\" title=\"1.3 更好的互操作性\"></a>1.3 更好的互操作性</h2><ul>\n<li>Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。</li>\n</ul>\n<ol>\n<li><strong>兼容 Java 类库和框架</strong></li>\n</ol>\n<ul>\n<li>Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java<br>应用程序一起部署和运行。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>直接使用 Java 类和方法</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pi = Math.PI</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>使用 JavaBean</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Kotlin 和 Java 代码混合编写</strong></li>\n</ol>\n<ul>\n<li>Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。</li>\n</ul>\n<h2 id=\"1-4-更加良好的函数式编程体验\"><a href=\"#1-4-更加良好的函数式编程体验\" class=\"headerlink\" title=\"1.4 更加良好的函数式编程体验\"></a>1.4 更加良好的函数式编程体验</h2><ul>\n<li>Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。</li>\n</ul>\n<ol>\n<li><strong>支持函数类型</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sum: (<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -&gt; Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>高阶函数</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">filter</span><span class=\"params\">(predicate: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = mutableListOf&lt;T&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            result.add(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> evenNumbers = numbers.filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用函数式操作符</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。</li>\n</ul>\n<h1 id=\"二、-Kotlin-的应用场景\"><a href=\"#二、-Kotlin-的应用场景\" class=\"headerlink\" title=\"二、 Kotlin 的应用场景\"></a>二、 Kotlin 的应用场景</h1><ul>\n<li>由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：</li>\n</ul>\n<h2 id=\"2-1-Android-开发\"><a href=\"#2-1-Android-开发\" class=\"headerlink\" title=\"2.1 Android 开发\"></a>2.1 Android 开发</h2><ul>\n<li>Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda<br>表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。</li>\n</ul>\n<h2 id=\"2-2-Web-开发\"><a href=\"#2-2-Web-开发\" class=\"headerlink\" title=\"2.2 Web 开发\"></a>2.2 Web 开发</h2><ul>\n<li>Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如<br>Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。</li>\n</ul>\n<h2 id=\"2-3-数据分析\"><a href=\"#2-3-数据分析\" class=\"headerlink\" title=\"2.3 数据分析\"></a>2.3 数据分析</h2><ul>\n<li>Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark<br>配合使用，可以实现高效的数据处理和可视化。</li>\n</ul>\n<h2 id=\"2-4-游戏开发\"><a href=\"#2-4-游戏开发\" class=\"headerlink\" title=\"2.4 游戏开发\"></a>2.4 游戏开发</h2><ul>\n<li>Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin<br>作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin<br>进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。</li>\n<li>Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android<br>开发中，Kotlin 已经成为了一种备受热爱的编程语言。</li>\n<li>总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。</li>\n<li>即使是初学者，也可以通过阅读 <a href=\"https://www.kotlincn.net/docs/reference/\">Kotlin 的官方文档和教程</a><br>来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。</li>\n</ul>\n"},{"title":"Kotlin 函数式编程思想概述","date":"2023-04-10T00:00:00.000Z","description":"函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oxuwrS.webp","_content":"\n# 一、函数式编程\n\n## 1.1 函数式编程的概念\n\n- 函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda\n  表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。\n- 与传统的命令式编程（Imperative\n  Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。\n- 在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation\n  的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。\n\n## 1.2 函数和方法的区别\n\n在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。\n\n- 函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。\n- 方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。\n\n在面向对象编程中，方法经常被用来执行某个特定对象的行为，也**经常涉及**到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，**通常不涉及**到类和对象的概念。\n**总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。**\n\n## 1.3 面向对象编程和函数式编程的区别\n\n**面向对象编程**（Object-Oriented Programming，OOP）和**函数式编程**（Functional Programming，FP）是两种不同的编程范式。\n\n### 1.3.1 面向对象编程\n\n面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：**请谈谈你对面向对象编程概念的理解。** 那么什么是对象？什么是面向对象编程呢？\n\n- Java中，\"万物皆对象\"。这样类似的说法有很多，比如 SQL 中：\"万物皆表\"，Git 中：\"万物皆版本\"等等...这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。\n- 那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。\n- \"万物皆对象\"这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。\n- 面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。\n\n### 1.3.2 函数式编程\n\n- 函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n- 在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n- \"函数即数据\"这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。\n- 函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。\n\n### 1.3.3 它们的不同之处\n\n1. 编程思想不同\n   面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n\n2. 松耦合度不同\n   面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。\n\n3. 副作用处理不同\n   副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n\n4. 可变性处理不同\n   面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。\n\n5. 代码风格不同\n   面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。\n\n### 1.3.4 两种编程范式的运用\n\n- 面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。\n- 函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。\n- 可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，**OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。**\n\n# 二、初步接触函数式编程\n\n## Kotlin中函数的众多写法\n\n- 在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：\n\n```java\nclass Fun_ {\n    public int addNumbers(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。\n\n- 接下来我们看一下 Kotlin 中函数的各种花式写法：\n\n1. 普通函数\n\n```kotlin\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n2. 省略返回类型的函数：\n\n```kotlin\nfun multiply(a: Int, b: Int) = a * b\n```\n\n3. 单表达式函数：\n\n```kotlin\nfun isEven(num: Int) = num % 2 == 0\n```\n\n4. 带默认参数的函数：\n\n```kotlin\nfun showMessage(message: String, times: Int = 1) {\n    repeat(times) {\n        println(message)\n    }\n}\n```\n\n5. 带具名参数调用的函数：\n\n```kotlin\nshowMessage(message = \"Hello\", times = 3)\n```\n\n6. 使用 lambda 表达式的函数：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEach { println(it) }\n```\n\n7. 带有高阶函数参数的函数：\n\n```kotlin\nfun processNumbers(numbers: List<Int>, action: (Int) -> Unit) {\n    for (number in numbers) {\n        action(number)\n    }\n}\n\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n8. 使用函数类型别名的函数：\n\n```kotlin\ntypealias Processor = (Int) -> Unit\n\nfun processNumbers(numbers: List<Int>, action: Processor) {\n    for (number in numbers) {\n        action(number)\n    }\n}\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n- 没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。\n- Kotlin 中的函数可以具有**默认参数、具名参数调用、扩展函数、局部函数**等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。\n- 见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。\n- 它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。\n\n# 三、总结\n\n- 在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。\n- 还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。\n- 你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！","source":"_posts/Kotlin_02_Kotlin函数式编程思想概述.md","raw":"---\ntitle: 'Kotlin 函数式编程思想概述'\ndate: '2023-04-10'\ndescription: '函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oxuwrS.webp'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程 \n\n---\n\n# 一、函数式编程\n\n## 1.1 函数式编程的概念\n\n- 函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda\n  表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。\n- 与传统的命令式编程（Imperative\n  Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。\n- 在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation\n  的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。\n\n## 1.2 函数和方法的区别\n\n在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。\n\n- 函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。\n- 方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。\n\n在面向对象编程中，方法经常被用来执行某个特定对象的行为，也**经常涉及**到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，**通常不涉及**到类和对象的概念。\n**总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。**\n\n## 1.3 面向对象编程和函数式编程的区别\n\n**面向对象编程**（Object-Oriented Programming，OOP）和**函数式编程**（Functional Programming，FP）是两种不同的编程范式。\n\n### 1.3.1 面向对象编程\n\n面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：**请谈谈你对面向对象编程概念的理解。** 那么什么是对象？什么是面向对象编程呢？\n\n- Java中，\"万物皆对象\"。这样类似的说法有很多，比如 SQL 中：\"万物皆表\"，Git 中：\"万物皆版本\"等等...这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。\n- 那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。\n- \"万物皆对象\"这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。\n- 面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。\n\n### 1.3.2 函数式编程\n\n- 函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n- 在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n- \"函数即数据\"这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。\n- 函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。\n\n### 1.3.3 它们的不同之处\n\n1. 编程思想不同\n   面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n\n2. 松耦合度不同\n   面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。\n\n3. 副作用处理不同\n   副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n\n4. 可变性处理不同\n   面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。\n\n5. 代码风格不同\n   面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。\n\n### 1.3.4 两种编程范式的运用\n\n- 面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。\n- 函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。\n- 可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，**OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。**\n\n# 二、初步接触函数式编程\n\n## Kotlin中函数的众多写法\n\n- 在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：\n\n```java\nclass Fun_ {\n    public int addNumbers(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。\n\n- 接下来我们看一下 Kotlin 中函数的各种花式写法：\n\n1. 普通函数\n\n```kotlin\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n2. 省略返回类型的函数：\n\n```kotlin\nfun multiply(a: Int, b: Int) = a * b\n```\n\n3. 单表达式函数：\n\n```kotlin\nfun isEven(num: Int) = num % 2 == 0\n```\n\n4. 带默认参数的函数：\n\n```kotlin\nfun showMessage(message: String, times: Int = 1) {\n    repeat(times) {\n        println(message)\n    }\n}\n```\n\n5. 带具名参数调用的函数：\n\n```kotlin\nshowMessage(message = \"Hello\", times = 3)\n```\n\n6. 使用 lambda 表达式的函数：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEach { println(it) }\n```\n\n7. 带有高阶函数参数的函数：\n\n```kotlin\nfun processNumbers(numbers: List<Int>, action: (Int) -> Unit) {\n    for (number in numbers) {\n        action(number)\n    }\n}\n\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n8. 使用函数类型别名的函数：\n\n```kotlin\ntypealias Processor = (Int) -> Unit\n\nfun processNumbers(numbers: List<Int>, action: Processor) {\n    for (number in numbers) {\n        action(number)\n    }\n}\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n- 没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。\n- Kotlin 中的函数可以具有**默认参数、具名参数调用、扩展函数、局部函数**等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。\n- 见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。\n- 它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。\n\n# 三、总结\n\n- 在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。\n- 还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。\n- 你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！","slug":"Kotlin_02_Kotlin函数式编程思想概述","published":1,"updated":"2023-09-25T06:59:38.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji53000727ho3orq721x","content":"<h1 id=\"一、函数式编程\"><a href=\"#一、函数式编程\" class=\"headerlink\" title=\"一、函数式编程\"></a>一、函数式编程</h1><h2 id=\"1-1-函数式编程的概念\"><a href=\"#1-1-函数式编程的概念\" class=\"headerlink\" title=\"1.1 函数式编程的概念\"></a>1.1 函数式编程的概念</h2><ul>\n<li>函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda<br>表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。</li>\n<li>与传统的命令式编程（Imperative<br>Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。</li>\n<li>在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation<br>的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。</li>\n</ul>\n<h2 id=\"1-2-函数和方法的区别\"><a href=\"#1-2-函数和方法的区别\" class=\"headerlink\" title=\"1.2 函数和方法的区别\"></a>1.2 函数和方法的区别</h2><p>在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。</p>\n<ul>\n<li>函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。</li>\n<li>方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。</li>\n</ul>\n<p>在面向对象编程中，方法经常被用来执行某个特定对象的行为，也<strong>经常涉及</strong>到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，<strong>通常不涉及</strong>到类和对象的概念。<br><strong>总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。</strong></p>\n<h2 id=\"1-3-面向对象编程和函数式编程的区别\"><a href=\"#1-3-面向对象编程和函数式编程的区别\" class=\"headerlink\" title=\"1.3 面向对象编程和函数式编程的区别\"></a>1.3 面向对象编程和函数式编程的区别</h2><p><strong>面向对象编程</strong>（Object-Oriented Programming，OOP）和<strong>函数式编程</strong>（Functional Programming，FP）是两种不同的编程范式。</p>\n<h3 id=\"1-3-1-面向对象编程\"><a href=\"#1-3-1-面向对象编程\" class=\"headerlink\" title=\"1.3.1 面向对象编程\"></a>1.3.1 面向对象编程</h3><p>面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：<strong>请谈谈你对面向对象编程概念的理解。</strong> 那么什么是对象？什么是面向对象编程呢？</p>\n<ul>\n<li>Java中，”万物皆对象”。这样类似的说法有很多，比如 SQL 中：”万物皆表”，Git 中：”万物皆版本”等等…这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。</li>\n<li>那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。</li>\n<li>“万物皆对象”这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。</li>\n<li>面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。</li>\n</ul>\n<h3 id=\"1-3-2-函数式编程\"><a href=\"#1-3-2-函数式编程\" class=\"headerlink\" title=\"1.3.2 函数式编程\"></a>1.3.2 函数式编程</h3><ul>\n<li>函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</li>\n<li>在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</li>\n<li>“函数即数据”这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。</li>\n<li>函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。</li>\n</ul>\n<h3 id=\"1-3-3-它们的不同之处\"><a href=\"#1-3-3-它们的不同之处\" class=\"headerlink\" title=\"1.3.3 它们的不同之处\"></a>1.3.3 它们的不同之处</h3><ol>\n<li><p>编程思想不同<br>面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</p>\n</li>\n<li><p>松耦合度不同<br>面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。</p>\n</li>\n<li><p>副作用处理不同<br>副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</p>\n</li>\n<li><p>可变性处理不同<br>面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。</p>\n</li>\n<li><p>代码风格不同<br>面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。</p>\n</li>\n</ol>\n<h3 id=\"1-3-4-两种编程范式的运用\"><a href=\"#1-3-4-两种编程范式的运用\" class=\"headerlink\" title=\"1.3.4 两种编程范式的运用\"></a>1.3.4 两种编程范式的运用</h3><ul>\n<li>面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。</li>\n<li>函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。</li>\n<li>可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，<strong>OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。</strong></li>\n</ul>\n<h1 id=\"二、初步接触函数式编程\"><a href=\"#二、初步接触函数式编程\" class=\"headerlink\" title=\"二、初步接触函数式编程\"></a>二、初步接触函数式编程</h1><h2 id=\"Kotlin中函数的众多写法\"><a href=\"#Kotlin中函数的众多写法\" class=\"headerlink\" title=\"Kotlin中函数的众多写法\"></a>Kotlin中函数的众多写法</h2><ul>\n<li>在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fun_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">addNumbers</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。</p>\n<ul>\n<li>接下来我们看一下 Kotlin 中函数的各种花式写法：</li>\n</ul>\n<ol>\n<li>普通函数</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>省略返回类型的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">multiply</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span> = a * b</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>单表达式函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isEven</span><span class=\"params\">(num: <span class=\"type\">Int</span>)</span></span> = num % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>带默认参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showMessage</span><span class=\"params\">(message: <span class=\"type\">String</span>, times: <span class=\"type\">Int</span> = <span class=\"number\">1</span>)</span></span> &#123;</span><br><span class=\"line\">    repeat(times) &#123;</span><br><span class=\"line\">        println(message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>带具名参数调用的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showMessage(message = <span class=\"string\">&quot;Hello&quot;</span>, times = <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>使用 lambda 表达式的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">numbers.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>带有高阶函数参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>使用函数类型别名的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Processor = (<span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: <span class=\"type\">Processor</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。</li>\n<li>Kotlin 中的函数可以具有<strong>默认参数、具名参数调用、扩展函数、局部函数</strong>等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。</li>\n<li>见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。</li>\n<li>它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。</li>\n<li>还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。</li>\n<li>你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、函数式编程\"><a href=\"#一、函数式编程\" class=\"headerlink\" title=\"一、函数式编程\"></a>一、函数式编程</h1><h2 id=\"1-1-函数式编程的概念\"><a href=\"#1-1-函数式编程的概念\" class=\"headerlink\" title=\"1.1 函数式编程的概念\"></a>1.1 函数式编程的概念</h2><ul>\n<li>函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda<br>表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。</li>\n<li>与传统的命令式编程（Imperative<br>Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。</li>\n<li>在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation<br>的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。</li>\n</ul>\n<h2 id=\"1-2-函数和方法的区别\"><a href=\"#1-2-函数和方法的区别\" class=\"headerlink\" title=\"1.2 函数和方法的区别\"></a>1.2 函数和方法的区别</h2><p>在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。</p>\n<ul>\n<li>函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。</li>\n<li>方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。</li>\n</ul>\n<p>在面向对象编程中，方法经常被用来执行某个特定对象的行为，也<strong>经常涉及</strong>到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，<strong>通常不涉及</strong>到类和对象的概念。<br><strong>总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。</strong></p>\n<h2 id=\"1-3-面向对象编程和函数式编程的区别\"><a href=\"#1-3-面向对象编程和函数式编程的区别\" class=\"headerlink\" title=\"1.3 面向对象编程和函数式编程的区别\"></a>1.3 面向对象编程和函数式编程的区别</h2><p><strong>面向对象编程</strong>（Object-Oriented Programming，OOP）和<strong>函数式编程</strong>（Functional Programming，FP）是两种不同的编程范式。</p>\n<h3 id=\"1-3-1-面向对象编程\"><a href=\"#1-3-1-面向对象编程\" class=\"headerlink\" title=\"1.3.1 面向对象编程\"></a>1.3.1 面向对象编程</h3><p>面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：<strong>请谈谈你对面向对象编程概念的理解。</strong> 那么什么是对象？什么是面向对象编程呢？</p>\n<ul>\n<li>Java中，”万物皆对象”。这样类似的说法有很多，比如 SQL 中：”万物皆表”，Git 中：”万物皆版本”等等…这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。</li>\n<li>那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。</li>\n<li>“万物皆对象”这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。</li>\n<li>面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。</li>\n</ul>\n<h3 id=\"1-3-2-函数式编程\"><a href=\"#1-3-2-函数式编程\" class=\"headerlink\" title=\"1.3.2 函数式编程\"></a>1.3.2 函数式编程</h3><ul>\n<li>函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</li>\n<li>在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</li>\n<li>“函数即数据”这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。</li>\n<li>函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。</li>\n</ul>\n<h3 id=\"1-3-3-它们的不同之处\"><a href=\"#1-3-3-它们的不同之处\" class=\"headerlink\" title=\"1.3.3 它们的不同之处\"></a>1.3.3 它们的不同之处</h3><ol>\n<li><p>编程思想不同<br>面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</p>\n</li>\n<li><p>松耦合度不同<br>面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。</p>\n</li>\n<li><p>副作用处理不同<br>副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</p>\n</li>\n<li><p>可变性处理不同<br>面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。</p>\n</li>\n<li><p>代码风格不同<br>面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。</p>\n</li>\n</ol>\n<h3 id=\"1-3-4-两种编程范式的运用\"><a href=\"#1-3-4-两种编程范式的运用\" class=\"headerlink\" title=\"1.3.4 两种编程范式的运用\"></a>1.3.4 两种编程范式的运用</h3><ul>\n<li>面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。</li>\n<li>函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。</li>\n<li>可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，<strong>OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。</strong></li>\n</ul>\n<h1 id=\"二、初步接触函数式编程\"><a href=\"#二、初步接触函数式编程\" class=\"headerlink\" title=\"二、初步接触函数式编程\"></a>二、初步接触函数式编程</h1><h2 id=\"Kotlin中函数的众多写法\"><a href=\"#Kotlin中函数的众多写法\" class=\"headerlink\" title=\"Kotlin中函数的众多写法\"></a>Kotlin中函数的众多写法</h2><ul>\n<li>在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fun_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">addNumbers</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。</p>\n<ul>\n<li>接下来我们看一下 Kotlin 中函数的各种花式写法：</li>\n</ul>\n<ol>\n<li>普通函数</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>省略返回类型的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">multiply</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span> = a * b</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>单表达式函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isEven</span><span class=\"params\">(num: <span class=\"type\">Int</span>)</span></span> = num % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>带默认参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showMessage</span><span class=\"params\">(message: <span class=\"type\">String</span>, times: <span class=\"type\">Int</span> = <span class=\"number\">1</span>)</span></span> &#123;</span><br><span class=\"line\">    repeat(times) &#123;</span><br><span class=\"line\">        println(message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>带具名参数调用的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showMessage(message = <span class=\"string\">&quot;Hello&quot;</span>, times = <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>使用 lambda 表达式的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">numbers.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>带有高阶函数参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>使用函数类型别名的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Processor = (<span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: <span class=\"type\">Processor</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。</li>\n<li>Kotlin 中的函数可以具有<strong>默认参数、具名参数调用、扩展函数、局部函数</strong>等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。</li>\n<li>见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。</li>\n<li>它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。</li>\n<li>还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。</li>\n<li>你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！</li>\n</ul>\n"},{"title":"Kotlin 中的空安全设计详解","date":"2023-07-19T00:00:00.000Z","description":"之前对 Kotlin 的基本语法、变量声明、空安全设计和兼容性做了笼统的介绍，今天对其中的空安全设计做一个详细的剖析。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oAMLZr.jpg","_content":"\n# 一、变量\n\n- 在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中`变量声明和赋值`方面的异同。\n- 首先，在 Java 中，声明一个变量的格式是：`<数据类型> <变量名>;`缺一不可，比如：\n\n```java\nclass Sample {\n    int age; // 声明一个整型变量 age\n    String name; // 声明一个字符串型变量 name\n}\n```\n\n- 除了简单声明变量，还可以同时进行初始化，即：`<数据类型> <变量名> = <初始值>;`如：\n\n```java\nclass Sample {\n    int age = 25; // 声明一个整型变量 age，并初始化为 25\n    String name = \"John\"; // 声明一个字符串型变量 name，并初始化为 \"John\"\n}\n```\n\n- 然后，在 Kotlin 中，声明一个变量的格式是：`var <变量名>: <数据类型>`，像这样：\n\n```kotlin\n    var name: String\n```\n\n- 一眼看去和 Java 有几处不同：\n   1. 有一个`var`关键字\n   2. 类型和变量名位置互换了\n   3. 中间是用冒号分隔的\n   4. 结尾没有分号（Kotlin 里面不需要分号）\n\n- 虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：`Property must be initialized or be abstract`。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）\n- 彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？\n\n- 不不不！其实是有原因的，在 Kotlin 中，变量是`没有默认值`的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：\n\n```java\nclass Sample {\n    String name; // 默认值是 null\n    int count; // 默认值是 0\n}\n```\n\n- 好吧，你没有默认值那我给你一个吧，我这样写：\n\n```kotlin\n    var name: String = null\n```\n\n- 哎呀又报错了，IDE 告诉你说：`Null can not be a value of a non-null type View`，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。\n\n# 二、空安全设计\n\n## 2.1 NullPointerException\n\n- 先介绍一个异常：`NullPointerException` - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str = null;\n        System.out.println(str.length()); // 触发 NullPointerException\n    }\n}\n```\n\n- 具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。\n\n## 2.2 空安全设计\n\n- 好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？\n- 简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而`避免 NullPointerException`。\n- 可别小看这一点，单单`避免 NullPointerException`这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。\n- 空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：\n\n```java\nclass Sample {\n    @NonNull\n    View view = null;//IDE 会发出警告：'null' is assigned to a variable that is annotated with @NotNull\n}\n```\n\n- 到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 `warning` 变成了 `error`（拒绝编译）：\n\n```kotlin\n    var view: View = null //IDE 会提示错误，Null can not be a value of a non-null type View\n```\n\n- `在 Kotlin 里面，所有的变量默认都是不允许为空的`，如果你给它赋值 null，就会报错，像上面那样。\n- Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。\n- 这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：\n\n```kotlin\nclass User {\n    var name: String = null // 这样写会报错，但该变量无法保证空与否\n}\n```\n\n- 这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：\n\n```kotlin\nclass User {\n    var name: String? = null\n}\n```\n\n- 加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。\n- 这种类型之后加 ? 的写法，在 Kotlin 里叫`可空类型`。不过，当我们使用了可空类型的变量后，会有新的问题：\n\n```kotlin\n    var view: View? = null\n    view.setBackgroundColor(Color.RED)\n    // 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?\n```\n\n- 对于我们定义的`可能为空`的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：\n\n```kotlin\n    if (view != null) {\n        view.setBackgroundColor(Color.RED)\n        // 这样写也会报错，Smart cast to 'View' is impossible, because 'view' is a mutable property that could have been changed by this time\n    } \n```\n\n- 这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在`多线程`情况下，其他线程可能把它再改成空的。\n- 那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是` . `而是` ?.`：\n\n```kotlin\n    view?.setBackgroundColor(Color.RED)\n```\n\n- 这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到`线程安全`，因此这种写法叫做`safe call`。\n- 另外还有一种双感叹号的用法：\n\n```kotlin\n    view!!.setBackgroundColor(Color.RED)\n```\n\n- 意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 `non-null asserted call`。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。\n- 其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：\n  1. 变量需要手动初始化，如果不初始化的话会报错； \n  2. 变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； \n  3. 变量用 ? 设置为可空的时候，使用的时候因为`可能为空`又报错。\n\n- 关于空安全，最重要的是记住一点：所谓`可空不可空`，关注的全都是`使用的时候`，即`这个变量在使用时是否可能为空`。\n\n- Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：\n\n```kotlin\n  expression ?: defaultValue\n```\n\n- 如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。\n- 一些注意事项：\n  1. defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。\n  2. defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。\n  3. Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c\n  4. Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue\n  5. Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。\n\n- 空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。\n- 但如果你在 MainActivity 里这么写：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    var view: View = findViewById(R.id.tvContent)\n}\n```\n\n- 编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。\n- 那怎么办呢？其实我们很想告诉编译器`我很确定我用的时候绝对不为空，但第一时间我没法给它赋值`。\n- Kotlin 给我们提供了一个选项：`延迟初始化`。\n\n## 2.3 延迟初始化\n\n- 为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：\n\n```kotlin\n    lateinit var view: View\n```\n\n- lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。\n- 它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。\n- 然后我们就可以在 onCreate 中进行初始化了：\n\n```kotlin\n  lateinit var view: View\n  override fun onCreate() {\n      //...\n      view = findViewById(R.id.tvContent)\n  }\n```\n\n- 延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。\n\n## 2.4 类型推断\n\n- 空安全设计到此其实已经差不多讲完了，再补充一点其他内容。\n- Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：\n\n```kotlin\n   var name: String = \"Mike\"//可以直接写成 var name = \"Mike\"\n```\n\n- 这个特性叫做`类型推断`，它跟`动态类型`是不一样的。\n  1. 类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。\n  2. 动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。\n\n## 2.5 val 和 var\n\n- 除了前面提到的 var，我们还可以使用 val 来声明变量：\n\n```kotlin\n    val age = 18\n```\n\n- val 是 Kotlin 在 Java 的`变量`类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。\n- val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。\n\n# 三、总结\n\n- Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。","source":"_posts/Kotlin_03_Kotlin中的空安全设计详解.md","raw":"---\ntitle: 'Kotlin 中的空安全设计详解'\ndate: '2023-07-19'\ndescription: '之前对 Kotlin 的基本语法、变量声明、空安全设计和兼容性做了笼统的介绍，今天对其中的空安全设计做一个详细的剖析。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oAMLZr.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n# 一、变量\n\n- 在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中`变量声明和赋值`方面的异同。\n- 首先，在 Java 中，声明一个变量的格式是：`<数据类型> <变量名>;`缺一不可，比如：\n\n```java\nclass Sample {\n    int age; // 声明一个整型变量 age\n    String name; // 声明一个字符串型变量 name\n}\n```\n\n- 除了简单声明变量，还可以同时进行初始化，即：`<数据类型> <变量名> = <初始值>;`如：\n\n```java\nclass Sample {\n    int age = 25; // 声明一个整型变量 age，并初始化为 25\n    String name = \"John\"; // 声明一个字符串型变量 name，并初始化为 \"John\"\n}\n```\n\n- 然后，在 Kotlin 中，声明一个变量的格式是：`var <变量名>: <数据类型>`，像这样：\n\n```kotlin\n    var name: String\n```\n\n- 一眼看去和 Java 有几处不同：\n   1. 有一个`var`关键字\n   2. 类型和变量名位置互换了\n   3. 中间是用冒号分隔的\n   4. 结尾没有分号（Kotlin 里面不需要分号）\n\n- 虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：`Property must be initialized or be abstract`。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）\n- 彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？\n\n- 不不不！其实是有原因的，在 Kotlin 中，变量是`没有默认值`的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：\n\n```java\nclass Sample {\n    String name; // 默认值是 null\n    int count; // 默认值是 0\n}\n```\n\n- 好吧，你没有默认值那我给你一个吧，我这样写：\n\n```kotlin\n    var name: String = null\n```\n\n- 哎呀又报错了，IDE 告诉你说：`Null can not be a value of a non-null type View`，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。\n\n# 二、空安全设计\n\n## 2.1 NullPointerException\n\n- 先介绍一个异常：`NullPointerException` - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str = null;\n        System.out.println(str.length()); // 触发 NullPointerException\n    }\n}\n```\n\n- 具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。\n\n## 2.2 空安全设计\n\n- 好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？\n- 简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而`避免 NullPointerException`。\n- 可别小看这一点，单单`避免 NullPointerException`这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。\n- 空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：\n\n```java\nclass Sample {\n    @NonNull\n    View view = null;//IDE 会发出警告：'null' is assigned to a variable that is annotated with @NotNull\n}\n```\n\n- 到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 `warning` 变成了 `error`（拒绝编译）：\n\n```kotlin\n    var view: View = null //IDE 会提示错误，Null can not be a value of a non-null type View\n```\n\n- `在 Kotlin 里面，所有的变量默认都是不允许为空的`，如果你给它赋值 null，就会报错，像上面那样。\n- Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。\n- 这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：\n\n```kotlin\nclass User {\n    var name: String = null // 这样写会报错，但该变量无法保证空与否\n}\n```\n\n- 这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：\n\n```kotlin\nclass User {\n    var name: String? = null\n}\n```\n\n- 加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。\n- 这种类型之后加 ? 的写法，在 Kotlin 里叫`可空类型`。不过，当我们使用了可空类型的变量后，会有新的问题：\n\n```kotlin\n    var view: View? = null\n    view.setBackgroundColor(Color.RED)\n    // 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?\n```\n\n- 对于我们定义的`可能为空`的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：\n\n```kotlin\n    if (view != null) {\n        view.setBackgroundColor(Color.RED)\n        // 这样写也会报错，Smart cast to 'View' is impossible, because 'view' is a mutable property that could have been changed by this time\n    } \n```\n\n- 这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在`多线程`情况下，其他线程可能把它再改成空的。\n- 那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是` . `而是` ?.`：\n\n```kotlin\n    view?.setBackgroundColor(Color.RED)\n```\n\n- 这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到`线程安全`，因此这种写法叫做`safe call`。\n- 另外还有一种双感叹号的用法：\n\n```kotlin\n    view!!.setBackgroundColor(Color.RED)\n```\n\n- 意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 `non-null asserted call`。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。\n- 其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：\n  1. 变量需要手动初始化，如果不初始化的话会报错； \n  2. 变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； \n  3. 变量用 ? 设置为可空的时候，使用的时候因为`可能为空`又报错。\n\n- 关于空安全，最重要的是记住一点：所谓`可空不可空`，关注的全都是`使用的时候`，即`这个变量在使用时是否可能为空`。\n\n- Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：\n\n```kotlin\n  expression ?: defaultValue\n```\n\n- 如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。\n- 一些注意事项：\n  1. defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。\n  2. defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。\n  3. Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c\n  4. Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue\n  5. Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。\n\n- 空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。\n- 但如果你在 MainActivity 里这么写：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    var view: View = findViewById(R.id.tvContent)\n}\n```\n\n- 编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。\n- 那怎么办呢？其实我们很想告诉编译器`我很确定我用的时候绝对不为空，但第一时间我没法给它赋值`。\n- Kotlin 给我们提供了一个选项：`延迟初始化`。\n\n## 2.3 延迟初始化\n\n- 为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：\n\n```kotlin\n    lateinit var view: View\n```\n\n- lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。\n- 它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。\n- 然后我们就可以在 onCreate 中进行初始化了：\n\n```kotlin\n  lateinit var view: View\n  override fun onCreate() {\n      //...\n      view = findViewById(R.id.tvContent)\n  }\n```\n\n- 延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。\n\n## 2.4 类型推断\n\n- 空安全设计到此其实已经差不多讲完了，再补充一点其他内容。\n- Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：\n\n```kotlin\n   var name: String = \"Mike\"//可以直接写成 var name = \"Mike\"\n```\n\n- 这个特性叫做`类型推断`，它跟`动态类型`是不一样的。\n  1. 类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。\n  2. 动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。\n\n## 2.5 val 和 var\n\n- 除了前面提到的 var，我们还可以使用 val 来声明变量：\n\n```kotlin\n    val age = 18\n```\n\n- val 是 Kotlin 在 Java 的`变量`类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。\n- val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。\n\n# 三、总结\n\n- Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。","slug":"Kotlin_03_Kotlin中的空安全设计详解","published":1,"updated":"2023-09-25T06:49:27.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji54000827ho9as8023a","content":"<h1 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h1><ul>\n<li>在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中<code>变量声明和赋值</code>方面的异同。</li>\n<li>首先，在 Java 中，声明一个变量的格式是：<code>&lt;数据类型&gt; &lt;变量名&gt;;</code>缺一不可，比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> age; <span class=\"comment\">// 声明一个整型变量 age</span></span><br><span class=\"line\">    String name; <span class=\"comment\">// 声明一个字符串型变量 name</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>除了简单声明变量，还可以同时进行初始化，即：<code>&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</code>如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">25</span>; <span class=\"comment\">// 声明一个整型变量 age，并初始化为 25</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span>; <span class=\"comment\">// 声明一个字符串型变量 name，并初始化为 &quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后，在 Kotlin 中，声明一个变量的格式是：<code>var &lt;变量名&gt;: &lt;数据类型&gt;</code>，像这样：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>一眼看去和 Java 有几处不同：</p>\n<ol>\n<li>有一个<code>var</code>关键字</li>\n<li>类型和变量名位置互换了</li>\n<li>中间是用冒号分隔的</li>\n<li>结尾没有分号（Kotlin 里面不需要分号）</li>\n</ol>\n</li>\n<li><p>虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：<code>Property must be initialized or be abstract</code>。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）</p>\n</li>\n<li><p>彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？</p>\n</li>\n<li><p>不不不！其实是有原因的，在 Kotlin 中，变量是<code>没有默认值</code>的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    String name; <span class=\"comment\">// 默认值是 null</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">// 默认值是 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>好吧，你没有默认值那我给你一个吧，我这样写：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>哎呀又报错了，IDE 告诉你说：<code>Null can not be a value of a non-null type View</code>，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。</li>\n</ul>\n<h1 id=\"二、空安全设计\"><a href=\"#二、空安全设计\" class=\"headerlink\" title=\"二、空安全设计\"></a>二、空安全设计</h1><h2 id=\"2-1-NullPointerException\"><a href=\"#2-1-NullPointerException\" class=\"headerlink\" title=\"2.1 NullPointerException\"></a>2.1 NullPointerException</h2><ul>\n<li>先介绍一个异常：<code>NullPointerException</code> - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        System.out.println(str.length()); <span class=\"comment\">// 触发 NullPointerException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。</li>\n</ul>\n<h2 id=\"2-2-空安全设计\"><a href=\"#2-2-空安全设计\" class=\"headerlink\" title=\"2.2 空安全设计\"></a>2.2 空安全设计</h2><ul>\n<li>好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？</li>\n<li>简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而<code>避免 NullPointerException</code>。</li>\n<li>可别小看这一点，单单<code>避免 NullPointerException</code>这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。</li>\n<li>空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//IDE 会发出警告：&#x27;null&#x27; is assigned to a variable that is annotated with @NotNull</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 <code>warning</code> 变成了 <code>error</code>（拒绝编译）：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View = <span class=\"literal\">null</span> <span class=\"comment\">//IDE 会提示错误，Null can not be a value of a non-null type View</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>在 Kotlin 里面，所有的变量默认都是不允许为空的</code>，如果你给它赋值 null，就会报错，像上面那样。</li>\n<li>Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。</li>\n<li>这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span> <span class=\"comment\">// 这样写会报错，但该变量无法保证空与否</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。</li>\n<li>这种类型之后加 ? 的写法，在 Kotlin 里叫<code>可空类型</code>。不过，当我们使用了可空类型的变量后，会有新的问题：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View? = <span class=\"literal\">null</span></span><br><span class=\"line\">view.setBackgroundColor(Color.RED)</span><br><span class=\"line\"><span class=\"comment\">// 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于我们定义的<code>可能为空</code>的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (view != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    view.setBackgroundColor(Color.RED)</span><br><span class=\"line\">    <span class=\"comment\">// 这样写也会报错，Smart cast to &#x27;View&#x27; is impossible, because &#x27;view&#x27; is a mutable property that could have been changed by this time</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在<code>多线程</code>情况下，其他线程可能把它再改成空的。</li>\n<li>那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是<code>.</code>而是<code> ?.</code>：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view?.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到<code>线程安全</code>，因此这种写法叫做<code>safe call</code>。</li>\n<li>另外还有一种双感叹号的用法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view!!.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 <code>non-null asserted call</code>。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。</p>\n</li>\n<li><p>其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：</p>\n<ol>\n<li>变量需要手动初始化，如果不初始化的话会报错； </li>\n<li>变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； </li>\n<li>变量用 ? 设置为可空的时候，使用的时候因为<code>可能为空</code>又报错。</li>\n</ol>\n</li>\n<li><p>关于空安全，最重要的是记住一点：所谓<code>可空不可空</code>，关注的全都是<code>使用的时候</code>，即<code>这个变量在使用时是否可能为空</code>。</p>\n</li>\n<li><p>Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression ?: defaultValue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。</p>\n</li>\n<li><p>一些注意事项：</p>\n<ol>\n<li>defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。</li>\n<li>defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。</li>\n<li>Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c</li>\n<li>Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue</li>\n<li>Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。</li>\n</ol>\n</li>\n<li><p>空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。</p>\n</li>\n<li><p>但如果你在 MainActivity 里这么写：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: View = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。</li>\n<li>那怎么办呢？其实我们很想告诉编译器<code>我很确定我用的时候绝对不为空，但第一时间我没法给它赋值</code>。</li>\n<li>Kotlin 给我们提供了一个选项：<code>延迟初始化</code>。</li>\n</ul>\n<h2 id=\"2-3-延迟初始化\"><a href=\"#2-3-延迟初始化\" class=\"headerlink\" title=\"2.3 延迟初始化\"></a>2.3 延迟初始化</h2><ul>\n<li>为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。</li>\n<li>它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。</li>\n<li>然后我们就可以在 onCreate 中进行初始化了：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    view = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。</li>\n</ul>\n<h2 id=\"2-4-类型推断\"><a href=\"#2-4-类型推断\" class=\"headerlink\" title=\"2.4 类型推断\"></a>2.4 类型推断</h2><ul>\n<li>空安全设计到此其实已经差不多讲完了，再补充一点其他内容。</li>\n<li>Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;Mike&quot;</span><span class=\"comment\">//可以直接写成 var name = &quot;Mike&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个特性叫做<code>类型推断</code>，它跟<code>动态类型</code>是不一样的。<ol>\n<li>类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。</li>\n<li>动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-val-和-var\"><a href=\"#2-5-val-和-var\" class=\"headerlink\" title=\"2.5 val 和 var\"></a>2.5 val 和 var</h2><ul>\n<li>除了前面提到的 var，我们还可以使用 val 来声明变量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>val 是 Kotlin 在 Java 的<code>变量</code>类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。</li>\n<li>val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h1><ul>\n<li>在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中<code>变量声明和赋值</code>方面的异同。</li>\n<li>首先，在 Java 中，声明一个变量的格式是：<code>&lt;数据类型&gt; &lt;变量名&gt;;</code>缺一不可，比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> age; <span class=\"comment\">// 声明一个整型变量 age</span></span><br><span class=\"line\">    String name; <span class=\"comment\">// 声明一个字符串型变量 name</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>除了简单声明变量，还可以同时进行初始化，即：<code>&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</code>如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">25</span>; <span class=\"comment\">// 声明一个整型变量 age，并初始化为 25</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span>; <span class=\"comment\">// 声明一个字符串型变量 name，并初始化为 &quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后，在 Kotlin 中，声明一个变量的格式是：<code>var &lt;变量名&gt;: &lt;数据类型&gt;</code>，像这样：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>一眼看去和 Java 有几处不同：</p>\n<ol>\n<li>有一个<code>var</code>关键字</li>\n<li>类型和变量名位置互换了</li>\n<li>中间是用冒号分隔的</li>\n<li>结尾没有分号（Kotlin 里面不需要分号）</li>\n</ol>\n</li>\n<li><p>虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：<code>Property must be initialized or be abstract</code>。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）</p>\n</li>\n<li><p>彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？</p>\n</li>\n<li><p>不不不！其实是有原因的，在 Kotlin 中，变量是<code>没有默认值</code>的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    String name; <span class=\"comment\">// 默认值是 null</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">// 默认值是 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>好吧，你没有默认值那我给你一个吧，我这样写：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>哎呀又报错了，IDE 告诉你说：<code>Null can not be a value of a non-null type View</code>，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。</li>\n</ul>\n<h1 id=\"二、空安全设计\"><a href=\"#二、空安全设计\" class=\"headerlink\" title=\"二、空安全设计\"></a>二、空安全设计</h1><h2 id=\"2-1-NullPointerException\"><a href=\"#2-1-NullPointerException\" class=\"headerlink\" title=\"2.1 NullPointerException\"></a>2.1 NullPointerException</h2><ul>\n<li>先介绍一个异常：<code>NullPointerException</code> - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        System.out.println(str.length()); <span class=\"comment\">// 触发 NullPointerException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。</li>\n</ul>\n<h2 id=\"2-2-空安全设计\"><a href=\"#2-2-空安全设计\" class=\"headerlink\" title=\"2.2 空安全设计\"></a>2.2 空安全设计</h2><ul>\n<li>好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？</li>\n<li>简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而<code>避免 NullPointerException</code>。</li>\n<li>可别小看这一点，单单<code>避免 NullPointerException</code>这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。</li>\n<li>空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//IDE 会发出警告：&#x27;null&#x27; is assigned to a variable that is annotated with @NotNull</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 <code>warning</code> 变成了 <code>error</code>（拒绝编译）：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View = <span class=\"literal\">null</span> <span class=\"comment\">//IDE 会提示错误，Null can not be a value of a non-null type View</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>在 Kotlin 里面，所有的变量默认都是不允许为空的</code>，如果你给它赋值 null，就会报错，像上面那样。</li>\n<li>Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。</li>\n<li>这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span> <span class=\"comment\">// 这样写会报错，但该变量无法保证空与否</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。</li>\n<li>这种类型之后加 ? 的写法，在 Kotlin 里叫<code>可空类型</code>。不过，当我们使用了可空类型的变量后，会有新的问题：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View? = <span class=\"literal\">null</span></span><br><span class=\"line\">view.setBackgroundColor(Color.RED)</span><br><span class=\"line\"><span class=\"comment\">// 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于我们定义的<code>可能为空</code>的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (view != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    view.setBackgroundColor(Color.RED)</span><br><span class=\"line\">    <span class=\"comment\">// 这样写也会报错，Smart cast to &#x27;View&#x27; is impossible, because &#x27;view&#x27; is a mutable property that could have been changed by this time</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在<code>多线程</code>情况下，其他线程可能把它再改成空的。</li>\n<li>那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是<code>.</code>而是<code> ?.</code>：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view?.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到<code>线程安全</code>，因此这种写法叫做<code>safe call</code>。</li>\n<li>另外还有一种双感叹号的用法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view!!.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 <code>non-null asserted call</code>。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。</p>\n</li>\n<li><p>其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：</p>\n<ol>\n<li>变量需要手动初始化，如果不初始化的话会报错； </li>\n<li>变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； </li>\n<li>变量用 ? 设置为可空的时候，使用的时候因为<code>可能为空</code>又报错。</li>\n</ol>\n</li>\n<li><p>关于空安全，最重要的是记住一点：所谓<code>可空不可空</code>，关注的全都是<code>使用的时候</code>，即<code>这个变量在使用时是否可能为空</code>。</p>\n</li>\n<li><p>Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression ?: defaultValue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。</p>\n</li>\n<li><p>一些注意事项：</p>\n<ol>\n<li>defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。</li>\n<li>defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。</li>\n<li>Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c</li>\n<li>Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue</li>\n<li>Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。</li>\n</ol>\n</li>\n<li><p>空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。</p>\n</li>\n<li><p>但如果你在 MainActivity 里这么写：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: View = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。</li>\n<li>那怎么办呢？其实我们很想告诉编译器<code>我很确定我用的时候绝对不为空，但第一时间我没法给它赋值</code>。</li>\n<li>Kotlin 给我们提供了一个选项：<code>延迟初始化</code>。</li>\n</ul>\n<h2 id=\"2-3-延迟初始化\"><a href=\"#2-3-延迟初始化\" class=\"headerlink\" title=\"2.3 延迟初始化\"></a>2.3 延迟初始化</h2><ul>\n<li>为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。</li>\n<li>它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。</li>\n<li>然后我们就可以在 onCreate 中进行初始化了：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    view = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。</li>\n</ul>\n<h2 id=\"2-4-类型推断\"><a href=\"#2-4-类型推断\" class=\"headerlink\" title=\"2.4 类型推断\"></a>2.4 类型推断</h2><ul>\n<li>空安全设计到此其实已经差不多讲完了，再补充一点其他内容。</li>\n<li>Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;Mike&quot;</span><span class=\"comment\">//可以直接写成 var name = &quot;Mike&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个特性叫做<code>类型推断</code>，它跟<code>动态类型</code>是不一样的。<ol>\n<li>类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。</li>\n<li>动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-val-和-var\"><a href=\"#2-5-val-和-var\" class=\"headerlink\" title=\"2.5 val 和 var\"></a>2.5 val 和 var</h2><ul>\n<li>除了前面提到的 var，我们还可以使用 val 来声明变量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>val 是 Kotlin 在 Java 的<code>变量</code>类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。</li>\n<li>val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。</li>\n</ul>\n"},{"title":"Kotlin 中那些和 Java 不一样的写法","date":"2023-07-24T00:00:00.000Z","description":"总结一下 Kotlin 和 Java 在语法、集合数组、流程控制等方面的差异。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oA6jWM.png","_content":"\n# 一、语法和类型系统\n\n## 1.1 可空性\n\n- Kotlin 引入了可空性的概念，通过在类型后面添加`?`来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。\n\n```kotlin\n    var name: String? = null // 可空的字符串\n```\n\n- Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。\n\n```java\n    String name = null; // 普通字符串，可能为 null\n```\n\n## 1.2 函数声明\n\n- Kotlin 使用`fun`关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。\n\n```kotlin\nfun greet(name: String) {\n    println(\"Hello, $name!\")\n}\n```\n\n- Java 中的函数声明方式：\n\n```java\nvoid greet(String name) {\n    System.out.println(\"Hello, \" + name + \"!\");\n}\n```\n\n## 1.3 数据类\n\n-  Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\n## 1.4 字符串插值\n\n- Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。\n\n```kotlin\nkotlin\nval name = \"Alice\"\nval message = \"Hello, $name!\"\n```\n\n## 1.5 Lambda 表达式\n\n- Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval squared = numbers.map { it * it }\n```\n\n- Java 中函数式编程需要通过匿名内部类来实现。\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nList<Integer> squared = numbers.stream().map(x -> x * x).collect(Collectors.toList());\n```\n\n## 1.6 类型推断\n\n- Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。\n\n```kotlin\nval number = 42 // 推断为 Int 类型\nval doubleNumber = 3.14 // 推断为 Double 类型\n```\n\n## 1.7 构造器\n\n- Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。\n\n```kotlin\nclass User {\n    val id: Int\n    val name: String\n    \n    constructor(id: Int, name: String) {\n        this.id = id\n        this.name = name\n    }\n}\n```\n\n```java\npublic class User {\n    int id;\n    String name;\n    \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n- 还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。\n\n## 1.8 init 代码块 \n\n- Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。\n\n```kotlin\nclass User {\n    \n    init {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    constructor() {\n    }\n}\n```\n\n```java\npublic class User {\n   \n    {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    public User() {\n    }\n}\n```\n\n## 1.9 final 和 val\n\n- 大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。\n\n```kotlin\nval size: Int\n    get() { // 每次获取 size 值时都会执行 items.size\n        return items.size\n    }\n```\n\n## 1.10 static 和 companion object\n\n- kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是`伴生对象（Companion Object）`，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。\n\n```kotlin\nclass Sample {\n    companion object {\n        //str 可以直接通过类名进行访问\n        val str = \"Hello word\"\n    }\n}\n```\n\n- 静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：\n\n```kotlin\nclass Sample {\n       \n    companion object {\n         \n        init {\n            //初始化工作\n        }\n    }\n}\n```\n\n## 1.11 Object 和 Any\n\n- 在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了`Any`，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。\n\n```kotlin\nclass MyClass {\n    // ...\n}\n\nval myObj = MyClass()\nif (myObj is Any) {\n    println(\"myObj is an instance of Any\")\n}\n\nval hashCode = myObj.hashCode() // 调用 Any 类的方法\n\n```\n\n- object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于`class`，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。\n\n```kotlin\nobject Singleton {\n    val name = \"Singleton\"\n    fun greet() {\n        println(\"Hello, $name!\")\n    }\n}\n\nval singletonName = Singleton.name // 访问对象的属性\nSingleton.greet() // 调用对象的方法\n\n```\n\n- 所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：\n\n```java\npublic class A {\n    private static A sInstance;\n    \n    public static A getInstance() {\n        if (sInstance == null) {\n            sInstance = new A();\n        }\n        return sInstance;\n    }\n}\n```\n\n- 上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：\n\n```kotlin\nobject A {\n    val number: Int = 1\n    fun method() {\n        println(\"A.method()\")\n    }\n}   \n```\n\n- 另外，通过 object 实现的单例是一个`饿汉式`的单例，并且实现了`线程安全`。\n- 单例对象说完了，还有个匿名类写法差异：\n\n```java\nViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {\n    @Override \n    public void onPageSelected(int position) {\n        // override\n    }\n};\n```\n\n- Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：\n\n```kotlin\nval listener = object: ViewPager.SimpleOnPageChangeListener() {\n    override fun onPageSelected(position: Int) {\n        // override\n    }\n}   \n```\n\n## 1.12 常量\n\n- 在 Java 中，一般这样声明一个常量：\n\n```java\npublic class Sample {\n    public static final int CONST_NUMBER = 1;\n}\n```\n\n- 可以注意到使用了`static final`进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在`companion object`伴生类中才能实现这个功能：\n\n```kotlin\nclass Sample {\n    companion object {\n        const val CONST_NUMBER = 1\n    }\n}\n\n```\n\n- 可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：`top-level 顶层`，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。\n- 例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：\n\n```kotlin\nconst val CONST_NUMBER = 1\n\nfun main() {\n    println(CONST_NUMBER)\n}\n```\n\n- 在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。\n- 学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：\n    1. #define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。\n    2. 在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。\n\n## 1.13 可见性修饰符\n\n- Java 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。\n  2. protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。\n  3. default（默认修饰符）：默认的，作用范围是同一包内。`如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。`\n  4. private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。\n\n- kotlin 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个模块（module）。`默认情况下，所有声明都具有public可见性，可以被任何代码访问`。\n  2. internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。\n  3. protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。\n  4. private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。\n\n- 可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。\n- 特别的，需要说明一下两者 private 修饰符的区别：\n  1. Java 中的 private 表示`类中可见`，作为内部类时对外部类`可见`。\n  2. Kotlin 中的 private 表示`类中或所在文件内可见`，作为内部类时对外部类`不可见`。\n\n# 二、数组和集合\n\n## 2.1 数组\n\n- 在 Java 中声明一个 String 数组：\n\n```java\n    String[] strs = {\"a\", \"b\", \"c\"};\n```\n\n- Kotlin 中声明一个 String 数组：\n\n```kotlin\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：\n    1. get() / set()  获取/修改指定索引位置上的元素值。\n    2. contains()  检查数组中是否包含指定元素。\n    3. first()  获取数组的第一个元素。\n    4. find()  根据给定的条件查找数组中的第一个匹配元素。\n\n## 2.2 集合\n\n- Java 中创建一个列表集合，需要一个个的添加元素：\n\n```java\n  List<String> strList = new ArrayList<>();\n  strList.add(\"a\");\n  strList.add(\"b\");\n  strList.add(\"c\");\n```\n\n- Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：\n\n```kotlin\n    val strList = listOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中创建相同的 Set：\n\n```java\n  Set<String> strSet = new HashSet<>();\n  strSet.add(\"a\");\n  strSet.add(\"b\");\n  strSet.add(\"c\");\n```\n\n- Kotlin 中创建相同的 Set 集合：\n\n```kotlin\nval strSet = setOf(\"a\", \"b\", \"c\")\n```\n\n- Java 中创建一个 Map 集合：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"key1\", 1);\n  map.put(\"key2\", 2);\n  map.put(\"key3\", 3);\n  map.put(\"key4\", 3);\n```\n\n- Kotlin 中创建一个同样的 Map 集合：\n\n```kotlin\nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n```\n\n- 简洁、优雅。\n\n# 三、流程控制\n\n## 3.1 if else\n\n- 就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。\n- 但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：\n\n```kotlin\n  val a = 5\n  val b = if (a > 0) {\n      10\n  } else {\n      -10\n  }\n```\n\n## 3.2 for 循环\n\n- Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。\n\n```kotlin\nfor (i in 1..5) {\n    println(i)\n}\n```\n- 同样的功能在 Java 中需要这么写：\n\n```java\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n```\n\n- 特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n      System.out.println(entry.getKey() + \": \" + entry.getValue());\n  }\n```\n\n- 而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：\n\n```kotlin\n  val map = mapOf(\"A\" to 1, \"B\" to 2)\n  for ((key, value) in map) {\n      println(\"$key: $value\")\n  }\n```\n\n## 3.3 switch case\n\n- Java 中，switch case 需要使用关键字 switch、case、break 和 default：\n\n```java\nint day = 3;\n        String dayName;\n        switch (day) {\n        case 1:\n        dayName = \"Monday\";\n        break;\n        case 2:\n        dayName = \"Tuesday\";\n        break;\n        case 3:\n        dayName = \"Wednesday\";\n        break;\n        default:\n        dayName = \"Invalid day\";\n        }\n        System.out.println(dayName);\n```\n\n- 而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（->）将条件和结果连接起来，并且不需要显式的 break 语句：\n\n```kotlin\nval day = 3\nval dayName = when (day) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    else -> \"Invalid day\"\n}\nprintln(dayName)\n```\n\n- 还是那么的简洁、优雅。\n\n# 四、总结\n\n- 上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。\n- 反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。","source":"_posts/Kotlin_04_Kotlin中那些和Java不一样的写法.md","raw":"---\ntitle: 'Kotlin 中那些和 Java 不一样的写法'\ndate: '2023-07-24'\ndescription: '总结一下 Kotlin 和 Java 在语法、集合数组、流程控制等方面的差异。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oA6jWM.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n# 一、语法和类型系统\n\n## 1.1 可空性\n\n- Kotlin 引入了可空性的概念，通过在类型后面添加`?`来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。\n\n```kotlin\n    var name: String? = null // 可空的字符串\n```\n\n- Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。\n\n```java\n    String name = null; // 普通字符串，可能为 null\n```\n\n## 1.2 函数声明\n\n- Kotlin 使用`fun`关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。\n\n```kotlin\nfun greet(name: String) {\n    println(\"Hello, $name!\")\n}\n```\n\n- Java 中的函数声明方式：\n\n```java\nvoid greet(String name) {\n    System.out.println(\"Hello, \" + name + \"!\");\n}\n```\n\n## 1.3 数据类\n\n-  Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\n## 1.4 字符串插值\n\n- Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。\n\n```kotlin\nkotlin\nval name = \"Alice\"\nval message = \"Hello, $name!\"\n```\n\n## 1.5 Lambda 表达式\n\n- Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval squared = numbers.map { it * it }\n```\n\n- Java 中函数式编程需要通过匿名内部类来实现。\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nList<Integer> squared = numbers.stream().map(x -> x * x).collect(Collectors.toList());\n```\n\n## 1.6 类型推断\n\n- Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。\n\n```kotlin\nval number = 42 // 推断为 Int 类型\nval doubleNumber = 3.14 // 推断为 Double 类型\n```\n\n## 1.7 构造器\n\n- Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。\n\n```kotlin\nclass User {\n    val id: Int\n    val name: String\n    \n    constructor(id: Int, name: String) {\n        this.id = id\n        this.name = name\n    }\n}\n```\n\n```java\npublic class User {\n    int id;\n    String name;\n    \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n- 还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。\n\n## 1.8 init 代码块 \n\n- Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。\n\n```kotlin\nclass User {\n    \n    init {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    constructor() {\n    }\n}\n```\n\n```java\npublic class User {\n   \n    {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    public User() {\n    }\n}\n```\n\n## 1.9 final 和 val\n\n- 大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。\n\n```kotlin\nval size: Int\n    get() { // 每次获取 size 值时都会执行 items.size\n        return items.size\n    }\n```\n\n## 1.10 static 和 companion object\n\n- kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是`伴生对象（Companion Object）`，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。\n\n```kotlin\nclass Sample {\n    companion object {\n        //str 可以直接通过类名进行访问\n        val str = \"Hello word\"\n    }\n}\n```\n\n- 静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：\n\n```kotlin\nclass Sample {\n       \n    companion object {\n         \n        init {\n            //初始化工作\n        }\n    }\n}\n```\n\n## 1.11 Object 和 Any\n\n- 在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了`Any`，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。\n\n```kotlin\nclass MyClass {\n    // ...\n}\n\nval myObj = MyClass()\nif (myObj is Any) {\n    println(\"myObj is an instance of Any\")\n}\n\nval hashCode = myObj.hashCode() // 调用 Any 类的方法\n\n```\n\n- object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于`class`，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。\n\n```kotlin\nobject Singleton {\n    val name = \"Singleton\"\n    fun greet() {\n        println(\"Hello, $name!\")\n    }\n}\n\nval singletonName = Singleton.name // 访问对象的属性\nSingleton.greet() // 调用对象的方法\n\n```\n\n- 所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：\n\n```java\npublic class A {\n    private static A sInstance;\n    \n    public static A getInstance() {\n        if (sInstance == null) {\n            sInstance = new A();\n        }\n        return sInstance;\n    }\n}\n```\n\n- 上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：\n\n```kotlin\nobject A {\n    val number: Int = 1\n    fun method() {\n        println(\"A.method()\")\n    }\n}   \n```\n\n- 另外，通过 object 实现的单例是一个`饿汉式`的单例，并且实现了`线程安全`。\n- 单例对象说完了，还有个匿名类写法差异：\n\n```java\nViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {\n    @Override \n    public void onPageSelected(int position) {\n        // override\n    }\n};\n```\n\n- Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：\n\n```kotlin\nval listener = object: ViewPager.SimpleOnPageChangeListener() {\n    override fun onPageSelected(position: Int) {\n        // override\n    }\n}   \n```\n\n## 1.12 常量\n\n- 在 Java 中，一般这样声明一个常量：\n\n```java\npublic class Sample {\n    public static final int CONST_NUMBER = 1;\n}\n```\n\n- 可以注意到使用了`static final`进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在`companion object`伴生类中才能实现这个功能：\n\n```kotlin\nclass Sample {\n    companion object {\n        const val CONST_NUMBER = 1\n    }\n}\n\n```\n\n- 可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：`top-level 顶层`，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。\n- 例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：\n\n```kotlin\nconst val CONST_NUMBER = 1\n\nfun main() {\n    println(CONST_NUMBER)\n}\n```\n\n- 在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。\n- 学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：\n    1. #define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。\n    2. 在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。\n\n## 1.13 可见性修饰符\n\n- Java 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。\n  2. protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。\n  3. default（默认修饰符）：默认的，作用范围是同一包内。`如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。`\n  4. private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。\n\n- kotlin 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个模块（module）。`默认情况下，所有声明都具有public可见性，可以被任何代码访问`。\n  2. internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。\n  3. protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。\n  4. private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。\n\n- 可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。\n- 特别的，需要说明一下两者 private 修饰符的区别：\n  1. Java 中的 private 表示`类中可见`，作为内部类时对外部类`可见`。\n  2. Kotlin 中的 private 表示`类中或所在文件内可见`，作为内部类时对外部类`不可见`。\n\n# 二、数组和集合\n\n## 2.1 数组\n\n- 在 Java 中声明一个 String 数组：\n\n```java\n    String[] strs = {\"a\", \"b\", \"c\"};\n```\n\n- Kotlin 中声明一个 String 数组：\n\n```kotlin\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：\n    1. get() / set()  获取/修改指定索引位置上的元素值。\n    2. contains()  检查数组中是否包含指定元素。\n    3. first()  获取数组的第一个元素。\n    4. find()  根据给定的条件查找数组中的第一个匹配元素。\n\n## 2.2 集合\n\n- Java 中创建一个列表集合，需要一个个的添加元素：\n\n```java\n  List<String> strList = new ArrayList<>();\n  strList.add(\"a\");\n  strList.add(\"b\");\n  strList.add(\"c\");\n```\n\n- Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：\n\n```kotlin\n    val strList = listOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中创建相同的 Set：\n\n```java\n  Set<String> strSet = new HashSet<>();\n  strSet.add(\"a\");\n  strSet.add(\"b\");\n  strSet.add(\"c\");\n```\n\n- Kotlin 中创建相同的 Set 集合：\n\n```kotlin\nval strSet = setOf(\"a\", \"b\", \"c\")\n```\n\n- Java 中创建一个 Map 集合：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"key1\", 1);\n  map.put(\"key2\", 2);\n  map.put(\"key3\", 3);\n  map.put(\"key4\", 3);\n```\n\n- Kotlin 中创建一个同样的 Map 集合：\n\n```kotlin\nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n```\n\n- 简洁、优雅。\n\n# 三、流程控制\n\n## 3.1 if else\n\n- 就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。\n- 但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：\n\n```kotlin\n  val a = 5\n  val b = if (a > 0) {\n      10\n  } else {\n      -10\n  }\n```\n\n## 3.2 for 循环\n\n- Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。\n\n```kotlin\nfor (i in 1..5) {\n    println(i)\n}\n```\n- 同样的功能在 Java 中需要这么写：\n\n```java\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n```\n\n- 特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n      System.out.println(entry.getKey() + \": \" + entry.getValue());\n  }\n```\n\n- 而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：\n\n```kotlin\n  val map = mapOf(\"A\" to 1, \"B\" to 2)\n  for ((key, value) in map) {\n      println(\"$key: $value\")\n  }\n```\n\n## 3.3 switch case\n\n- Java 中，switch case 需要使用关键字 switch、case、break 和 default：\n\n```java\nint day = 3;\n        String dayName;\n        switch (day) {\n        case 1:\n        dayName = \"Monday\";\n        break;\n        case 2:\n        dayName = \"Tuesday\";\n        break;\n        case 3:\n        dayName = \"Wednesday\";\n        break;\n        default:\n        dayName = \"Invalid day\";\n        }\n        System.out.println(dayName);\n```\n\n- 而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（->）将条件和结果连接起来，并且不需要显式的 break 语句：\n\n```kotlin\nval day = 3\nval dayName = when (day) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    else -> \"Invalid day\"\n}\nprintln(dayName)\n```\n\n- 还是那么的简洁、优雅。\n\n# 四、总结\n\n- 上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。\n- 反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。","slug":"Kotlin_04_Kotlin中那些和Java不一样的写法","published":1,"updated":"2023-09-25T06:44:16.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji55000927ho0bzp41wr","content":"<h1 id=\"一、语法和类型系统\"><a href=\"#一、语法和类型系统\" class=\"headerlink\" title=\"一、语法和类型系统\"></a>一、语法和类型系统</h1><h2 id=\"1-1-可空性\"><a href=\"#1-1-可空性\" class=\"headerlink\" title=\"1.1 可空性\"></a>1.1 可空性</h2><ul>\n<li>Kotlin 引入了可空性的概念，通过在类型后面添加<code>?</code>来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span> <span class=\"comment\">// 可空的字符串</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 普通字符串，可能为 null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-函数声明\"><a href=\"#1-2-函数声明\" class=\"headerlink\" title=\"1.2 函数声明\"></a>1.2 函数声明</h2><ul>\n<li>Kotlin 使用<code>fun</code>关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中的函数声明方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">greet</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-数据类\"><a href=\"#1-3-数据类\" class=\"headerlink\" title=\"1.3 数据类\"></a>1.3 数据类</h2><ul>\n<li> Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-字符串插值\"><a href=\"#1-4-字符串插值\" class=\"headerlink\" title=\"1.4 字符串插值\"></a>1.4 字符串插值</h2><ul>\n<li>Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin</span><br><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> message = <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-Lambda-表达式\"><a href=\"#1-5-Lambda-表达式\" class=\"headerlink\" title=\"1.5 Lambda 表达式\"></a>1.5 Lambda 表达式</h2><ul>\n<li>Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> squared = numbers.map &#123; it * it &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中函数式编程需要通过匿名内部类来实现。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squared = numbers.stream().map(x -&gt; x * x).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-类型推断\"><a href=\"#1-6-类型推断\" class=\"headerlink\" title=\"1.6 类型推断\"></a>1.6 类型推断</h2><ul>\n<li>Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"number\">42</span> <span class=\"comment\">// 推断为 Int 类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> doubleNumber = <span class=\"number\">3.14</span> <span class=\"comment\">// 推断为 Double 类型</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-构造器\"><a href=\"#1-7-构造器\" class=\"headerlink\" title=\"1.7 构造器\"></a>1.7 构造器</h2><ul>\n<li>Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(id: <span class=\"built_in\">Int</span>, name: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。</li>\n</ul>\n<h2 id=\"1-8-init-代码块\"><a href=\"#1-8-init-代码块\" class=\"headerlink\" title=\"1.8 init 代码块\"></a>1.8 init 代码块</h2><ul>\n<li>Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-final-和-val\"><a href=\"#1-9-final-和-val\" class=\"headerlink\" title=\"1.9 final 和 val\"></a>1.9 final 和 val</h2><ul>\n<li>大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123; <span class=\"comment\">// 每次获取 size 值时都会执行 items.size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.size</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-10-static-和-companion-object\"><a href=\"#1-10-static-和-companion-object\" class=\"headerlink\" title=\"1.10 static 和 companion object\"></a>1.10 static 和 companion object</h2><ul>\n<li>kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是<code>伴生对象（Companion Object）</code>，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//str 可以直接通过类名进行访问</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> str = <span class=\"string\">&quot;Hello word&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化工作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-11-Object-和-Any\"><a href=\"#1-11-Object-和-Any\" class=\"headerlink\" title=\"1.11 Object 和 Any\"></a>1.11 Object 和 Any</h2><ul>\n<li>在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了<code>Any</code>，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> myObj = MyClass()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (myObj <span class=\"keyword\">is</span> Any) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;myObj is an instance of Any&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> hashCode = myObj.hashCode() <span class=\"comment\">// 调用 Any 类的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于<code>class</code>，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> Singleton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Singleton&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> singletonName = Singleton.name <span class=\"comment\">// 访问对象的属性</span></span><br><span class=\"line\">Singleton.greet() <span class=\"comment\">// 调用对象的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A sInstance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;A.method()&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另外，通过 object 实现的单例是一个<code>饿汉式</code>的单例，并且实现了<code>线程安全</code>。</li>\n<li>单例对象说完了，还有个匿名类写法差异：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewPager.<span class=\"type\">SimpleOnPageChangeListener</span> <span class=\"variable\">listener</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewPager</span>.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPageSelected</span><span class=\"params\">(<span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> listener = <span class=\"keyword\">object</span>: ViewPager.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-常量\"><a href=\"#1-12-常量\" class=\"headerlink\" title=\"1.12 常量\"></a>1.12 常量</h2><ul>\n<li>在 Java 中，一般这样声明一个常量：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CONST_NUMBER</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以注意到使用了<code>static final</code>进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在<code>companion object</code>伴生类中才能实现这个功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：<code>top-level 顶层</code>，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。</li>\n<li>例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(CONST_NUMBER)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。</li>\n<li>学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：<ol>\n<li>#define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。</li>\n<li>在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-13-可见性修饰符\"><a href=\"#1-13-可见性修饰符\" class=\"headerlink\" title=\"1.13 可见性修饰符\"></a>1.13 可见性修饰符</h2><ul>\n<li><p>Java 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。</li>\n<li>protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。</li>\n<li>default（默认修饰符）：默认的，作用范围是同一包内。<code>如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。</code></li>\n<li>private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。</li>\n</ol>\n</li>\n<li><p>kotlin 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个模块（module）。<code>默认情况下，所有声明都具有public可见性，可以被任何代码访问</code>。</li>\n<li>internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。</li>\n<li>protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。</li>\n<li>private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。</li>\n</ol>\n</li>\n<li><p>可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。</p>\n</li>\n<li><p>特别的，需要说明一下两者 private 修饰符的区别：</p>\n<ol>\n<li>Java 中的 private 表示<code>类中可见</code>，作为内部类时对外部类<code>可见</code>。</li>\n<li>Kotlin 中的 private 表示<code>类中或所在文件内可见</code>，作为内部类时对外部类<code>不可见</code>。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、数组和集合\"><a href=\"#二、数组和集合\" class=\"headerlink\" title=\"二、数组和集合\"></a>二、数组和集合</h1><h2 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h2><ul>\n<li>在 Java 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] strs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strs: Array&lt;String&gt; = arrayOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：<ol>\n<li>get() / set()  获取/修改指定索引位置上的元素值。</li>\n<li>contains()  检查数组中是否包含指定元素。</li>\n<li>first()  获取数组的第一个元素。</li>\n<li>find()  根据给定的条件查找数组中的第一个匹配元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-集合\"><a href=\"#2-2-集合\" class=\"headerlink\" title=\"2.2 集合\"></a>2.2 集合</h2><ul>\n<li>Java 中创建一个列表集合，需要一个个的添加元素：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strList = listOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; strSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strSet = setOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中创建一个 Map 集合：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个同样的 Map 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;key1&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;key2&quot;</span> to <span class=\"number\">2</span>, <span class=\"string\">&quot;key3&quot;</span> to <span class=\"number\">3</span>, <span class=\"string\">&quot;key4&quot;</span> to <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁、优雅。</li>\n</ul>\n<h1 id=\"三、流程控制\"><a href=\"#三、流程控制\" class=\"headerlink\" title=\"三、流程控制\"></a>三、流程控制</h1><h2 id=\"3-1-if-else\"><a href=\"#3-1-if-else\" class=\"headerlink\" title=\"3.1 if else\"></a>3.1 if else</h2><ul>\n<li>就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。</li>\n<li>但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">10</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    -<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for-循环\"><a href=\"#3-2-for-循环\" class=\"headerlink\" title=\"3.2 for 循环\"></a>3.2 for 循环</h2><ul>\n<li>Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1.</span><span class=\"number\">.5</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样的功能在 Java 中需要这么写：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;: &quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;A&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;B&quot;</span> to <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((key, value) <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$key</span>: <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-switch-case\"><a href=\"#3-3-switch-case\" class=\"headerlink\" title=\"3.3 switch case\"></a>3.3 switch case</h2><ul>\n<li>Java 中，switch case 需要使用关键字 switch、case、break 和 default：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        String dayName;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Monday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Tuesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Wednesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Invalid day&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dayName);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（-&gt;）将条件和结果连接起来，并且不需要显式的 break 语句：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> day = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> dayName = <span class=\"keyword\">when</span> (day) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; <span class=\"string\">&quot;Monday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; <span class=\"string\">&quot;Tuesday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; <span class=\"string\">&quot;Wednesday&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; <span class=\"string\">&quot;Invalid day&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(dayName)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还是那么的简洁、优雅。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。</li>\n<li>反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、语法和类型系统\"><a href=\"#一、语法和类型系统\" class=\"headerlink\" title=\"一、语法和类型系统\"></a>一、语法和类型系统</h1><h2 id=\"1-1-可空性\"><a href=\"#1-1-可空性\" class=\"headerlink\" title=\"1.1 可空性\"></a>1.1 可空性</h2><ul>\n<li>Kotlin 引入了可空性的概念，通过在类型后面添加<code>?</code>来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span> <span class=\"comment\">// 可空的字符串</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 普通字符串，可能为 null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-函数声明\"><a href=\"#1-2-函数声明\" class=\"headerlink\" title=\"1.2 函数声明\"></a>1.2 函数声明</h2><ul>\n<li>Kotlin 使用<code>fun</code>关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中的函数声明方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">greet</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-数据类\"><a href=\"#1-3-数据类\" class=\"headerlink\" title=\"1.3 数据类\"></a>1.3 数据类</h2><ul>\n<li> Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-字符串插值\"><a href=\"#1-4-字符串插值\" class=\"headerlink\" title=\"1.4 字符串插值\"></a>1.4 字符串插值</h2><ul>\n<li>Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin</span><br><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> message = <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-Lambda-表达式\"><a href=\"#1-5-Lambda-表达式\" class=\"headerlink\" title=\"1.5 Lambda 表达式\"></a>1.5 Lambda 表达式</h2><ul>\n<li>Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> squared = numbers.map &#123; it * it &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中函数式编程需要通过匿名内部类来实现。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squared = numbers.stream().map(x -&gt; x * x).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-类型推断\"><a href=\"#1-6-类型推断\" class=\"headerlink\" title=\"1.6 类型推断\"></a>1.6 类型推断</h2><ul>\n<li>Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"number\">42</span> <span class=\"comment\">// 推断为 Int 类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> doubleNumber = <span class=\"number\">3.14</span> <span class=\"comment\">// 推断为 Double 类型</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-构造器\"><a href=\"#1-7-构造器\" class=\"headerlink\" title=\"1.7 构造器\"></a>1.7 构造器</h2><ul>\n<li>Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(id: <span class=\"built_in\">Int</span>, name: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。</li>\n</ul>\n<h2 id=\"1-8-init-代码块\"><a href=\"#1-8-init-代码块\" class=\"headerlink\" title=\"1.8 init 代码块\"></a>1.8 init 代码块</h2><ul>\n<li>Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-final-和-val\"><a href=\"#1-9-final-和-val\" class=\"headerlink\" title=\"1.9 final 和 val\"></a>1.9 final 和 val</h2><ul>\n<li>大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123; <span class=\"comment\">// 每次获取 size 值时都会执行 items.size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.size</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-10-static-和-companion-object\"><a href=\"#1-10-static-和-companion-object\" class=\"headerlink\" title=\"1.10 static 和 companion object\"></a>1.10 static 和 companion object</h2><ul>\n<li>kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是<code>伴生对象（Companion Object）</code>，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//str 可以直接通过类名进行访问</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> str = <span class=\"string\">&quot;Hello word&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化工作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-11-Object-和-Any\"><a href=\"#1-11-Object-和-Any\" class=\"headerlink\" title=\"1.11 Object 和 Any\"></a>1.11 Object 和 Any</h2><ul>\n<li>在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了<code>Any</code>，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> myObj = MyClass()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (myObj <span class=\"keyword\">is</span> Any) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;myObj is an instance of Any&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> hashCode = myObj.hashCode() <span class=\"comment\">// 调用 Any 类的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于<code>class</code>，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> Singleton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Singleton&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> singletonName = Singleton.name <span class=\"comment\">// 访问对象的属性</span></span><br><span class=\"line\">Singleton.greet() <span class=\"comment\">// 调用对象的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A sInstance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;A.method()&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另外，通过 object 实现的单例是一个<code>饿汉式</code>的单例，并且实现了<code>线程安全</code>。</li>\n<li>单例对象说完了，还有个匿名类写法差异：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewPager.<span class=\"type\">SimpleOnPageChangeListener</span> <span class=\"variable\">listener</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewPager</span>.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPageSelected</span><span class=\"params\">(<span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> listener = <span class=\"keyword\">object</span>: ViewPager.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-常量\"><a href=\"#1-12-常量\" class=\"headerlink\" title=\"1.12 常量\"></a>1.12 常量</h2><ul>\n<li>在 Java 中，一般这样声明一个常量：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CONST_NUMBER</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以注意到使用了<code>static final</code>进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在<code>companion object</code>伴生类中才能实现这个功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：<code>top-level 顶层</code>，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。</li>\n<li>例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(CONST_NUMBER)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。</li>\n<li>学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：<ol>\n<li>#define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。</li>\n<li>在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-13-可见性修饰符\"><a href=\"#1-13-可见性修饰符\" class=\"headerlink\" title=\"1.13 可见性修饰符\"></a>1.13 可见性修饰符</h2><ul>\n<li><p>Java 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。</li>\n<li>protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。</li>\n<li>default（默认修饰符）：默认的，作用范围是同一包内。<code>如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。</code></li>\n<li>private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。</li>\n</ol>\n</li>\n<li><p>kotlin 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个模块（module）。<code>默认情况下，所有声明都具有public可见性，可以被任何代码访问</code>。</li>\n<li>internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。</li>\n<li>protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。</li>\n<li>private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。</li>\n</ol>\n</li>\n<li><p>可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。</p>\n</li>\n<li><p>特别的，需要说明一下两者 private 修饰符的区别：</p>\n<ol>\n<li>Java 中的 private 表示<code>类中可见</code>，作为内部类时对外部类<code>可见</code>。</li>\n<li>Kotlin 中的 private 表示<code>类中或所在文件内可见</code>，作为内部类时对外部类<code>不可见</code>。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、数组和集合\"><a href=\"#二、数组和集合\" class=\"headerlink\" title=\"二、数组和集合\"></a>二、数组和集合</h1><h2 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h2><ul>\n<li>在 Java 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] strs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strs: Array&lt;String&gt; = arrayOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：<ol>\n<li>get() / set()  获取/修改指定索引位置上的元素值。</li>\n<li>contains()  检查数组中是否包含指定元素。</li>\n<li>first()  获取数组的第一个元素。</li>\n<li>find()  根据给定的条件查找数组中的第一个匹配元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-集合\"><a href=\"#2-2-集合\" class=\"headerlink\" title=\"2.2 集合\"></a>2.2 集合</h2><ul>\n<li>Java 中创建一个列表集合，需要一个个的添加元素：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strList = listOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; strSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strSet = setOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中创建一个 Map 集合：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个同样的 Map 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;key1&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;key2&quot;</span> to <span class=\"number\">2</span>, <span class=\"string\">&quot;key3&quot;</span> to <span class=\"number\">3</span>, <span class=\"string\">&quot;key4&quot;</span> to <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁、优雅。</li>\n</ul>\n<h1 id=\"三、流程控制\"><a href=\"#三、流程控制\" class=\"headerlink\" title=\"三、流程控制\"></a>三、流程控制</h1><h2 id=\"3-1-if-else\"><a href=\"#3-1-if-else\" class=\"headerlink\" title=\"3.1 if else\"></a>3.1 if else</h2><ul>\n<li>就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。</li>\n<li>但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">10</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    -<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for-循环\"><a href=\"#3-2-for-循环\" class=\"headerlink\" title=\"3.2 for 循环\"></a>3.2 for 循环</h2><ul>\n<li>Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1.</span><span class=\"number\">.5</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样的功能在 Java 中需要这么写：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;: &quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;A&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;B&quot;</span> to <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((key, value) <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$key</span>: <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-switch-case\"><a href=\"#3-3-switch-case\" class=\"headerlink\" title=\"3.3 switch case\"></a>3.3 switch case</h2><ul>\n<li>Java 中，switch case 需要使用关键字 switch、case、break 和 default：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        String dayName;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Monday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Tuesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Wednesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Invalid day&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dayName);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（-&gt;）将条件和结果连接起来，并且不需要显式的 break 语句：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> day = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> dayName = <span class=\"keyword\">when</span> (day) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; <span class=\"string\">&quot;Monday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; <span class=\"string\">&quot;Tuesday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; <span class=\"string\">&quot;Wednesday&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; <span class=\"string\">&quot;Invalid day&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(dayName)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还是那么的简洁、优雅。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。</li>\n<li>反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。</li>\n</ul>\n"},{"title":"爬楼梯","date":"2023-04-01T00:00:00.000Z","description":"动态规划入门题目 - 爬楼梯","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/a76dfdb1924352c8687e43ae69edd8f1.jpeg","_content":"\n# 一、定义和举例\n\n## 1.1 定义\n\n- 什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。\n\n- 很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：\n\n- `动态规划就是从下往上(从前向后)阶梯型求解数值`。还是不明白？\n\n## 1.2 举个栗子\n\n**爬楼梯**\n\n大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？\n现在我们来分析一下这个场景，并加一点限制：\n\n- 张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？\n  聪明的你看都看出来了，这还不简单？\n\n1. 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶\n3. 走两阶 -> 走一阶\n   <br/>\n\nOK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。\n那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：\n\n1. 走一阶 -> 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶 -> 走一阶\n3. 走一阶 -> 走一阶 -> 走两阶\n4. 走两阶 -> 走一阶 -> 走一阶\n5. 走两阶 -> 走两阶\n\n好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。\n以下就是动态规划的核心思想了：\n\n    张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n\n欸！对哎，可是那又怎么样呢？那可太重要了！\n我们可以得出一个**很重要的结论**：\n\n- 张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。\n  再扩展一下\n- 张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。\n- ... 第五层 ... 是 ... 第四层 ... 加上 ... 第三层 ...。\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n\n发现规律了吗？没错，一句话**总结**就是：\n\n    张三后续做的决策都会受到前面所做决策的影响！\n\n## 1.3 小结一下\n\n可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。\n这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。\n更通俗一点的说：\n\n- 递归是先解决大问题，再解决小问题\n- 动态规划是先解决小问题，再解决大问题\n\n- 下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下\n\n```Java\n//递归\nclass Ra {\n    int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);   // 从最大的数字开始考虑\n    }\n}\n```\n\n```Java\n//动态规划\nclass Dp {\n    int factorial(int n) {\n        int dp = new int[100];// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘\n        dp[0] = 1;\n        if (n == 0) {\n            return dp[0];\n        }\n        for (\n                int i = 1;\n                i <= n; i++) // 从最小的数字开始考虑，将所有的结果放在数组中\n        {\n            dp[i] = i * dp[i - 1];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 二、解决问题\n\n## 2.1 定义数组元素含义\n\n- 首先我们重新梳理一下问题：\n  **假设张三正在爬楼梯，需要 n 阶才能到达楼顶。\n  每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？**\n\n- 有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。\n  我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。\n\n```java\nclass Solution {\n    /*  省略  */\n    int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n    /*  省略  */\n}\n```\n\n## 2.2 找出数组元素之间的关系式（状态转移方程）\n\n- 这是最难的一步，好在前面我们已经分析出来了，还记得吗？\n\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n  所以我们得出了状态转移方程：\n- **dp[n] = dp[n - 1] + dp[n - 2];**\n\n## 2.3 找出初始值\n\n- 有的同学已经发现，上面的方程可能出现数组越界的问题。\n  没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；\n  因此，我们第三步要做的就是找出这些初始值。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n        /*  省略  */\n        //找出初始值\n        dp[1] = 1;\n        dp[2] = 2;\n        /*  省略  */\n    }\n}\n```\n\n**好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：**\n\n```Java\nclass Solution {\n    public int climbStairs(int n) {\n        //分析\n        //爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n\n        //假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];\n        //dp[3]=dp[1]+dp[2];\n        //dp[1]和dp[2]是初始值，无法通过公式计算\n\n        //创建一个数组来保存历史数据\n        int[] dp = new int[n + 1];\n        //排除两种初始情况\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 三、总结\n\n- 以上就是最经典的动态规划入门题目：[《爬楼梯》](https://leetcode.cn/problems/climbing-stairs/)的一个简单分析和对应的解法。\n  当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。","source":"_posts/动态规划_01_爬楼梯.md","raw":"---\ntitle: '爬楼梯'\ndate: '2023-04-01'\ndescription: '动态规划入门题目 - 爬楼梯'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/a76dfdb1924352c8687e43ae69edd8f1.jpeg'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 动态规划\n\n---\n\n# 一、定义和举例\n\n## 1.1 定义\n\n- 什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。\n\n- 很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：\n\n- `动态规划就是从下往上(从前向后)阶梯型求解数值`。还是不明白？\n\n## 1.2 举个栗子\n\n**爬楼梯**\n\n大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？\n现在我们来分析一下这个场景，并加一点限制：\n\n- 张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？\n  聪明的你看都看出来了，这还不简单？\n\n1. 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶\n3. 走两阶 -> 走一阶\n   <br/>\n\nOK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。\n那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：\n\n1. 走一阶 -> 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶 -> 走一阶\n3. 走一阶 -> 走一阶 -> 走两阶\n4. 走两阶 -> 走一阶 -> 走一阶\n5. 走两阶 -> 走两阶\n\n好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。\n以下就是动态规划的核心思想了：\n\n    张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n\n欸！对哎，可是那又怎么样呢？那可太重要了！\n我们可以得出一个**很重要的结论**：\n\n- 张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。\n  再扩展一下\n- 张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。\n- ... 第五层 ... 是 ... 第四层 ... 加上 ... 第三层 ...。\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n\n发现规律了吗？没错，一句话**总结**就是：\n\n    张三后续做的决策都会受到前面所做决策的影响！\n\n## 1.3 小结一下\n\n可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。\n这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。\n更通俗一点的说：\n\n- 递归是先解决大问题，再解决小问题\n- 动态规划是先解决小问题，再解决大问题\n\n- 下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下\n\n```Java\n//递归\nclass Ra {\n    int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);   // 从最大的数字开始考虑\n    }\n}\n```\n\n```Java\n//动态规划\nclass Dp {\n    int factorial(int n) {\n        int dp = new int[100];// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘\n        dp[0] = 1;\n        if (n == 0) {\n            return dp[0];\n        }\n        for (\n                int i = 1;\n                i <= n; i++) // 从最小的数字开始考虑，将所有的结果放在数组中\n        {\n            dp[i] = i * dp[i - 1];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 二、解决问题\n\n## 2.1 定义数组元素含义\n\n- 首先我们重新梳理一下问题：\n  **假设张三正在爬楼梯，需要 n 阶才能到达楼顶。\n  每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？**\n\n- 有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。\n  我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。\n\n```java\nclass Solution {\n    /*  省略  */\n    int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n    /*  省略  */\n}\n```\n\n## 2.2 找出数组元素之间的关系式（状态转移方程）\n\n- 这是最难的一步，好在前面我们已经分析出来了，还记得吗？\n\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n  所以我们得出了状态转移方程：\n- **dp[n] = dp[n - 1] + dp[n - 2];**\n\n## 2.3 找出初始值\n\n- 有的同学已经发现，上面的方程可能出现数组越界的问题。\n  没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；\n  因此，我们第三步要做的就是找出这些初始值。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n        /*  省略  */\n        //找出初始值\n        dp[1] = 1;\n        dp[2] = 2;\n        /*  省略  */\n    }\n}\n```\n\n**好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：**\n\n```Java\nclass Solution {\n    public int climbStairs(int n) {\n        //分析\n        //爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n\n        //假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];\n        //dp[3]=dp[1]+dp[2];\n        //dp[1]和dp[2]是初始值，无法通过公式计算\n\n        //创建一个数组来保存历史数据\n        int[] dp = new int[n + 1];\n        //排除两种初始情况\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 三、总结\n\n- 以上就是最经典的动态规划入门题目：[《爬楼梯》](https://leetcode.cn/problems/climbing-stairs/)的一个简单分析和对应的解法。\n  当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。","slug":"动态规划_01_爬楼梯","published":1,"updated":"2023-09-25T07:07:18.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji57000d27hoel2febn9","content":"<h1 id=\"一、定义和举例\"><a href=\"#一、定义和举例\" class=\"headerlink\" title=\"一、定义和举例\"></a>一、定义和举例</h1><h2 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h2><ul>\n<li><p>什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>\n</li>\n<li><p>很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：</p>\n</li>\n<li><p><code>动态规划就是从下往上(从前向后)阶梯型求解数值</code>。还是不明白？</p>\n</li>\n</ul>\n<h2 id=\"1-2-举个栗子\"><a href=\"#1-2-举个栗子\" class=\"headerlink\" title=\"1.2 举个栗子\"></a>1.2 举个栗子</h2><p><strong>爬楼梯</strong></p>\n<p>大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？<br>现在我们来分析一下这个场景，并加一点限制：</p>\n<ul>\n<li>张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？<br>聪明的你看都看出来了，这还不简单？</li>\n</ul>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶<br/></li>\n</ol>\n<p>OK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。<br>那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：</p>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走两阶 -&gt; 走两阶</li>\n</ol>\n<p>好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。<br>以下就是动态规划的核心思想了：</p>\n<pre><code>张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n</code></pre>\n<p>欸！对哎，可是那又怎么样呢？那可太重要了！<br>我们可以得出一个<strong>很重要的结论</strong>：</p>\n<ul>\n<li>张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。<br>再扩展一下</li>\n<li>张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。</li>\n<li>… 第五层 … 是 … 第四层 … 加上 … 第三层 …。</li>\n<li>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。</li>\n</ul>\n<p>发现规律了吗？没错，一句话<strong>总结</strong>就是：</p>\n<pre><code>张三后续做的决策都会受到前面所做决策的影响！\n</code></pre>\n<h2 id=\"1-3-小结一下\"><a href=\"#1-3-小结一下\" class=\"headerlink\" title=\"1.3 小结一下\"></a>1.3 小结一下</h2><p>可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。<br>这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。<br>更通俗一点的说：</p>\n<ul>\n<li><p>递归是先解决大问题，再解决小问题</p>\n</li>\n<li><p>动态规划是先解决小问题，再解决大问题</p>\n</li>\n<li><p>下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ra</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);   <span class=\"comment\">// 从最大的数字开始考虑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dp</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                i &lt;= n; i++) <span class=\"comment\">// 从最小的数字开始考虑，将所有的结果放在数组中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[i] = i * dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、解决问题\"><a href=\"#二、解决问题\" class=\"headerlink\" title=\"二、解决问题\"></a>二、解决问题</h1><h2 id=\"2-1-定义数组元素含义\"><a href=\"#2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.1 定义数组元素含义\"></a>2.1 定义数组元素含义</h2><ul>\n<li><p>首先我们重新梳理一下问题：<br><strong>假设张三正在爬楼梯，需要 n 阶才能到达楼顶。<br>每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？</strong></p>\n</li>\n<li><p>有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。<br>我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2 找出数组元素之间的关系式（状态转移方程）</h2><ul>\n<li><p>这是最难的一步，好在前面我们已经分析出来了，还记得吗？</p>\n</li>\n<li><p>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。<br>所以我们得出了状态转移方程：</p>\n</li>\n<li><p><strong>dp[n] = dp[n - 1] + dp[n - 2];</strong></p>\n</li>\n</ul>\n<h2 id=\"2-3-找出初始值\"><a href=\"#2-3-找出初始值\" class=\"headerlink\" title=\"2.3 找出初始值\"></a>2.3 找出初始值</h2><ul>\n<li>有的同学已经发现，上面的方程可能出现数组越界的问题。<br>没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；<br>因此，我们第三步要做的就是找出这些初始值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"comment\">//找出初始值</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//分析</span></span><br><span class=\"line\">        <span class=\"comment\">//爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n</span></span><br><span class=\"line\">        <span class=\"comment\">//假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[3]=dp[1]+dp[2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[1]和dp[2]是初始值，无法通过公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个数组来保存历史数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//排除两种初始情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>以上就是最经典的动态规划入门题目：<a href=\"https://leetcode.cn/problems/climbing-stairs/\">《爬楼梯》</a>的一个简单分析和对应的解法。<br>当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、定义和举例\"><a href=\"#一、定义和举例\" class=\"headerlink\" title=\"一、定义和举例\"></a>一、定义和举例</h1><h2 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h2><ul>\n<li><p>什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>\n</li>\n<li><p>很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：</p>\n</li>\n<li><p><code>动态规划就是从下往上(从前向后)阶梯型求解数值</code>。还是不明白？</p>\n</li>\n</ul>\n<h2 id=\"1-2-举个栗子\"><a href=\"#1-2-举个栗子\" class=\"headerlink\" title=\"1.2 举个栗子\"></a>1.2 举个栗子</h2><p><strong>爬楼梯</strong></p>\n<p>大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？<br>现在我们来分析一下这个场景，并加一点限制：</p>\n<ul>\n<li>张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？<br>聪明的你看都看出来了，这还不简单？</li>\n</ul>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶<br/></li>\n</ol>\n<p>OK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。<br>那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：</p>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走两阶 -&gt; 走两阶</li>\n</ol>\n<p>好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。<br>以下就是动态规划的核心思想了：</p>\n<pre><code>张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n</code></pre>\n<p>欸！对哎，可是那又怎么样呢？那可太重要了！<br>我们可以得出一个<strong>很重要的结论</strong>：</p>\n<ul>\n<li>张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。<br>再扩展一下</li>\n<li>张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。</li>\n<li>… 第五层 … 是 … 第四层 … 加上 … 第三层 …。</li>\n<li>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。</li>\n</ul>\n<p>发现规律了吗？没错，一句话<strong>总结</strong>就是：</p>\n<pre><code>张三后续做的决策都会受到前面所做决策的影响！\n</code></pre>\n<h2 id=\"1-3-小结一下\"><a href=\"#1-3-小结一下\" class=\"headerlink\" title=\"1.3 小结一下\"></a>1.3 小结一下</h2><p>可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。<br>这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。<br>更通俗一点的说：</p>\n<ul>\n<li><p>递归是先解决大问题，再解决小问题</p>\n</li>\n<li><p>动态规划是先解决小问题，再解决大问题</p>\n</li>\n<li><p>下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ra</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);   <span class=\"comment\">// 从最大的数字开始考虑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dp</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                i &lt;= n; i++) <span class=\"comment\">// 从最小的数字开始考虑，将所有的结果放在数组中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[i] = i * dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、解决问题\"><a href=\"#二、解决问题\" class=\"headerlink\" title=\"二、解决问题\"></a>二、解决问题</h1><h2 id=\"2-1-定义数组元素含义\"><a href=\"#2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.1 定义数组元素含义\"></a>2.1 定义数组元素含义</h2><ul>\n<li><p>首先我们重新梳理一下问题：<br><strong>假设张三正在爬楼梯，需要 n 阶才能到达楼顶。<br>每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？</strong></p>\n</li>\n<li><p>有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。<br>我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2 找出数组元素之间的关系式（状态转移方程）</h2><ul>\n<li><p>这是最难的一步，好在前面我们已经分析出来了，还记得吗？</p>\n</li>\n<li><p>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。<br>所以我们得出了状态转移方程：</p>\n</li>\n<li><p><strong>dp[n] = dp[n - 1] + dp[n - 2];</strong></p>\n</li>\n</ul>\n<h2 id=\"2-3-找出初始值\"><a href=\"#2-3-找出初始值\" class=\"headerlink\" title=\"2.3 找出初始值\"></a>2.3 找出初始值</h2><ul>\n<li>有的同学已经发现，上面的方程可能出现数组越界的问题。<br>没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；<br>因此，我们第三步要做的就是找出这些初始值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"comment\">//找出初始值</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//分析</span></span><br><span class=\"line\">        <span class=\"comment\">//爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n</span></span><br><span class=\"line\">        <span class=\"comment\">//假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[3]=dp[1]+dp[2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[1]和dp[2]是初始值，无法通过公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个数组来保存历史数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//排除两种初始情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>以上就是最经典的动态规划入门题目：<a href=\"https://leetcode.cn/problems/climbing-stairs/\">《爬楼梯》</a>的一个简单分析和对应的解法。<br>当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。</li>\n</ul>\n"},{"title":"不同路径","date":"2023-04-03T00:00:00.000Z","description":"介绍一个经典的动态规划问题 - 不同路径","cover":"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png","_content":"\n# 一、题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次**只能向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n**问总共有多少条不同的路径？**\n\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\">\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/unique-paths\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？\n在[爬楼梯](https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/)\n中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。\n\n- 机器人要从左上角的Start走到右下角Finish的位置，并且**只能向下或者向右移动一步**。\n  乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。\n- 机器人达到Finish，必须是**从Finish上方一个格子向下走，或者从Finish左方一个格子向右走**。\n  是不是有点眼熟？这就是本题的**核心**，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。\n- 总结：**机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解**\n\n## 2.2 算法分析\n\n还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：\n\n### 2.2.1 定义数组元素含义\n\n- 我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。\n  注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font>\n\n```java\nclass Solution {\n    /*  省略  */\n    int[][] dp = new int[m + 1][n + 1];\n    /*  省略  */\n}\n```\n\n### 2.2.2 找出数组元素之间的关系式（状态转移方程）\n\n- **dp[m][n] = dp[m][n-1] + dp[m-1][n];**\n\n### 2.2.3 找出初始值\n\n- 这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        /*  省略  */\n    }\n}\n```\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //到达finish只能是从finish左边那一格向右或上面那一格向下\n        //假设d[i][j]表示到达i*j格子的方法数\n        //找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];\n        //排除特殊情况\n        if (m <= 0 || n <= 0) {\n            return 0;\n        }\n        //定义状态转移方程\n        int[][] dp = new int[m + 1][n + 1];\n        //设置初始值\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        //运用状态转移方程求出结果\n        for (int i = 2; i <= m; i++) {\n            for (int j = 2; j <= n; j++) {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n# 四、总结\n\n- 相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。  \n  不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。","source":"_posts/动态规划_02_不同路径.md","raw":"---\ntitle: '不同路径'\ndate: '2023-04-03'\ndescription: '介绍一个经典的动态规划问题 - 不同路径'\ncover: 'https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 动态规划\n\n---\n\n# 一、题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次**只能向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n**问总共有多少条不同的路径？**\n\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\">\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/unique-paths\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？\n在[爬楼梯](https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/)\n中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。\n\n- 机器人要从左上角的Start走到右下角Finish的位置，并且**只能向下或者向右移动一步**。\n  乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。\n- 机器人达到Finish，必须是**从Finish上方一个格子向下走，或者从Finish左方一个格子向右走**。\n  是不是有点眼熟？这就是本题的**核心**，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。\n- 总结：**机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解**\n\n## 2.2 算法分析\n\n还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：\n\n### 2.2.1 定义数组元素含义\n\n- 我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。\n  注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font>\n\n```java\nclass Solution {\n    /*  省略  */\n    int[][] dp = new int[m + 1][n + 1];\n    /*  省略  */\n}\n```\n\n### 2.2.2 找出数组元素之间的关系式（状态转移方程）\n\n- **dp[m][n] = dp[m][n-1] + dp[m-1][n];**\n\n### 2.2.3 找出初始值\n\n- 这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        /*  省略  */\n    }\n}\n```\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //到达finish只能是从finish左边那一格向右或上面那一格向下\n        //假设d[i][j]表示到达i*j格子的方法数\n        //找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];\n        //排除特殊情况\n        if (m <= 0 || n <= 0) {\n            return 0;\n        }\n        //定义状态转移方程\n        int[][] dp = new int[m + 1][n + 1];\n        //设置初始值\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        //运用状态转移方程求出结果\n        for (int i = 2; i <= m; i++) {\n            for (int j = 2; j <= n; j++) {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n# 四、总结\n\n- 相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。  \n  不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。","slug":"动态规划_02_不同路径","published":1,"updated":"2023-09-25T06:18:32.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji58000e27ho9tbd4vak","content":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><strong>问总共有多少条不同的路径？</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\">\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/unique-paths\">https://leetcode.cn/problems/unique-paths</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？<br>在<a href=\"https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/\">爬楼梯</a><br>中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。</p>\n<ul>\n<li>机器人要从左上角的Start走到右下角Finish的位置，并且<strong>只能向下或者向右移动一步</strong>。<br>乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。</li>\n<li>机器人达到Finish，必须是<strong>从Finish上方一个格子向下走，或者从Finish左方一个格子向右走</strong>。<br>是不是有点眼熟？这就是本题的<strong>核心</strong>，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。</li>\n<li>总结：<strong>机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解</strong></li>\n</ul>\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：</p>\n<h3 id=\"2-2-1-定义数组元素含义\"><a href=\"#2-2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.2.1 定义数组元素含义\"></a>2.2.1 定义数组元素含义</h3><ul>\n<li>我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。<br>注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2.2 找出数组元素之间的关系式（状态转移方程）</h3><ul>\n<li><strong>dp[m][n] = dp[m][n-1] + dp[m-1][n];</strong></li>\n</ul>\n<h3 id=\"2-2-3-找出初始值\"><a href=\"#2-2-3-找出初始值\" class=\"headerlink\" title=\"2.2.3 找出初始值\"></a>2.2.3 找出初始值</h3><ul>\n<li>这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//到达finish只能是从finish左边那一格向右或上面那一格向下</span></span><br><span class=\"line\">        <span class=\"comment\">//假设d[i][j]表示到达i*j格子的方法数</span></span><br><span class=\"line\">        <span class=\"comment\">//找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];</span></span><br><span class=\"line\">        <span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &lt;= <span class=\"number\">0</span> || n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义状态转移方程</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//设置初始值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//运用状态转移方程求出结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。<br>不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><strong>问总共有多少条不同的路径？</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\">\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/unique-paths\">https://leetcode.cn/problems/unique-paths</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？<br>在<a href=\"https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/\">爬楼梯</a><br>中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。</p>\n<ul>\n<li>机器人要从左上角的Start走到右下角Finish的位置，并且<strong>只能向下或者向右移动一步</strong>。<br>乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。</li>\n<li>机器人达到Finish，必须是<strong>从Finish上方一个格子向下走，或者从Finish左方一个格子向右走</strong>。<br>是不是有点眼熟？这就是本题的<strong>核心</strong>，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。</li>\n<li>总结：<strong>机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解</strong></li>\n</ul>\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：</p>\n<h3 id=\"2-2-1-定义数组元素含义\"><a href=\"#2-2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.2.1 定义数组元素含义\"></a>2.2.1 定义数组元素含义</h3><ul>\n<li>我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。<br>注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2.2 找出数组元素之间的关系式（状态转移方程）</h3><ul>\n<li><strong>dp[m][n] = dp[m][n-1] + dp[m-1][n];</strong></li>\n</ul>\n<h3 id=\"2-2-3-找出初始值\"><a href=\"#2-2-3-找出初始值\" class=\"headerlink\" title=\"2.2.3 找出初始值\"></a>2.2.3 找出初始值</h3><ul>\n<li>这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//到达finish只能是从finish左边那一格向右或上面那一格向下</span></span><br><span class=\"line\">        <span class=\"comment\">//假设d[i][j]表示到达i*j格子的方法数</span></span><br><span class=\"line\">        <span class=\"comment\">//找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];</span></span><br><span class=\"line\">        <span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &lt;= <span class=\"number\">0</span> || n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义状态转移方程</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//设置初始值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//运用状态转移方程求出结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。<br>不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。</li>\n</ul>\n"},{"title":"OrmLite 框架的简单使用","date":"2023-04-19T00:00:00.000Z","description":"介绍如何使用OrmLite框架对SQLite数据库进行管理","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/7fe62a205607a2883501bc1b711c73d5.jpg","_content":"\n# 一、OrmLite和SQLite简介\n\n## 1.1 ORM\n\n- 首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？\n  一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。\n    - 有过 MyBatis 经验的小伙伴对\"将映射关系定义为元数据（XML、注解等形式\"这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。\n    - 没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。\n\n  举个例子：\n    - 假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的\n      SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。\n    - 使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的\n      User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。\n\n## 1.2 OrmLite\n\nLite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。\n再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。\n\n- 具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。\n- 由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。\n- OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。\n- OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。\n\n## 1.3 SQLite\n\n- SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。\n- SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。\n- 无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。\n- 支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。\n- SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。\n- SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。\n\n# 二、OrmLite的使用\n\n概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。\n\n## 2.1 引入依赖\n\n- 由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：\n\n```groovy\ndependencies {\n    //...\n    //ormlite\n    implementation 'com.j256.ormlite:ormlite-core:4.48'\n    implementation 'com.j256.ormlite:ormlite-android:4.48'\n    //...\n}\n```\n\n## 2.2 定义数据模型类\n\n- 我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，\n\n```java\n\n@DatabaseTable(tableName = \"user\")\npublic class User {\n    //唯一身份识别\n    @DatabaseField(generatedId = true) // 自动生成的主键，主键可以省略canBeNull = false\n    private int id;\n\n    //姓名\n    @DatabaseField(columnName = \"name\", canBeNull = false)\n    private String name;\n\n    //年龄\n    @DatabaseField(columnName = \"age\", canBeNull = false)\n    private int age;\n\n    //性别\n    @DatabaseField(columnName = \"gender\", canBeNull = false)\n    private String gender;\n\n    public User() {\n    }\n\n    //其他构造器、getter和setter方法、toString等\n}\n```\n\n<font color=\"FF0000\"><br>重点来了（敲黑板!!）</font>\n首先解释一下这段代码：**使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。**\n\n1. 注解解释：\n    1. @DatabaseTable(tableName = \"user\")\n       该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。\n    2. @DatabaseField(generatedId = true)\n       该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。\n    3. @DatabaseField(columnName = \"name\", canBeNull = false)\n       该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。\n2. 注意事项：\n    1. 无参构造必须存在\n       有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？  \n       Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的**无参构造**方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。\n\n## 2.3 创建工具类\n\n### 2.3.1 数据库管理工具类\n\n为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：\n\n```java\npublic class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n\n    // 数据库名称\n    private static final String DATABASE_NAME = \"db_demo.db\";\n\n    // 数据库版本号\n    private static final int DATABASE_VERSION = 1;\n\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            // 在这里创建表格\n            TableUtils.createTable(connectionSource, User.class);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            // 在这里升级表格\n            TableUtils.dropTable(connectionSource, User.class, true);\n            onCreate(db, connectionSource);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。\n通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。\n例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：\n\n```java\n        Dao<User, Integer> userDao=ormLiteUtils.getDao(User.class);\n        User user=new User(\"雷皓\",18,\"男\");\n        userDao.create(user);\n```\n\n在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。\n\n### 2.3.2 操作 DAO 对象的工具类\n\n为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：\n\n```java\npublic class OrmLiteUtils {\n\n    // 单例模式静态变量\n    private static OrmLiteUtils instance;\n    // DatabaseHelper 对象\n    private final DatabaseHelper databaseHelper;\n    // UserDao 对象\n    private Dao<User, Integer> userDao;\n\n    // 私有构造方法\n    private OrmLiteUtils(Context context) {\n        // 创建 DatabaseHelper 对象\n        databaseHelper = new DatabaseHelper(context);\n    }\n\n    // 获取实例对象（实现单例模式）\n    public static synchronized OrmLiteUtils getInstance(Context context) {\n        if (instance == null) instance = new OrmLiteUtils(context);\n\n        return instance;\n    }\n\n    // 获取 UserDao 对象\n    public synchronized Dao<User, Integer> getUserDao() throws SQLException, java.sql.SQLException {\n        if (userDao == null)\n            // 获取 Dao 对象\n            userDao = databaseHelper.getDao(User.class);\n\n        return userDao;\n    }\n}\n```\n\n该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO\n获取方法都是同步方法，防止多线程获取时出现冲突。\n\n在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。\n\n## 2.4 开始使用\n\n好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！\n接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。\n应用很简单，提供几个按钮，可以操作 user 表即可。\n\n### 2.4.1 获取数据库访问对象\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    //数据库访问对象\n    private Dao<User, Integer> userDao;\n\n    /*...*/\n    private void initEvent() {\n        /*...*/\n        // 点击获取 Dao 对象\n        OrmLiteUtils ormLiteUtils = OrmLiteUtils.getInstance(context);\n        userDao = ormLiteUtils.getUserDao();\n        /*...*/\n    }\n}\n```\n\n### 2.4.2 插入操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //插入数据\n        binding.btnInsert.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = new User(name, Integer.parseInt(age), gender);\n            //插入用户\n            userDao.create(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n### 2.4.3 删除操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //删除数据\n        binding.btnDeleteById.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = userDao.queryForId(Integer.valueOf(id));\n            //删除用户\n            userDao.delete(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。\n\n# 三、总结\n\n- 在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。\n- 除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。\n- 总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。","source":"_posts/安卓_02_OrmLite框架的简单使用.md","raw":"---\ntitle: 'OrmLite 框架的简单使用'\ndate: '2023-04-19'\ndescription: '介绍如何使用OrmLite框架对SQLite数据库进行管理'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/7fe62a205607a2883501bc1b711c73d5.jpg'\ncategories:\n\n- 数据库\n\ntags:\n\n- Android\n- Java\n- 数据库\n- SQLite\n\n---\n\n# 一、OrmLite和SQLite简介\n\n## 1.1 ORM\n\n- 首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？\n  一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。\n    - 有过 MyBatis 经验的小伙伴对\"将映射关系定义为元数据（XML、注解等形式\"这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。\n    - 没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。\n\n  举个例子：\n    - 假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的\n      SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。\n    - 使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的\n      User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。\n\n## 1.2 OrmLite\n\nLite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。\n再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。\n\n- 具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。\n- 由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。\n- OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。\n- OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。\n\n## 1.3 SQLite\n\n- SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。\n- SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。\n- 无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。\n- 支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。\n- SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。\n- SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。\n\n# 二、OrmLite的使用\n\n概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。\n\n## 2.1 引入依赖\n\n- 由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：\n\n```groovy\ndependencies {\n    //...\n    //ormlite\n    implementation 'com.j256.ormlite:ormlite-core:4.48'\n    implementation 'com.j256.ormlite:ormlite-android:4.48'\n    //...\n}\n```\n\n## 2.2 定义数据模型类\n\n- 我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，\n\n```java\n\n@DatabaseTable(tableName = \"user\")\npublic class User {\n    //唯一身份识别\n    @DatabaseField(generatedId = true) // 自动生成的主键，主键可以省略canBeNull = false\n    private int id;\n\n    //姓名\n    @DatabaseField(columnName = \"name\", canBeNull = false)\n    private String name;\n\n    //年龄\n    @DatabaseField(columnName = \"age\", canBeNull = false)\n    private int age;\n\n    //性别\n    @DatabaseField(columnName = \"gender\", canBeNull = false)\n    private String gender;\n\n    public User() {\n    }\n\n    //其他构造器、getter和setter方法、toString等\n}\n```\n\n<font color=\"FF0000\"><br>重点来了（敲黑板!!）</font>\n首先解释一下这段代码：**使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。**\n\n1. 注解解释：\n    1. @DatabaseTable(tableName = \"user\")\n       该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。\n    2. @DatabaseField(generatedId = true)\n       该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。\n    3. @DatabaseField(columnName = \"name\", canBeNull = false)\n       该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。\n2. 注意事项：\n    1. 无参构造必须存在\n       有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？  \n       Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的**无参构造**方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。\n\n## 2.3 创建工具类\n\n### 2.3.1 数据库管理工具类\n\n为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：\n\n```java\npublic class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n\n    // 数据库名称\n    private static final String DATABASE_NAME = \"db_demo.db\";\n\n    // 数据库版本号\n    private static final int DATABASE_VERSION = 1;\n\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            // 在这里创建表格\n            TableUtils.createTable(connectionSource, User.class);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            // 在这里升级表格\n            TableUtils.dropTable(connectionSource, User.class, true);\n            onCreate(db, connectionSource);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。\n通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。\n例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：\n\n```java\n        Dao<User, Integer> userDao=ormLiteUtils.getDao(User.class);\n        User user=new User(\"雷皓\",18,\"男\");\n        userDao.create(user);\n```\n\n在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。\n\n### 2.3.2 操作 DAO 对象的工具类\n\n为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：\n\n```java\npublic class OrmLiteUtils {\n\n    // 单例模式静态变量\n    private static OrmLiteUtils instance;\n    // DatabaseHelper 对象\n    private final DatabaseHelper databaseHelper;\n    // UserDao 对象\n    private Dao<User, Integer> userDao;\n\n    // 私有构造方法\n    private OrmLiteUtils(Context context) {\n        // 创建 DatabaseHelper 对象\n        databaseHelper = new DatabaseHelper(context);\n    }\n\n    // 获取实例对象（实现单例模式）\n    public static synchronized OrmLiteUtils getInstance(Context context) {\n        if (instance == null) instance = new OrmLiteUtils(context);\n\n        return instance;\n    }\n\n    // 获取 UserDao 对象\n    public synchronized Dao<User, Integer> getUserDao() throws SQLException, java.sql.SQLException {\n        if (userDao == null)\n            // 获取 Dao 对象\n            userDao = databaseHelper.getDao(User.class);\n\n        return userDao;\n    }\n}\n```\n\n该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO\n获取方法都是同步方法，防止多线程获取时出现冲突。\n\n在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。\n\n## 2.4 开始使用\n\n好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！\n接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。\n应用很简单，提供几个按钮，可以操作 user 表即可。\n\n### 2.4.1 获取数据库访问对象\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    //数据库访问对象\n    private Dao<User, Integer> userDao;\n\n    /*...*/\n    private void initEvent() {\n        /*...*/\n        // 点击获取 Dao 对象\n        OrmLiteUtils ormLiteUtils = OrmLiteUtils.getInstance(context);\n        userDao = ormLiteUtils.getUserDao();\n        /*...*/\n    }\n}\n```\n\n### 2.4.2 插入操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //插入数据\n        binding.btnInsert.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = new User(name, Integer.parseInt(age), gender);\n            //插入用户\n            userDao.create(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n### 2.4.3 删除操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //删除数据\n        binding.btnDeleteById.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = userDao.queryForId(Integer.valueOf(id));\n            //删除用户\n            userDao.delete(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。\n\n# 三、总结\n\n- 在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。\n- 除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。\n- 总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。","slug":"安卓_02_OrmLite框架的简单使用","published":1,"updated":"2023-09-25T07:03:06.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji59000i27ho2vv86h78","content":"<h1 id=\"一、OrmLite和SQLite简介\"><a href=\"#一、OrmLite和SQLite简介\" class=\"headerlink\" title=\"一、OrmLite和SQLite简介\"></a>一、OrmLite和SQLite简介</h1><h2 id=\"1-1-ORM\"><a href=\"#1-1-ORM\" class=\"headerlink\" title=\"1.1 ORM\"></a>1.1 ORM</h2><ul>\n<li><p>首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？<br>一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。</p>\n<ul>\n<li>有过 MyBatis 经验的小伙伴对”将映射关系定义为元数据（XML、注解等形式”这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。</li>\n<li>没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。</li>\n</ul>\n<p>举个例子：</p>\n<ul>\n<li>假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的<br>SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。</li>\n<li>使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的<br>User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-2-OrmLite\"><a href=\"#1-2-OrmLite\" class=\"headerlink\" title=\"1.2 OrmLite\"></a>1.2 OrmLite</h2><p>Lite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。<br>再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。</p>\n<ul>\n<li>具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。</li>\n<li>由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。</li>\n<li>OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。</li>\n<li>OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。</li>\n</ul>\n<h2 id=\"1-3-SQLite\"><a href=\"#1-3-SQLite\" class=\"headerlink\" title=\"1.3 SQLite\"></a>1.3 SQLite</h2><ul>\n<li>SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。</li>\n<li>SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。</li>\n<li>无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。</li>\n<li>支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。</li>\n<li>SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。</li>\n<li>SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。</li>\n</ul>\n<h1 id=\"二、OrmLite的使用\"><a href=\"#二、OrmLite的使用\" class=\"headerlink\" title=\"二、OrmLite的使用\"></a>二、OrmLite的使用</h1><p>概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。</p>\n<h2 id=\"2-1-引入依赖\"><a href=\"#2-1-引入依赖\" class=\"headerlink\" title=\"2.1 引入依赖\"></a>2.1 引入依赖</h2><ul>\n<li>由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//ormlite</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-core:4.48&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-android:4.48&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-定义数据模型类\"><a href=\"#2-2-定义数据模型类\" class=\"headerlink\" title=\"2.2 定义数据模型类\"></a>2.2 定义数据模型类</h2><ul>\n<li>我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DatabaseTable(tableName = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一身份识别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(generatedId = true)</span> <span class=\"comment\">// 自动生成的主键，主键可以省略canBeNull = false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;name&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;age&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;gender&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他构造器、getter和setter方法、toString等</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"FF0000\"><br>重点来了（敲黑板!!）</font><br>首先解释一下这段代码：<strong>使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。</strong></p>\n<ol>\n<li>注解解释：<ol>\n<li>@DatabaseTable(tableName = “user”)<br>该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。</li>\n<li>@DatabaseField(generatedId = true)<br>该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。</li>\n<li>@DatabaseField(columnName = “name”, canBeNull = false)<br>该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。</li>\n</ol>\n</li>\n<li>注意事项：<ol>\n<li>无参构造必须存在<br>有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？<br>Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的<strong>无参构造</strong>方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-3-创建工具类\"><a href=\"#2-3-创建工具类\" class=\"headerlink\" title=\"2.3 创建工具类\"></a>2.3 创建工具类</h2><h3 id=\"2-3-1-数据库管理工具类\"><a href=\"#2-3-1-数据库管理工具类\" class=\"headerlink\" title=\"2.3.1 数据库管理工具类\"></a>2.3.1 数据库管理工具类</h3><p>为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OrmLiteSqliteOpenHelper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DATABASE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;db_demo.db&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DATABASE_VERSION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DatabaseHelper</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, DATABASE_NAME, <span class=\"literal\">null</span>, DATABASE_VERSION);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里创建表格</span></span><br><span class=\"line\">            TableUtils.createTable(connectionSource, User.class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里升级表格</span></span><br><span class=\"line\">            TableUtils.dropTable(connectionSource, User.class, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            onCreate(db, connectionSource);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。<br>通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。<br>例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao&lt;User, Integer&gt; userDao=ormLiteUtils.getDao(User.class);</span><br><span class=\"line\">User user=<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;雷皓&quot;</span>,<span class=\"number\">18</span>,<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">userDao.create(user);</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。</p>\n<h3 id=\"2-3-2-操作-DAO-对象的工具类\"><a href=\"#2-3-2-操作-DAO-对象的工具类\" class=\"headerlink\" title=\"2.3.2 操作 DAO 对象的工具类\"></a>2.3.2 操作 DAO 对象的工具类</h3><p>为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrmLiteUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例模式静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OrmLiteUtils instance;</span><br><span class=\"line\">    <span class=\"comment\">// DatabaseHelper 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DatabaseHelper databaseHelper;</span><br><span class=\"line\">    <span class=\"comment\">// UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">OrmLiteUtils</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 DatabaseHelper 对象</span></span><br><span class=\"line\">        databaseHelper = <span class=\"keyword\">new</span> <span class=\"title class_\">DatabaseHelper</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取实例对象（实现单例模式）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> OrmLiteUtils <span class=\"title function_\">getInstance</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) instance = <span class=\"keyword\">new</span> <span class=\"title class_\">OrmLiteUtils</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Dao&lt;User, Integer&gt; <span class=\"title function_\">getUserDao</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException, java.sql.SQLException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userDao == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 获取 Dao 对象</span></span><br><span class=\"line\">            userDao = databaseHelper.getDao(User.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO<br>获取方法都是同步方法，防止多线程获取时出现冲突。</p>\n<p>在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。</p>\n<h2 id=\"2-4-开始使用\"><a href=\"#2-4-开始使用\" class=\"headerlink\" title=\"2.4 开始使用\"></a>2.4 开始使用</h2><p>好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！<br>接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。<br>应用很简单，提供几个按钮，可以操作 user 表即可。</p>\n<h3 id=\"2-4-1-获取数据库访问对象\"><a href=\"#2-4-1-获取数据库访问对象\" class=\"headerlink\" title=\"2.4.1 获取数据库访问对象\"></a>2.4.1 获取数据库访问对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数据库访问对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        <span class=\"comment\">// 点击获取 Dao 对象</span></span><br><span class=\"line\">        <span class=\"type\">OrmLiteUtils</span> <span class=\"variable\">ormLiteUtils</span> <span class=\"operator\">=</span> OrmLiteUtils.getInstance(context);</span><br><span class=\"line\">        userDao = ormLiteUtils.getUserDao();</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-插入操作\"><a href=\"#2-4-2-插入操作\" class=\"headerlink\" title=\"2.4.2 插入操作\"></a>2.4.2 插入操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入数据</span></span><br><span class=\"line\">        binding.btnInsert.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(name, Integer.parseInt(age), gender);</span><br><span class=\"line\">            <span class=\"comment\">//插入用户</span></span><br><span class=\"line\">            userDao.create(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-3-删除操作\"><a href=\"#2-4-3-删除操作\" class=\"headerlink\" title=\"2.4.3 删除操作\"></a>2.4.3 删除操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//删除数据</span></span><br><span class=\"line\">        binding.btnDeleteById.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userDao.queryForId(Integer.valueOf(id));</span><br><span class=\"line\">            <span class=\"comment\">//删除用户</span></span><br><span class=\"line\">            userDao.delete(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。</p>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。</li>\n<li>除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。</li>\n<li>总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、OrmLite和SQLite简介\"><a href=\"#一、OrmLite和SQLite简介\" class=\"headerlink\" title=\"一、OrmLite和SQLite简介\"></a>一、OrmLite和SQLite简介</h1><h2 id=\"1-1-ORM\"><a href=\"#1-1-ORM\" class=\"headerlink\" title=\"1.1 ORM\"></a>1.1 ORM</h2><ul>\n<li><p>首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？<br>一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。</p>\n<ul>\n<li>有过 MyBatis 经验的小伙伴对”将映射关系定义为元数据（XML、注解等形式”这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。</li>\n<li>没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。</li>\n</ul>\n<p>举个例子：</p>\n<ul>\n<li>假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的<br>SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。</li>\n<li>使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的<br>User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-2-OrmLite\"><a href=\"#1-2-OrmLite\" class=\"headerlink\" title=\"1.2 OrmLite\"></a>1.2 OrmLite</h2><p>Lite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。<br>再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。</p>\n<ul>\n<li>具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。</li>\n<li>由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。</li>\n<li>OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。</li>\n<li>OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。</li>\n</ul>\n<h2 id=\"1-3-SQLite\"><a href=\"#1-3-SQLite\" class=\"headerlink\" title=\"1.3 SQLite\"></a>1.3 SQLite</h2><ul>\n<li>SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。</li>\n<li>SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。</li>\n<li>无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。</li>\n<li>支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。</li>\n<li>SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。</li>\n<li>SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。</li>\n</ul>\n<h1 id=\"二、OrmLite的使用\"><a href=\"#二、OrmLite的使用\" class=\"headerlink\" title=\"二、OrmLite的使用\"></a>二、OrmLite的使用</h1><p>概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。</p>\n<h2 id=\"2-1-引入依赖\"><a href=\"#2-1-引入依赖\" class=\"headerlink\" title=\"2.1 引入依赖\"></a>2.1 引入依赖</h2><ul>\n<li>由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//ormlite</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-core:4.48&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-android:4.48&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-定义数据模型类\"><a href=\"#2-2-定义数据模型类\" class=\"headerlink\" title=\"2.2 定义数据模型类\"></a>2.2 定义数据模型类</h2><ul>\n<li>我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DatabaseTable(tableName = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一身份识别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(generatedId = true)</span> <span class=\"comment\">// 自动生成的主键，主键可以省略canBeNull = false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;name&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;age&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;gender&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他构造器、getter和setter方法、toString等</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"FF0000\"><br>重点来了（敲黑板!!）</font><br>首先解释一下这段代码：<strong>使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。</strong></p>\n<ol>\n<li>注解解释：<ol>\n<li>@DatabaseTable(tableName = “user”)<br>该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。</li>\n<li>@DatabaseField(generatedId = true)<br>该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。</li>\n<li>@DatabaseField(columnName = “name”, canBeNull = false)<br>该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。</li>\n</ol>\n</li>\n<li>注意事项：<ol>\n<li>无参构造必须存在<br>有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？<br>Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的<strong>无参构造</strong>方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-3-创建工具类\"><a href=\"#2-3-创建工具类\" class=\"headerlink\" title=\"2.3 创建工具类\"></a>2.3 创建工具类</h2><h3 id=\"2-3-1-数据库管理工具类\"><a href=\"#2-3-1-数据库管理工具类\" class=\"headerlink\" title=\"2.3.1 数据库管理工具类\"></a>2.3.1 数据库管理工具类</h3><p>为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OrmLiteSqliteOpenHelper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DATABASE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;db_demo.db&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DATABASE_VERSION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DatabaseHelper</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, DATABASE_NAME, <span class=\"literal\">null</span>, DATABASE_VERSION);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里创建表格</span></span><br><span class=\"line\">            TableUtils.createTable(connectionSource, User.class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里升级表格</span></span><br><span class=\"line\">            TableUtils.dropTable(connectionSource, User.class, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            onCreate(db, connectionSource);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。<br>通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。<br>例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao&lt;User, Integer&gt; userDao=ormLiteUtils.getDao(User.class);</span><br><span class=\"line\">User user=<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;雷皓&quot;</span>,<span class=\"number\">18</span>,<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">userDao.create(user);</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。</p>\n<h3 id=\"2-3-2-操作-DAO-对象的工具类\"><a href=\"#2-3-2-操作-DAO-对象的工具类\" class=\"headerlink\" title=\"2.3.2 操作 DAO 对象的工具类\"></a>2.3.2 操作 DAO 对象的工具类</h3><p>为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrmLiteUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例模式静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OrmLiteUtils instance;</span><br><span class=\"line\">    <span class=\"comment\">// DatabaseHelper 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DatabaseHelper databaseHelper;</span><br><span class=\"line\">    <span class=\"comment\">// UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">OrmLiteUtils</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 DatabaseHelper 对象</span></span><br><span class=\"line\">        databaseHelper = <span class=\"keyword\">new</span> <span class=\"title class_\">DatabaseHelper</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取实例对象（实现单例模式）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> OrmLiteUtils <span class=\"title function_\">getInstance</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) instance = <span class=\"keyword\">new</span> <span class=\"title class_\">OrmLiteUtils</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Dao&lt;User, Integer&gt; <span class=\"title function_\">getUserDao</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException, java.sql.SQLException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userDao == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 获取 Dao 对象</span></span><br><span class=\"line\">            userDao = databaseHelper.getDao(User.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO<br>获取方法都是同步方法，防止多线程获取时出现冲突。</p>\n<p>在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。</p>\n<h2 id=\"2-4-开始使用\"><a href=\"#2-4-开始使用\" class=\"headerlink\" title=\"2.4 开始使用\"></a>2.4 开始使用</h2><p>好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！<br>接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。<br>应用很简单，提供几个按钮，可以操作 user 表即可。</p>\n<h3 id=\"2-4-1-获取数据库访问对象\"><a href=\"#2-4-1-获取数据库访问对象\" class=\"headerlink\" title=\"2.4.1 获取数据库访问对象\"></a>2.4.1 获取数据库访问对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数据库访问对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        <span class=\"comment\">// 点击获取 Dao 对象</span></span><br><span class=\"line\">        <span class=\"type\">OrmLiteUtils</span> <span class=\"variable\">ormLiteUtils</span> <span class=\"operator\">=</span> OrmLiteUtils.getInstance(context);</span><br><span class=\"line\">        userDao = ormLiteUtils.getUserDao();</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-插入操作\"><a href=\"#2-4-2-插入操作\" class=\"headerlink\" title=\"2.4.2 插入操作\"></a>2.4.2 插入操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入数据</span></span><br><span class=\"line\">        binding.btnInsert.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(name, Integer.parseInt(age), gender);</span><br><span class=\"line\">            <span class=\"comment\">//插入用户</span></span><br><span class=\"line\">            userDao.create(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-3-删除操作\"><a href=\"#2-4-3-删除操作\" class=\"headerlink\" title=\"2.4.3 删除操作\"></a>2.4.3 删除操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//删除数据</span></span><br><span class=\"line\">        binding.btnDeleteById.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userDao.queryForId(Integer.valueOf(id));</span><br><span class=\"line\">            <span class=\"comment\">//删除用户</span></span><br><span class=\"line\">            userDao.delete(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。</p>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。</li>\n<li>除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。</li>\n<li>总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。</li>\n</ul>\n"},{"title":"安卓多线程异步任务处理的两种方案","date":"2023-03-31T00:00:00.000Z","description":"安卓多线程异步任务处理的两种方案 AsyncTask 与 Handler 的异同","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/pP7t1JO.png","_content":"\n# 一、多线程概述\n\n## 1.1 什么是多线程？\n\n- 相信只要接触过编程的同学对\"多线程\"、\"异步\"这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是\"线程\"，以及跟线程密切相关的另一个家伙：进程。\n- 一般来说，线程和进程的概念如下：\n    - 进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。\n    - 线程：一个基本的CPU执行单元 & 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。\n\n- 概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：\n    - CPU：一座时刻运行的工厂\n    - 进程：工厂的一个车间\n    - 线程：在车间里面活动的工人\n      CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 & 程序执行流的最小单元。\n\n  **多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务**\n\n# 二、安卓实现多线程异步任务的两种方式\n\n我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。\n但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论**如何让安卓实现线程间通信（一般是指子线程和主线程通信）**。\n\n## 2.1 Handler\n\n- 首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。\n    - <font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font>\n      这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。\n\n### 2.1.1 Handler的使用\n\n下面将演示Handler的基本使用</br>\n<font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。\n\n1. 定义Handler，在handleMessage方法中，推荐使用switch...case语句判断msg.what，从而进行指定的操作\n\n```Java\nclass Concurrent_ {\n    private final Handler handler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            //根据msg.what的值处理不同的任务，主线程中，可以操作UI\n            switch (msg.what) {\n                case 1:\n                    //操作1\n                    break;\n                case 2:\n                    //操作2\n                    //可以直接更改某控件的UI\n                    tvTest.setText((String) msg.obj);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n}\n```\n\n2. 子线程中使用Handler发送空消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        new Thread(() -> {\n            //模拟一个网络请求\n            try {\n                Thread.sleep(2000);//两秒后请求成功\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            handler.sendEmptyMessage(1);//使用sendEmptyMessage发送一个空消息，what为1\n        }).start();\n    }\n}\n```\n\n3. 子线程中使用Handler发送消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        /*  省略  */\n        Message message = new Message();\n        message.obj = \"Hello Word\";\n        message.what = 2;\n        handler.sendMessage(message);//使用sendMessage发送一个带Message对象的消息，what为2\n        /*  省略  */\n    }\n}\n```\n\n### 2.1.2 Handler小结\n\n- 可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)\n  运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。\n\n## 2.2 AsyncTask\n\nAsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。\n\n### 2.2.1 AsyncTask的使用\n\n1. 创建一个类继承自AsyncTask\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    /*  省略  */\n    @Override\n    protected Bitmap doInBackground(Integer... integers) {\n        //做异步任务\n    }\n\n    /*  省略  */\n    @Override\n    protected void onPostExecute(Bitmap bitmap) {\n        //异步任务完成后的操作\n    }\n}\n\n```\n\n2. 开启异步任务\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        MyTask myTask = new MyTask();\n        myTask.execute();\n    }\n}\n```\n\n是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。\n除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    @Override\n    protected void onPreExecute() {\n        //执行异步任务之前，当然还处于主线程，可以操作UI\n    }\n\n    @Override\n    protected void onProgressUpdate(Void... values) {\n        //用来更新进度条等操作\n    }\n}\n```\n\nAsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理\n他的三个泛型参数AsyncTask<Integer, Void, Bitmap>代表的含义分别是：\n\n- Void：表示在执行AsyncTask的时候不需要传入参数给后台任务\n- Integer：表示使用整型数据来作为进度显示单位\n- Bitmap：表示使用Bitmap位图来反馈执行结果\n\n下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：\n\n```java\nclass AsyncTask_ extends AsyncTask<Void, Integer, Boolean> {\n\n    //在一步开始之前，在主线程，可操作UI，一般用来做准备工作\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        Toast.makeText(context, \"开始模拟下载\", Toast.LENGTH_SHORT).show();\n    }\n\n    //异步线程中执行\n    @Override\n    protected Boolean doInBackground(Void... voids) {\n        int p = 0;\n        //模拟网络延迟\n        try {\n            //p = 1 / 0;//模拟下载失败\n            while (p < 100) {\n                Thread.sleep(1000);\n                p += 10;\n                publishProgress(p);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        //通知主线程当前执行的进度\n        return true;\n    }\n\n    //切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n        super.onProgressUpdate(values);\n        Log.e(\"TAG\", \"正在下载：\" + values[0] + \"%\");\n        binding.pb.setProgress(values[0]);\n    }\n\n    //切换到主线程\n    @Override\n    protected void onPostExecute(Boolean b) {\n        super.onPostExecute(b);\n        if (b) {\n            Toast.makeText(context, \"下载完成！\", Toast.LENGTH_SHORT).show();\n        } else Toast.makeText(context, \"下载失败！\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n### 2.2.2 AsyncTask小结\n\n- 不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。\n\n# 三、总结\n\n- Handler\n    - 优点\n        - 结构清晰，功能定义明确\n        - 对于多个后台任务时，更加简单，根据msg.what进行判断即可\n    - 缺点\n        - 在单个后台异步处理时，显得代码过多，结构过于复杂\n- AsyncTask\n    - 优点\n        - 对于单个任务是，更加简单，快捷\n        - 操作过程更加清晰明确，过程可控\n    - 缺点\n        - 在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来\n        - 最大并发数不超过5\n\n- 看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。","source":"_posts/安卓_01_安卓多线程异步任务处理的两种方案.md","raw":"---\ntitle: '安卓多线程异步任务处理的两种方案'\ndate: '2023-03-31'\ndescription: '安卓多线程异步任务处理的两种方案 AsyncTask 与 Handler 的异同'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/pP7t1JO.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Java\n- Android\n- 并发编程\n\n---\n\n# 一、多线程概述\n\n## 1.1 什么是多线程？\n\n- 相信只要接触过编程的同学对\"多线程\"、\"异步\"这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是\"线程\"，以及跟线程密切相关的另一个家伙：进程。\n- 一般来说，线程和进程的概念如下：\n    - 进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。\n    - 线程：一个基本的CPU执行单元 & 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。\n\n- 概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：\n    - CPU：一座时刻运行的工厂\n    - 进程：工厂的一个车间\n    - 线程：在车间里面活动的工人\n      CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 & 程序执行流的最小单元。\n\n  **多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务**\n\n# 二、安卓实现多线程异步任务的两种方式\n\n我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。\n但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论**如何让安卓实现线程间通信（一般是指子线程和主线程通信）**。\n\n## 2.1 Handler\n\n- 首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。\n    - <font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font>\n      这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。\n\n### 2.1.1 Handler的使用\n\n下面将演示Handler的基本使用</br>\n<font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。\n\n1. 定义Handler，在handleMessage方法中，推荐使用switch...case语句判断msg.what，从而进行指定的操作\n\n```Java\nclass Concurrent_ {\n    private final Handler handler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            //根据msg.what的值处理不同的任务，主线程中，可以操作UI\n            switch (msg.what) {\n                case 1:\n                    //操作1\n                    break;\n                case 2:\n                    //操作2\n                    //可以直接更改某控件的UI\n                    tvTest.setText((String) msg.obj);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n}\n```\n\n2. 子线程中使用Handler发送空消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        new Thread(() -> {\n            //模拟一个网络请求\n            try {\n                Thread.sleep(2000);//两秒后请求成功\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            handler.sendEmptyMessage(1);//使用sendEmptyMessage发送一个空消息，what为1\n        }).start();\n    }\n}\n```\n\n3. 子线程中使用Handler发送消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        /*  省略  */\n        Message message = new Message();\n        message.obj = \"Hello Word\";\n        message.what = 2;\n        handler.sendMessage(message);//使用sendMessage发送一个带Message对象的消息，what为2\n        /*  省略  */\n    }\n}\n```\n\n### 2.1.2 Handler小结\n\n- 可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)\n  运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。\n\n## 2.2 AsyncTask\n\nAsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。\n\n### 2.2.1 AsyncTask的使用\n\n1. 创建一个类继承自AsyncTask\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    /*  省略  */\n    @Override\n    protected Bitmap doInBackground(Integer... integers) {\n        //做异步任务\n    }\n\n    /*  省略  */\n    @Override\n    protected void onPostExecute(Bitmap bitmap) {\n        //异步任务完成后的操作\n    }\n}\n\n```\n\n2. 开启异步任务\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        MyTask myTask = new MyTask();\n        myTask.execute();\n    }\n}\n```\n\n是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。\n除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    @Override\n    protected void onPreExecute() {\n        //执行异步任务之前，当然还处于主线程，可以操作UI\n    }\n\n    @Override\n    protected void onProgressUpdate(Void... values) {\n        //用来更新进度条等操作\n    }\n}\n```\n\nAsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理\n他的三个泛型参数AsyncTask<Integer, Void, Bitmap>代表的含义分别是：\n\n- Void：表示在执行AsyncTask的时候不需要传入参数给后台任务\n- Integer：表示使用整型数据来作为进度显示单位\n- Bitmap：表示使用Bitmap位图来反馈执行结果\n\n下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：\n\n```java\nclass AsyncTask_ extends AsyncTask<Void, Integer, Boolean> {\n\n    //在一步开始之前，在主线程，可操作UI，一般用来做准备工作\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        Toast.makeText(context, \"开始模拟下载\", Toast.LENGTH_SHORT).show();\n    }\n\n    //异步线程中执行\n    @Override\n    protected Boolean doInBackground(Void... voids) {\n        int p = 0;\n        //模拟网络延迟\n        try {\n            //p = 1 / 0;//模拟下载失败\n            while (p < 100) {\n                Thread.sleep(1000);\n                p += 10;\n                publishProgress(p);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        //通知主线程当前执行的进度\n        return true;\n    }\n\n    //切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n        super.onProgressUpdate(values);\n        Log.e(\"TAG\", \"正在下载：\" + values[0] + \"%\");\n        binding.pb.setProgress(values[0]);\n    }\n\n    //切换到主线程\n    @Override\n    protected void onPostExecute(Boolean b) {\n        super.onPostExecute(b);\n        if (b) {\n            Toast.makeText(context, \"下载完成！\", Toast.LENGTH_SHORT).show();\n        } else Toast.makeText(context, \"下载失败！\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n### 2.2.2 AsyncTask小结\n\n- 不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。\n\n# 三、总结\n\n- Handler\n    - 优点\n        - 结构清晰，功能定义明确\n        - 对于多个后台任务时，更加简单，根据msg.what进行判断即可\n    - 缺点\n        - 在单个后台异步处理时，显得代码过多，结构过于复杂\n- AsyncTask\n    - 优点\n        - 对于单个任务是，更加简单，快捷\n        - 操作过程更加清晰明确，过程可控\n    - 缺点\n        - 在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来\n        - 最大并发数不超过5\n\n- 看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。","slug":"安卓_01_安卓多线程异步任务处理的两种方案","published":1,"updated":"2023-09-25T07:08:19.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5a000k27ho8gup2fmb","content":"<h1 id=\"一、多线程概述\"><a href=\"#一、多线程概述\" class=\"headerlink\" title=\"一、多线程概述\"></a>一、多线程概述</h1><h2 id=\"1-1-什么是多线程？\"><a href=\"#1-1-什么是多线程？\" class=\"headerlink\" title=\"1.1 什么是多线程？\"></a>1.1 什么是多线程？</h2><ul>\n<li><p>相信只要接触过编程的同学对”多线程”、”异步”这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是”线程”，以及跟线程密切相关的另一个家伙：进程。</p>\n</li>\n<li><p>一般来说，线程和进程的概念如下：</p>\n<ul>\n<li>进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。</li>\n<li>线程：一个基本的CPU执行单元 &amp; 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。</li>\n</ul>\n</li>\n<li><p>概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：</p>\n<ul>\n<li>CPU：一座时刻运行的工厂</li>\n<li>进程：工厂的一个车间</li>\n<li>线程：在车间里面活动的工人<br>CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 &amp; 程序执行流的最小单元。</li>\n</ul>\n<p><strong>多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务</strong></p>\n</li>\n</ul>\n<h1 id=\"二、安卓实现多线程异步任务的两种方式\"><a href=\"#二、安卓实现多线程异步任务的两种方式\" class=\"headerlink\" title=\"二、安卓实现多线程异步任务的两种方式\"></a>二、安卓实现多线程异步任务的两种方式</h1><p>我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。<br>但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论<strong>如何让安卓实现线程间通信（一般是指子线程和主线程通信）</strong>。</p>\n<h2 id=\"2-1-Handler\"><a href=\"#2-1-Handler\" class=\"headerlink\" title=\"2.1 Handler\"></a>2.1 Handler</h2><ul>\n<li>首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。<ul>\n<li><font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font><br>这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-1-Handler的使用\"><a href=\"#2-1-1-Handler的使用\" class=\"headerlink\" title=\"2.1.1 Handler的使用\"></a>2.1.1 Handler的使用</h3><p>下面将演示Handler的基本使用</br><br><font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。</p>\n<ol>\n<li>定义Handler，在handleMessage方法中，推荐使用switch…case语句判断msg.what，从而进行指定的操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据msg.what的值处理不同的任务，主线程中，可以操作UI</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作2</span></span><br><span class=\"line\">                    <span class=\"comment\">//可以直接更改某控件的UI</span></span><br><span class=\"line\">                    tvTest.setText((String) msg.obj);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子线程中使用Handler发送空消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//模拟一个网络请求</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//两秒后请求成功</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">1</span>);<span class=\"comment\">//使用sendEmptyMessage发送一个空消息，what为1</span></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子线程中使用Handler发送消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>();</span><br><span class=\"line\">        message.obj = <span class=\"string\">&quot;Hello Word&quot;</span>;</span><br><span class=\"line\">        message.what = <span class=\"number\">2</span>;</span><br><span class=\"line\">        handler.sendMessage(message);<span class=\"comment\">//使用sendMessage发送一个带Message对象的消息，what为2</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-Handler小结\"><a href=\"#2-1-2-Handler小结\" class=\"headerlink\" title=\"2.1.2 Handler小结\"></a>2.1.2 Handler小结</h3><ul>\n<li>可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)<br>运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。</li>\n</ul>\n<h2 id=\"2-2-AsyncTask\"><a href=\"#2-2-AsyncTask\" class=\"headerlink\" title=\"2.2 AsyncTask\"></a>2.2 AsyncTask</h2><p>AsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。</p>\n<h3 id=\"2-2-1-AsyncTask的使用\"><a href=\"#2-2-1-AsyncTask的使用\" class=\"headerlink\" title=\"2.2.1 AsyncTask的使用\"></a>2.2.1 AsyncTask的使用</h3><ol>\n<li>创建一个类继承自AsyncTask</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Bitmap <span class=\"title function_\">doInBackground</span><span class=\"params\">(Integer... integers)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//做异步任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//异步任务完成后的操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启异步任务</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyTask</span> <span class=\"variable\">myTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyTask</span>();</span><br><span class=\"line\">        myTask.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。<br>除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行异步任务之前，当然还处于主线程，可以操作UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Void... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用来更新进度条等操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理<br>他的三个泛型参数AsyncTask&lt;Integer, Void, Bitmap&gt;代表的含义分别是：</p>\n<ul>\n<li>Void：表示在执行AsyncTask的时候不需要传入参数给后台任务</li>\n<li>Integer：表示使用整型数据来作为进度显示单位</li>\n<li>Bitmap：表示使用Bitmap位图来反馈执行结果</li>\n</ul>\n<p>下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncTask_</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//在一步开始之前，在主线程，可操作UI，一般用来做准备工作</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPreExecute();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;开始模拟下载&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异步线程中执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Boolean <span class=\"title function_\">doInBackground</span><span class=\"params\">(Void... voids)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//模拟网络延迟</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p = 1 / 0;//模拟下载失败</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                p += <span class=\"number\">10</span>;</span><br><span class=\"line\">                publishProgress(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//通知主线程当前执行的进度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Integer... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onProgressUpdate(values);</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;正在下载：&quot;</span> + values[<span class=\"number\">0</span>] + <span class=\"string\">&quot;%&quot;</span>);</span><br><span class=\"line\">        binding.pb.setProgress(values[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到主线程</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Boolean b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPostExecute(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">            Toast.makeText(context, <span class=\"string\">&quot;下载完成！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> Toast.makeText(context, <span class=\"string\">&quot;下载失败！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-AsyncTask小结\"><a href=\"#2-2-2-AsyncTask小结\" class=\"headerlink\" title=\"2.2.2 AsyncTask小结\"></a>2.2.2 AsyncTask小结</h3><ul>\n<li>不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li><p>Handler</p>\n<ul>\n<li>优点<ul>\n<li>结构清晰，功能定义明确</li>\n<li>对于多个后台任务时，更加简单，根据msg.what进行判断即可</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在单个后台异步处理时，显得代码过多，结构过于复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AsyncTask</p>\n<ul>\n<li>优点<ul>\n<li>对于单个任务是，更加简单，快捷</li>\n<li>操作过程更加清晰明确，过程可控</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来</li>\n<li>最大并发数不超过5</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。</p>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、多线程概述\"><a href=\"#一、多线程概述\" class=\"headerlink\" title=\"一、多线程概述\"></a>一、多线程概述</h1><h2 id=\"1-1-什么是多线程？\"><a href=\"#1-1-什么是多线程？\" class=\"headerlink\" title=\"1.1 什么是多线程？\"></a>1.1 什么是多线程？</h2><ul>\n<li><p>相信只要接触过编程的同学对”多线程”、”异步”这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是”线程”，以及跟线程密切相关的另一个家伙：进程。</p>\n</li>\n<li><p>一般来说，线程和进程的概念如下：</p>\n<ul>\n<li>进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。</li>\n<li>线程：一个基本的CPU执行单元 &amp; 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。</li>\n</ul>\n</li>\n<li><p>概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：</p>\n<ul>\n<li>CPU：一座时刻运行的工厂</li>\n<li>进程：工厂的一个车间</li>\n<li>线程：在车间里面活动的工人<br>CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 &amp; 程序执行流的最小单元。</li>\n</ul>\n<p><strong>多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务</strong></p>\n</li>\n</ul>\n<h1 id=\"二、安卓实现多线程异步任务的两种方式\"><a href=\"#二、安卓实现多线程异步任务的两种方式\" class=\"headerlink\" title=\"二、安卓实现多线程异步任务的两种方式\"></a>二、安卓实现多线程异步任务的两种方式</h1><p>我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。<br>但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论<strong>如何让安卓实现线程间通信（一般是指子线程和主线程通信）</strong>。</p>\n<h2 id=\"2-1-Handler\"><a href=\"#2-1-Handler\" class=\"headerlink\" title=\"2.1 Handler\"></a>2.1 Handler</h2><ul>\n<li>首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。<ul>\n<li><font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font><br>这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-1-Handler的使用\"><a href=\"#2-1-1-Handler的使用\" class=\"headerlink\" title=\"2.1.1 Handler的使用\"></a>2.1.1 Handler的使用</h3><p>下面将演示Handler的基本使用</br><br><font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。</p>\n<ol>\n<li>定义Handler，在handleMessage方法中，推荐使用switch…case语句判断msg.what，从而进行指定的操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据msg.what的值处理不同的任务，主线程中，可以操作UI</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作2</span></span><br><span class=\"line\">                    <span class=\"comment\">//可以直接更改某控件的UI</span></span><br><span class=\"line\">                    tvTest.setText((String) msg.obj);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子线程中使用Handler发送空消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//模拟一个网络请求</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//两秒后请求成功</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">1</span>);<span class=\"comment\">//使用sendEmptyMessage发送一个空消息，what为1</span></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子线程中使用Handler发送消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>();</span><br><span class=\"line\">        message.obj = <span class=\"string\">&quot;Hello Word&quot;</span>;</span><br><span class=\"line\">        message.what = <span class=\"number\">2</span>;</span><br><span class=\"line\">        handler.sendMessage(message);<span class=\"comment\">//使用sendMessage发送一个带Message对象的消息，what为2</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-Handler小结\"><a href=\"#2-1-2-Handler小结\" class=\"headerlink\" title=\"2.1.2 Handler小结\"></a>2.1.2 Handler小结</h3><ul>\n<li>可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)<br>运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。</li>\n</ul>\n<h2 id=\"2-2-AsyncTask\"><a href=\"#2-2-AsyncTask\" class=\"headerlink\" title=\"2.2 AsyncTask\"></a>2.2 AsyncTask</h2><p>AsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。</p>\n<h3 id=\"2-2-1-AsyncTask的使用\"><a href=\"#2-2-1-AsyncTask的使用\" class=\"headerlink\" title=\"2.2.1 AsyncTask的使用\"></a>2.2.1 AsyncTask的使用</h3><ol>\n<li>创建一个类继承自AsyncTask</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Bitmap <span class=\"title function_\">doInBackground</span><span class=\"params\">(Integer... integers)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//做异步任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//异步任务完成后的操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启异步任务</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyTask</span> <span class=\"variable\">myTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyTask</span>();</span><br><span class=\"line\">        myTask.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。<br>除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行异步任务之前，当然还处于主线程，可以操作UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Void... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用来更新进度条等操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理<br>他的三个泛型参数AsyncTask&lt;Integer, Void, Bitmap&gt;代表的含义分别是：</p>\n<ul>\n<li>Void：表示在执行AsyncTask的时候不需要传入参数给后台任务</li>\n<li>Integer：表示使用整型数据来作为进度显示单位</li>\n<li>Bitmap：表示使用Bitmap位图来反馈执行结果</li>\n</ul>\n<p>下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncTask_</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//在一步开始之前，在主线程，可操作UI，一般用来做准备工作</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPreExecute();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;开始模拟下载&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异步线程中执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Boolean <span class=\"title function_\">doInBackground</span><span class=\"params\">(Void... voids)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//模拟网络延迟</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p = 1 / 0;//模拟下载失败</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                p += <span class=\"number\">10</span>;</span><br><span class=\"line\">                publishProgress(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//通知主线程当前执行的进度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Integer... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onProgressUpdate(values);</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;正在下载：&quot;</span> + values[<span class=\"number\">0</span>] + <span class=\"string\">&quot;%&quot;</span>);</span><br><span class=\"line\">        binding.pb.setProgress(values[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到主线程</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Boolean b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPostExecute(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">            Toast.makeText(context, <span class=\"string\">&quot;下载完成！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> Toast.makeText(context, <span class=\"string\">&quot;下载失败！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-AsyncTask小结\"><a href=\"#2-2-2-AsyncTask小结\" class=\"headerlink\" title=\"2.2.2 AsyncTask小结\"></a>2.2.2 AsyncTask小结</h3><ul>\n<li>不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li><p>Handler</p>\n<ul>\n<li>优点<ul>\n<li>结构清晰，功能定义明确</li>\n<li>对于多个后台任务时，更加简单，根据msg.what进行判断即可</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在单个后台异步处理时，显得代码过多，结构过于复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AsyncTask</p>\n<ul>\n<li>优点<ul>\n<li>对于单个任务是，更加简单，快捷</li>\n<li>操作过程更加清晰明确，过程可控</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来</li>\n<li>最大并发数不超过5</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。</p>\n</li>\n</ul>\n"},{"title":"初识 Jetpack","date":"2023-05-12T00:00:00.000Z","description":"初步了解Jetpack的概念和目标，并介绍LiveCycle、LiveData和ViewModel组件。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg","_content":"\n# 一、Jetpack 的概念和目标\n\n## 1.1 概念\n\n- Jetpack是一个由Google官方推出的Android应用程序开发工具包。\n- 举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。\n- 通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。\n\n## 1.2 目标\n\n- 旨在提供一系列库和工具，帮助开发者`更快`、`更简便`地构建`高质量`的Android应用程序。\n\n# 二、Jetpack 的诞生和发展\n\n## 2.1 诞生\n\n- Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的\"引擎\"或\"助推器\"的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。\n- 最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。\n\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg\" width=\"30%\">\n\n## 2.2 发展\n\n- 当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。\n- 随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。\n- 2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。\n- 2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。\n- 总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。\n\n\n# 三、Jetpack 的运用\n\n- 说明：\n  1. 由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。\n  2. 为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用`Kotlin`。\n\n## 3.1 LiveCycle\n\n- Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。\n- 作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。\n- Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。\n\n下面是代码示例：\n\n```kotlin\nimport androidx.lifecycle.LifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.OnLifecycleEvent\n\nclass MyLifecycleObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate(owner: LifecycleOwner) {\n        // 执行 onCreate 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart(owner: LifecycleOwner) {\n        // 执行 onStart 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume(owner: LifecycleOwner) {\n        // 执行 onResume 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause(owner: LifecycleOwner) {\n        // 执行 onPause 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onStop(owner: LifecycleOwner) {\n        // 执行 onStop 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy(owner: LifecycleOwner) {\n        // 执行 onDestroy 事件\n    }\n}\n```\n- 上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。\n- 下面演示如何使用：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private lateinit var myObserver: MyLifecycleObserver\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 创建 MyLifecycleObserver 实例\n        myObserver = MyLifecycleObserver()\n        \n        // 将 myObserver 添加到 Activity 的生命周期观察者列表中\n        lifecycle.addObserver(myObserver)\n    }\n}\n```\n- 在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：\n\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    //从观察者列表中移除\n    lifecycle.removeObserver(myObserver)\n}\n```\n\n- 如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。\n\n## 3.2 LiveData 和 ViewModel\n\n- 由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。\n- LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。\n- ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n- 在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为`旋转手机、配置更改（如切换语言）、资源内存不足`等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。\n\n- 下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。\n\n1. 先自定义一个继承自 ViewModel 的 DataBindingViewModel 类\n```kotlin\n// 定义一个 MyViewModel 类，继承自 ViewModel\nclass MyViewModel : ViewModel() {\n  // 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字\n  var number: MutableLiveData<Int> = MutableLiveData()\n\n  // addOne 方法，用于将 number 自增 1\n  fun addOne() {\n    // 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0\n    number.value = (number.value ?: 0) + 1\n  }\n}\n```\n2. 在 Activity 中使用\n```kotlin\nclass ViewModelActivity : AppCompatActivity() {\n    // 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding\n    private lateinit var binding: ActivityViewModelBinding\n    // 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象\n    private val myViewModel: MyViewModel by viewModels()\n  \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象\n        binding = ActivityViewModelBinding.inflate(layoutInflater)\n        // 设置界面布局为 binding.root\n        setContentView(binding.root)\n    \n        // 观察 myViewModel 中的 number 属性的变化\n        myViewModel.number.observe(this, Observer {\n          // 将 number 的值显示在 textView 上\n          binding.textView.text = myViewModel.number.value.toString()\n        })\n    \n        // 给 button 的点击事件添加监听器\n        binding.button.setOnClickListener {\n          // 在 myViewModel 中执行 addOne 函数\n          myViewModel.addOne()\n        }\n    }\n}\n```\n\n- 上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。\n- 总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。\n\n# 四、总结\n\n- 由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定...或许接触新知识的最大的乐趣就在于此吧。\n- 这两天使用 kotlin 进行编码，也让我对 Kotlin 语法'太甜了'的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。","source":"_posts/安卓_03_初识Jetpack.md","raw":"---\ntitle: '初识 Jetpack'\ndate: '2023-05-12'\ndescription: '初步了解Jetpack的概念和目标，并介绍LiveCycle、LiveData和ViewModel组件。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n# 一、Jetpack 的概念和目标\n\n## 1.1 概念\n\n- Jetpack是一个由Google官方推出的Android应用程序开发工具包。\n- 举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。\n- 通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。\n\n## 1.2 目标\n\n- 旨在提供一系列库和工具，帮助开发者`更快`、`更简便`地构建`高质量`的Android应用程序。\n\n# 二、Jetpack 的诞生和发展\n\n## 2.1 诞生\n\n- Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的\"引擎\"或\"助推器\"的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。\n- 最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。\n\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg\" width=\"30%\">\n\n## 2.2 发展\n\n- 当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。\n- 随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。\n- 2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。\n- 2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。\n- 总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。\n\n\n# 三、Jetpack 的运用\n\n- 说明：\n  1. 由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。\n  2. 为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用`Kotlin`。\n\n## 3.1 LiveCycle\n\n- Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。\n- 作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。\n- Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。\n\n下面是代码示例：\n\n```kotlin\nimport androidx.lifecycle.LifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.OnLifecycleEvent\n\nclass MyLifecycleObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate(owner: LifecycleOwner) {\n        // 执行 onCreate 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart(owner: LifecycleOwner) {\n        // 执行 onStart 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume(owner: LifecycleOwner) {\n        // 执行 onResume 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause(owner: LifecycleOwner) {\n        // 执行 onPause 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onStop(owner: LifecycleOwner) {\n        // 执行 onStop 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy(owner: LifecycleOwner) {\n        // 执行 onDestroy 事件\n    }\n}\n```\n- 上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。\n- 下面演示如何使用：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private lateinit var myObserver: MyLifecycleObserver\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 创建 MyLifecycleObserver 实例\n        myObserver = MyLifecycleObserver()\n        \n        // 将 myObserver 添加到 Activity 的生命周期观察者列表中\n        lifecycle.addObserver(myObserver)\n    }\n}\n```\n- 在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：\n\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    //从观察者列表中移除\n    lifecycle.removeObserver(myObserver)\n}\n```\n\n- 如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。\n\n## 3.2 LiveData 和 ViewModel\n\n- 由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。\n- LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。\n- ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n- 在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为`旋转手机、配置更改（如切换语言）、资源内存不足`等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。\n\n- 下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。\n\n1. 先自定义一个继承自 ViewModel 的 DataBindingViewModel 类\n```kotlin\n// 定义一个 MyViewModel 类，继承自 ViewModel\nclass MyViewModel : ViewModel() {\n  // 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字\n  var number: MutableLiveData<Int> = MutableLiveData()\n\n  // addOne 方法，用于将 number 自增 1\n  fun addOne() {\n    // 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0\n    number.value = (number.value ?: 0) + 1\n  }\n}\n```\n2. 在 Activity 中使用\n```kotlin\nclass ViewModelActivity : AppCompatActivity() {\n    // 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding\n    private lateinit var binding: ActivityViewModelBinding\n    // 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象\n    private val myViewModel: MyViewModel by viewModels()\n  \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象\n        binding = ActivityViewModelBinding.inflate(layoutInflater)\n        // 设置界面布局为 binding.root\n        setContentView(binding.root)\n    \n        // 观察 myViewModel 中的 number 属性的变化\n        myViewModel.number.observe(this, Observer {\n          // 将 number 的值显示在 textView 上\n          binding.textView.text = myViewModel.number.value.toString()\n        })\n    \n        // 给 button 的点击事件添加监听器\n        binding.button.setOnClickListener {\n          // 在 myViewModel 中执行 addOne 函数\n          myViewModel.addOne()\n        }\n    }\n}\n```\n\n- 上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。\n- 总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。\n\n# 四、总结\n\n- 由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定...或许接触新知识的最大的乐趣就在于此吧。\n- 这两天使用 kotlin 进行编码，也让我对 Kotlin 语法'太甜了'的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。","slug":"安卓_03_初识Jetpack","published":1,"updated":"2023-09-25T06:57:56.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5b000o27hogi39fh5e","content":"<h1 id=\"一、Jetpack-的概念和目标\"><a href=\"#一、Jetpack-的概念和目标\" class=\"headerlink\" title=\"一、Jetpack 的概念和目标\"></a>一、Jetpack 的概念和目标</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack是一个由Google官方推出的Android应用程序开发工具包。</li>\n<li>举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。</li>\n<li>通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。</li>\n</ul>\n<h2 id=\"1-2-目标\"><a href=\"#1-2-目标\" class=\"headerlink\" title=\"1.2 目标\"></a>1.2 目标</h2><ul>\n<li>旨在提供一系列库和工具，帮助开发者<code>更快</code>、<code>更简便</code>地构建<code>高质量</code>的Android应用程序。</li>\n</ul>\n<h1 id=\"二、Jetpack-的诞生和发展\"><a href=\"#二、Jetpack-的诞生和发展\" class=\"headerlink\" title=\"二、Jetpack 的诞生和发展\"></a>二、Jetpack 的诞生和发展</h1><h2 id=\"2-1-诞生\"><a href=\"#2-1-诞生\" class=\"headerlink\" title=\"2.1 诞生\"></a>2.1 诞生</h2><ul>\n<li>Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的”引擎”或”助推器”的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。</li>\n<li>最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg\" width=\"30%\">\n\n<h2 id=\"2-2-发展\"><a href=\"#2-2-发展\" class=\"headerlink\" title=\"2.2 发展\"></a>2.2 发展</h2><ul>\n<li>当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。</li>\n<li>随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。</li>\n<li>2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。</li>\n<li>2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。</li>\n<li>总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。</li>\n</ul>\n<h1 id=\"三、Jetpack-的运用\"><a href=\"#三、Jetpack-的运用\" class=\"headerlink\" title=\"三、Jetpack 的运用\"></a>三、Jetpack 的运用</h1><ul>\n<li>说明：<ol>\n<li>由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。</li>\n<li>为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用<code>Kotlin</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-1-LiveCycle\"><a href=\"#3-1-LiveCycle\" class=\"headerlink\" title=\"3.1 LiveCycle\"></a>3.1 LiveCycle</h2><ul>\n<li>Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。</li>\n<li>作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。</li>\n<li>Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleOwner</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.OnLifecycleEvent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLifecycleObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onCreate 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStart 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onResume 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onPause 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStop 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onDestroy 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。</li>\n<li>下面演示如何使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> myObserver: MyLifecycleObserver</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建 MyLifecycleObserver 实例</span></span><br><span class=\"line\">        myObserver = MyLifecycleObserver()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将 myObserver 添加到 Activity 的生命周期观察者列表中</span></span><br><span class=\"line\">        lifecycle.addObserver(myObserver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">    <span class=\"comment\">//从观察者列表中移除</span></span><br><span class=\"line\">    lifecycle.removeObserver(myObserver)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。</li>\n</ul>\n<h2 id=\"3-2-LiveData-和-ViewModel\"><a href=\"#3-2-LiveData-和-ViewModel\" class=\"headerlink\" title=\"3.2 LiveData 和 ViewModel\"></a>3.2 LiveData 和 ViewModel</h2><ul>\n<li><p>由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。</p>\n</li>\n<li><p>LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。</p>\n</li>\n<li><p>ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</p>\n</li>\n<li><p>在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为<code>旋转手机、配置更改（如切换语言）、资源内存不足</code>等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。</p>\n</li>\n<li><p>下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。</p>\n</li>\n</ul>\n<ol>\n<li>先自定义一个继承自 ViewModel 的 DataBindingViewModel 类<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个 MyViewModel 类，继承自 ViewModel</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> number: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// addOne 方法，用于将 number 自增 1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOne</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0</span></span><br><span class=\"line\">    number.value = (number.value ?: <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 Activity 中使用<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ViewModelActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityViewModelBinding</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> viewModels()</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">// 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象</span></span><br><span class=\"line\">        binding = ActivityViewModelBinding.inflate(layoutInflater)</span><br><span class=\"line\">        <span class=\"comment\">// 设置界面布局为 binding.root</span></span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 观察 myViewModel 中的 number 属性的变化</span></span><br><span class=\"line\">        myViewModel.number.observe(<span class=\"keyword\">this</span>, Observer &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 number 的值显示在 textView 上</span></span><br><span class=\"line\">          binding.textView.text = myViewModel.number.value.toString()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 给 button 的点击事件添加监听器</span></span><br><span class=\"line\">        binding.button.setOnClickListener &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在 myViewModel 中执行 addOne 函数</span></span><br><span class=\"line\">          myViewModel.addOne()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。</li>\n<li>总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定…或许接触新知识的最大的乐趣就在于此吧。</li>\n<li>这两天使用 kotlin 进行编码，也让我对 Kotlin 语法’太甜了’的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、Jetpack-的概念和目标\"><a href=\"#一、Jetpack-的概念和目标\" class=\"headerlink\" title=\"一、Jetpack 的概念和目标\"></a>一、Jetpack 的概念和目标</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack是一个由Google官方推出的Android应用程序开发工具包。</li>\n<li>举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。</li>\n<li>通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。</li>\n</ul>\n<h2 id=\"1-2-目标\"><a href=\"#1-2-目标\" class=\"headerlink\" title=\"1.2 目标\"></a>1.2 目标</h2><ul>\n<li>旨在提供一系列库和工具，帮助开发者<code>更快</code>、<code>更简便</code>地构建<code>高质量</code>的Android应用程序。</li>\n</ul>\n<h1 id=\"二、Jetpack-的诞生和发展\"><a href=\"#二、Jetpack-的诞生和发展\" class=\"headerlink\" title=\"二、Jetpack 的诞生和发展\"></a>二、Jetpack 的诞生和发展</h1><h2 id=\"2-1-诞生\"><a href=\"#2-1-诞生\" class=\"headerlink\" title=\"2.1 诞生\"></a>2.1 诞生</h2><ul>\n<li>Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的”引擎”或”助推器”的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。</li>\n<li>最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog-1.jpg\" width=\"30%\">\n\n<h2 id=\"2-2-发展\"><a href=\"#2-2-发展\" class=\"headerlink\" title=\"2.2 发展\"></a>2.2 发展</h2><ul>\n<li>当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。</li>\n<li>随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。</li>\n<li>2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。</li>\n<li>2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。</li>\n<li>总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。</li>\n</ul>\n<h1 id=\"三、Jetpack-的运用\"><a href=\"#三、Jetpack-的运用\" class=\"headerlink\" title=\"三、Jetpack 的运用\"></a>三、Jetpack 的运用</h1><ul>\n<li>说明：<ol>\n<li>由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。</li>\n<li>为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用<code>Kotlin</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-1-LiveCycle\"><a href=\"#3-1-LiveCycle\" class=\"headerlink\" title=\"3.1 LiveCycle\"></a>3.1 LiveCycle</h2><ul>\n<li>Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。</li>\n<li>作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。</li>\n<li>Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleOwner</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.OnLifecycleEvent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLifecycleObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onCreate 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStart 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onResume 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onPause 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStop 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onDestroy 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。</li>\n<li>下面演示如何使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> myObserver: MyLifecycleObserver</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建 MyLifecycleObserver 实例</span></span><br><span class=\"line\">        myObserver = MyLifecycleObserver()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将 myObserver 添加到 Activity 的生命周期观察者列表中</span></span><br><span class=\"line\">        lifecycle.addObserver(myObserver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">    <span class=\"comment\">//从观察者列表中移除</span></span><br><span class=\"line\">    lifecycle.removeObserver(myObserver)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。</li>\n</ul>\n<h2 id=\"3-2-LiveData-和-ViewModel\"><a href=\"#3-2-LiveData-和-ViewModel\" class=\"headerlink\" title=\"3.2 LiveData 和 ViewModel\"></a>3.2 LiveData 和 ViewModel</h2><ul>\n<li><p>由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。</p>\n</li>\n<li><p>LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。</p>\n</li>\n<li><p>ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</p>\n</li>\n<li><p>在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为<code>旋转手机、配置更改（如切换语言）、资源内存不足</code>等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。</p>\n</li>\n<li><p>下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。</p>\n</li>\n</ul>\n<ol>\n<li>先自定义一个继承自 ViewModel 的 DataBindingViewModel 类<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个 MyViewModel 类，继承自 ViewModel</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> number: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// addOne 方法，用于将 number 自增 1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOne</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0</span></span><br><span class=\"line\">    number.value = (number.value ?: <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 Activity 中使用<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ViewModelActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityViewModelBinding</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> viewModels()</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">// 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象</span></span><br><span class=\"line\">        binding = ActivityViewModelBinding.inflate(layoutInflater)</span><br><span class=\"line\">        <span class=\"comment\">// 设置界面布局为 binding.root</span></span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 观察 myViewModel 中的 number 属性的变化</span></span><br><span class=\"line\">        myViewModel.number.observe(<span class=\"keyword\">this</span>, Observer &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 number 的值显示在 textView 上</span></span><br><span class=\"line\">          binding.textView.text = myViewModel.number.value.toString()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 给 button 的点击事件添加监听器</span></span><br><span class=\"line\">        binding.button.setOnClickListener &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在 myViewModel 中执行 addOne 函数</span></span><br><span class=\"line\">          myViewModel.addOne()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。</li>\n<li>总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定…或许接触新知识的最大的乐趣就在于此吧。</li>\n<li>这两天使用 kotlin 进行编码，也让我对 Kotlin 语法’太甜了’的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。</li>\n</ul>\n"},{"title":"Navigation 组件使用示例","date":"2023-05-13T00:00:00.000Z","description":"Android Jetpack 组件之 Navigation","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oxuaj9.png","_content":"\n# 一、Navigation  \n\n## 1.1 概念\n\n- Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。\n- 使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。\n\n## 1.2 组成部分\n\n- 该组件包括以下几个基本部分：\n\n  1. 导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n  2. 目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。\n  3. 动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。\n  4. 导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。\n  5. 依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。\n\n# 二、Navigation 的使用\n\n## 2.1 添加依赖\n- 在 build.gradle(app) 中添加依赖（kotlin）：\n```groovy\ndependencies {\n  \n    implementation 'androidx.navigation:navigation-fragment-ktx:2.5.2'\n    implementation 'androidx.navigation:navigation-ui-ktx:2.5.2'\n\n}\n```\n\n## 2.2 创建两个 Fragment 示例\n- 直接 new -> Fragment -> Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。\n- 下面是 HomeFragment 的示例：\n```kotlin\nclass HomeFragment : Fragment() {\n\n    private lateinit var binding: FragmentHomeBinding\n  \n    override fun onCreateView(\n      inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View? {\n      // Inflate the layout for this fragment\n      binding = FragmentHomeBinding.inflate(inflater, container, false)\n      return binding.root\n    }\n  \n}\n```\n- 生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。\n- 布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。\n\n## 2.3 创建导航图(Navigation Graph)\n\n- 导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n- 创建： res -> new -> Android Resource File\n- 名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择`Navigation`。\n\n- 导入刚才创建的 Fragment。\n\n- `tips`: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。\n\n## 2.4 建立导航图与 NavHostFragment 的关联\n\n- 在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：\n- 在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)。\n\n## 2.5 使用 NavController 完成跳转\n\n- 在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。\n- onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。\n```kotlin\nclass HomeFragment : Fragment() {\n\n  //复写 onViewCreated() 方法\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //设置按钮监听\n        binding.todetail.setOnClickListener {\n              //通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。\n              val controller = Navigation.findNavController(it)\n              //调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。\n              controller.navigate(R.id.action_homeFragment_to_detailFragment)\n        }\n        \n    }\n}\n```\n- 重点是这两行代码：\n```kotlin\n    val controller = Navigation.findNavController(it)\n    controller.navigate(R.id.action_homeFragment_to_detailFragment)\n```\n- 首先是第一行，用以获取与当前 Fragment 关联的 NavController。\n- `NavController` 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。\n- 第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。\n- `R.id.action_homeFragment_to_detailFragment`是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。\n\n- 在 DetailFragment 中进行同样的操作即可，这里不再给出代码。\n\n## 2.6 将导航过程与应用程序的 ActionBar 集成起来。\n\n- 现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。\n\n- 在 Activity 中添加以下代码：\n```kotlin\nclass NavigationActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityNavigationBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNavigationBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n      \n        // 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。\n        // 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController\n        val navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()\n      \n        if (navController != null) {\n            //使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来\n            NavigationUI.setupActionBarWithNavController(this, navController)\n        }\n      \n    }\n    //重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。\n    override fun onSupportNavigateUp(): Boolean {\n        val controller = Navigation.findNavController(this, R.id.fragment)\n        return controller.navigateUp()\n    }\n}\n```\n\n- 到此，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！\n- 使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。\n\n# 三、总结\n\n- 在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。\n- 可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。\n- 当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！","source":"_posts/安卓_04_Navigation.md","raw":"---\ntitle: 'Navigation 组件使用示例'\ndate: '2023-05-13'\ndescription: 'Android Jetpack 组件之 Navigation'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oxuaj9.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n# 一、Navigation  \n\n## 1.1 概念\n\n- Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。\n- 使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。\n\n## 1.2 组成部分\n\n- 该组件包括以下几个基本部分：\n\n  1. 导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n  2. 目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。\n  3. 动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。\n  4. 导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。\n  5. 依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。\n\n# 二、Navigation 的使用\n\n## 2.1 添加依赖\n- 在 build.gradle(app) 中添加依赖（kotlin）：\n```groovy\ndependencies {\n  \n    implementation 'androidx.navigation:navigation-fragment-ktx:2.5.2'\n    implementation 'androidx.navigation:navigation-ui-ktx:2.5.2'\n\n}\n```\n\n## 2.2 创建两个 Fragment 示例\n- 直接 new -> Fragment -> Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。\n- 下面是 HomeFragment 的示例：\n```kotlin\nclass HomeFragment : Fragment() {\n\n    private lateinit var binding: FragmentHomeBinding\n  \n    override fun onCreateView(\n      inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View? {\n      // Inflate the layout for this fragment\n      binding = FragmentHomeBinding.inflate(inflater, container, false)\n      return binding.root\n    }\n  \n}\n```\n- 生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。\n- 布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。\n\n## 2.3 创建导航图(Navigation Graph)\n\n- 导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n- 创建： res -> new -> Android Resource File\n- 名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择`Navigation`。\n\n- 导入刚才创建的 Fragment。\n\n- `tips`: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。\n\n## 2.4 建立导航图与 NavHostFragment 的关联\n\n- 在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：\n- 在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)。\n\n## 2.5 使用 NavController 完成跳转\n\n- 在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。\n- onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。\n```kotlin\nclass HomeFragment : Fragment() {\n\n  //复写 onViewCreated() 方法\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //设置按钮监听\n        binding.todetail.setOnClickListener {\n              //通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。\n              val controller = Navigation.findNavController(it)\n              //调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。\n              controller.navigate(R.id.action_homeFragment_to_detailFragment)\n        }\n        \n    }\n}\n```\n- 重点是这两行代码：\n```kotlin\n    val controller = Navigation.findNavController(it)\n    controller.navigate(R.id.action_homeFragment_to_detailFragment)\n```\n- 首先是第一行，用以获取与当前 Fragment 关联的 NavController。\n- `NavController` 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。\n- 第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。\n- `R.id.action_homeFragment_to_detailFragment`是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。\n\n- 在 DetailFragment 中进行同样的操作即可，这里不再给出代码。\n\n## 2.6 将导航过程与应用程序的 ActionBar 集成起来。\n\n- 现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。\n\n- 在 Activity 中添加以下代码：\n```kotlin\nclass NavigationActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityNavigationBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNavigationBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n      \n        // 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。\n        // 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController\n        val navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()\n      \n        if (navController != null) {\n            //使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来\n            NavigationUI.setupActionBarWithNavController(this, navController)\n        }\n      \n    }\n    //重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。\n    override fun onSupportNavigateUp(): Boolean {\n        val controller = Navigation.findNavController(this, R.id.fragment)\n        return controller.navigateUp()\n    }\n}\n```\n\n- 到此，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！\n- 使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。\n\n# 三、总结\n\n- 在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。\n- 可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。\n- 当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！","slug":"安卓_04_Navigation","published":1,"updated":"2023-09-25T06:56:38.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5d000q27hobs2263m1","content":"<h1 id=\"一、Navigation\"><a href=\"#一、Navigation\" class=\"headerlink\" title=\"一、Navigation\"></a>一、Navigation</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。</li>\n<li>使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ul>\n<li><p>该组件包括以下几个基本部分：</p>\n<ol>\n<li>导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。</li>\n<li>动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。</li>\n<li>导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。</li>\n<li>依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、Navigation-的使用\"><a href=\"#二、Navigation-的使用\" class=\"headerlink\" title=\"二、Navigation 的使用\"></a>二、Navigation 的使用</h1><h2 id=\"2-1-添加依赖\"><a href=\"#2-1-添加依赖\" class=\"headerlink\" title=\"2.1 添加依赖\"></a>2.1 添加依赖</h2><ul>\n<li>在 build.gradle(app) 中添加依赖（kotlin）：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-fragment-ktx:2.5.2&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-ui-ktx:2.5.2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-2-创建两个-Fragment-示例\"><a href=\"#2-2-创建两个-Fragment-示例\" class=\"headerlink\" title=\"2.2 创建两个 Fragment 示例\"></a>2.2 创建两个 Fragment 示例</h2><ul>\n<li>直接 new -&gt; Fragment -&gt; Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。</li>\n<li>下面是 HomeFragment 的示例：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentHomeBinding</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View? &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Inflate the layout for this fragment</span></span><br><span class=\"line\">      binding = FragmentHomeBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。</li>\n<li>布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。</li>\n</ul>\n<h2 id=\"2-3-创建导航图-Navigation-Graph\"><a href=\"#2-3-创建导航图-Navigation-Graph\" class=\"headerlink\" title=\"2.3 创建导航图(Navigation Graph)\"></a>2.3 创建导航图(Navigation Graph)</h2><ul>\n<li><p>导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</p>\n</li>\n<li><p>创建： res -&gt; new -&gt; Android Resource File</p>\n</li>\n<li><p>名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择<code>Navigation</code>。</p>\n</li>\n<li><p>导入刚才创建的 Fragment。</p>\n</li>\n<li><p><code>tips</code>: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。</p>\n</li>\n</ul>\n<h2 id=\"2-4-建立导航图与-NavHostFragment-的关联\"><a href=\"#2-4-建立导航图与-NavHostFragment-的关联\" class=\"headerlink\" title=\"2.4 建立导航图与 NavHostFragment 的关联\"></a>2.4 建立导航图与 NavHostFragment 的关联</h2><ul>\n<li>在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：</li>\n<li>在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)。</li>\n</ul>\n<h2 id=\"2-5-使用-NavController-完成跳转\"><a href=\"#2-5-使用-NavController-完成跳转\" class=\"headerlink\" title=\"2.5 使用 NavController 完成跳转\"></a>2.5 使用 NavController 完成跳转</h2><ul>\n<li><p>在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。</p>\n</li>\n<li><p>onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//复写 onViewCreated() 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//设置按钮监听</span></span><br><span class=\"line\">        binding.todetail.setOnClickListener &#123;</span><br><span class=\"line\">              <span class=\"comment\">//通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。</span></span><br><span class=\"line\">              <span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">              <span class=\"comment\">//调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。</span></span><br><span class=\"line\">              controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>重点是这两行代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br></pre></td></tr></table></figure></li>\n<li><p>首先是第一行，用以获取与当前 Fragment 关联的 NavController。</p>\n</li>\n<li><p><code>NavController</code> 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。</p>\n</li>\n<li><p>第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。</p>\n</li>\n<li><p><code>R.id.action_homeFragment_to_detailFragment</code>是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。</p>\n</li>\n<li><p>在 DetailFragment 中进行同样的操作即可，这里不再给出代码。</p>\n</li>\n</ul>\n<h2 id=\"2-6-将导航过程与应用程序的-ActionBar-集成起来。\"><a href=\"#2-6-将导航过程与应用程序的-ActionBar-集成起来。\" class=\"headerlink\" title=\"2.6 将导航过程与应用程序的 ActionBar 集成起来。\"></a>2.6 将导航过程与应用程序的 ActionBar 集成起来。</h2><ul>\n<li><p>现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。</p>\n</li>\n<li><p>在 Activity 中添加以下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NavigationActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityNavigationBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        binding = ActivityNavigationBinding.inflate(layoutInflater)</span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。</span></span><br><span class=\"line\">        <span class=\"comment\">// 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (navController != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来</span></span><br><span class=\"line\">            NavigationUI.setupActionBarWithNavController(<span class=\"keyword\">this</span>, navController)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSupportNavigateUp</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> controller = Navigation.findNavController(<span class=\"keyword\">this</span>, R.id.fragment)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.navigateUp()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>到此，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！</p>\n</li>\n<li><p>使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。</p>\n</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。</li>\n<li>可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。</li>\n<li>当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、Navigation\"><a href=\"#一、Navigation\" class=\"headerlink\" title=\"一、Navigation\"></a>一、Navigation</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。</li>\n<li>使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ul>\n<li><p>该组件包括以下几个基本部分：</p>\n<ol>\n<li>导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。</li>\n<li>动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。</li>\n<li>导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。</li>\n<li>依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、Navigation-的使用\"><a href=\"#二、Navigation-的使用\" class=\"headerlink\" title=\"二、Navigation 的使用\"></a>二、Navigation 的使用</h1><h2 id=\"2-1-添加依赖\"><a href=\"#2-1-添加依赖\" class=\"headerlink\" title=\"2.1 添加依赖\"></a>2.1 添加依赖</h2><ul>\n<li>在 build.gradle(app) 中添加依赖（kotlin）：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-fragment-ktx:2.5.2&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-ui-ktx:2.5.2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-2-创建两个-Fragment-示例\"><a href=\"#2-2-创建两个-Fragment-示例\" class=\"headerlink\" title=\"2.2 创建两个 Fragment 示例\"></a>2.2 创建两个 Fragment 示例</h2><ul>\n<li>直接 new -&gt; Fragment -&gt; Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。</li>\n<li>下面是 HomeFragment 的示例：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentHomeBinding</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View? &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Inflate the layout for this fragment</span></span><br><span class=\"line\">      binding = FragmentHomeBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。</li>\n<li>布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。</li>\n</ul>\n<h2 id=\"2-3-创建导航图-Navigation-Graph\"><a href=\"#2-3-创建导航图-Navigation-Graph\" class=\"headerlink\" title=\"2.3 创建导航图(Navigation Graph)\"></a>2.3 创建导航图(Navigation Graph)</h2><ul>\n<li><p>导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</p>\n</li>\n<li><p>创建： res -&gt; new -&gt; Android Resource File</p>\n</li>\n<li><p>名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择<code>Navigation</code>。</p>\n</li>\n<li><p>导入刚才创建的 Fragment。</p>\n</li>\n<li><p><code>tips</code>: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。</p>\n</li>\n</ul>\n<h2 id=\"2-4-建立导航图与-NavHostFragment-的关联\"><a href=\"#2-4-建立导航图与-NavHostFragment-的关联\" class=\"headerlink\" title=\"2.4 建立导航图与 NavHostFragment 的关联\"></a>2.4 建立导航图与 NavHostFragment 的关联</h2><ul>\n<li>在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：</li>\n<li>在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)。</li>\n</ul>\n<h2 id=\"2-5-使用-NavController-完成跳转\"><a href=\"#2-5-使用-NavController-完成跳转\" class=\"headerlink\" title=\"2.5 使用 NavController 完成跳转\"></a>2.5 使用 NavController 完成跳转</h2><ul>\n<li><p>在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。</p>\n</li>\n<li><p>onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//复写 onViewCreated() 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//设置按钮监听</span></span><br><span class=\"line\">        binding.todetail.setOnClickListener &#123;</span><br><span class=\"line\">              <span class=\"comment\">//通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。</span></span><br><span class=\"line\">              <span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">              <span class=\"comment\">//调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。</span></span><br><span class=\"line\">              controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>重点是这两行代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br></pre></td></tr></table></figure></li>\n<li><p>首先是第一行，用以获取与当前 Fragment 关联的 NavController。</p>\n</li>\n<li><p><code>NavController</code> 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。</p>\n</li>\n<li><p>第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。</p>\n</li>\n<li><p><code>R.id.action_homeFragment_to_detailFragment</code>是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。</p>\n</li>\n<li><p>在 DetailFragment 中进行同样的操作即可，这里不再给出代码。</p>\n</li>\n</ul>\n<h2 id=\"2-6-将导航过程与应用程序的-ActionBar-集成起来。\"><a href=\"#2-6-将导航过程与应用程序的-ActionBar-集成起来。\" class=\"headerlink\" title=\"2.6 将导航过程与应用程序的 ActionBar 集成起来。\"></a>2.6 将导航过程与应用程序的 ActionBar 集成起来。</h2><ul>\n<li><p>现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。</p>\n</li>\n<li><p>在 Activity 中添加以下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NavigationActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityNavigationBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        binding = ActivityNavigationBinding.inflate(layoutInflater)</span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。</span></span><br><span class=\"line\">        <span class=\"comment\">// 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (navController != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来</span></span><br><span class=\"line\">            NavigationUI.setupActionBarWithNavController(<span class=\"keyword\">this</span>, navController)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSupportNavigateUp</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> controller = Navigation.findNavController(<span class=\"keyword\">this</span>, R.id.fragment)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.navigateUp()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>到此，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！</p>\n</li>\n<li><p>使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。</p>\n</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。</li>\n<li>可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。</li>\n<li>当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！</li>\n</ul>\n"},{"title":"Jetpack 组件联合使用示例","date":"2023-06-27T00:00:00.000Z","description":"总结目前学过的 Jetpack 组件，并使用他们写一个口算练习App","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog.jpg","_content":"\n# 一、概念汇总\n\n## 1.1 ViewModel\n\n- 官方定义：[官方文档](https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn)中并没有明确的定义。\n- 按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。\n- 简而言之，就是`帮我们管理数据，让数据变得清晰明白，知根知底。`\n\n## 1.2 Navigation\n\n- 官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。\n- 之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。\n- 简而言之，就是`让界面之间的跳转变得更统一、更清晰（可视化）。`\n\n## 1.3 DataBinding\n\n- 官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。\n- 通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。\n- 简而言之，就是`让你不需要写很多重复的代码来更新界面上的数据。`\n\n# 二、实际运用\n\n- 目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个`口算练习App`案例来实际运用一下他们。\n\n## 2.1 导入依赖\n\n- 我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的`app`级别的`build.gradle`文件中添加：\n\n```groovy\nandroid {\n    buildFeatures {\n        //开启DataBinding\n        dataBinding = true\n    }\n}\n\ndependencies {\n    // 添加 DataBinding 的依赖项\n    implementation 'androidx.databinding:databinding-runtime:7.3.1'\n}\n```\n\n## 2.2 创建页面\n\n### 2.2.1 文件\n\n- 创建一个 Activity 页面，作为我们的 Fragment 容器。\n- 创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。\n\n### 2.2.2 布局\n\n- 这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。\n- 首先是 TitleFragment（主界面）。\n- 然后是 QuestionFragment（答题界面），主要用于答题。\n- 最后是成功（超过最高分）和失败（未超过最高分）的界面。\n\n## 2.3 设置导航图(navGraph)\n\n### 2.3.1 新建导航图\n\n- 点击 res 资源路径，右键 -> new -> Android Resource File -> 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)\n\n### 2.3.2 编辑导航图\n\n- 将四个 Fragment 添加进来，并设置 TitleFragment 为`Start Destination`，然后将所有的跳转逻辑`action`添加进来，直接在视图中拉箭头指向就可以了。\n\n- 在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。\n\n## 2.4 ViewModel\n\n- 在项目目录下新建 MyViewModel 类，继承自`AndroidViewModel`，代码如下（有其他需求修改对应部分即可）：\n```kotlin\nclass MyViewModel(application: Application, savedStateHandle: SavedStateHandle) :\n    AndroidViewModel(application) {\n\n    private val handle: SavedStateHandle\n\n    private val spf: SharedPreferences\n    \n    var winFlag = false\n\n    companion object {\n        const val KEY_HIGH_SCORE = \"key_high_score\"\n        const val KEY_LEFT_NUMBER = \"key_left_number\"\n        const val KEY_RIGHT_NUMBER = \"key_right_number\"\n        const val KEY_OPERATOR = \"key_operator\"\n        const val KEY_ANSWER = \"key_answer\"\n        const val KEY_CURRENT_SCORE = \"key_current_score\"\n        const val SAVE_SHP_DATA_NAME = \"save_shp_data_name\"\n    }\n\n    init {\n        this.handle = savedStateHandle\n        spf = getApplication<Application>().getSharedPreferences(\n            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE\n        )\n        if (!handle.contains(KEY_HIGH_SCORE)) {\n            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, 0)\n            handle[KEY_LEFT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_RIGHT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_ANSWER] = 0\n            handle[KEY_CURRENT_SCORE] = 0\n        }\n    }\n\n    fun getLeftNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_LEFT_NUMBER)\n    }\n    \n    fun getRightNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_RIGHT_NUMBER)\n    }\n\n    fun getOperator(): MutableLiveData<String> {\n        return handle.getLiveData(KEY_OPERATOR)\n    }\n\n    fun getHighScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_HIGH_SCORE)\n    }\n\n    fun getCurrentScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_CURRENT_SCORE)\n    }\n\n    fun getAnswer(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_ANSWER)\n    }\n\n    //生成算式\n    fun generator() {\n        val level = 100\n        val random = Random()\n        val x = random.nextInt(level) + 1\n        val y = random.nextInt(level) + 1\n\n        if (x % 2 == 0) {\n            getOperator().value = \"+\"\n            if (x > y) {\n                getAnswer().value = x\n                getLeftNumber().value = y\n                getRightNumber().value = x - y\n            } else {\n                getAnswer().value = y\n                getLeftNumber().value = x\n                getRightNumber().value = y - x\n            }\n        } else {\n            getOperator().value = \"-\"\n            if (x > y) {\n                getAnswer().value = x - y\n                getLeftNumber().value = x\n                getRightNumber().value = y\n            } else {\n                getAnswer().value = y - x\n                getLeftNumber().value = y\n                getRightNumber().value = x\n            }\n        }\n\n\n    }\n\n    //保存新纪录\n    fun save() {\n        val edit = spf.edit()\n        getHighScore().value?.let { edit.putInt(KEY_HIGH_SCORE, it) }\n        edit.apply()\n    }\n\n\n    //答对处理\n    fun answerCorrect() {\n        val currentScore = getCurrentScore().value ?: 0\n        val highScore = getHighScore().value ?: 0\n        val updatedCurrentScore = currentScore + 1\n        //赋值最新得分结果\n        getCurrentScore().value = updatedCurrentScore\n        //如果超过最高分，就更新记录\n        if (updatedCurrentScore > highScore) {\n            getHighScore().value = updatedCurrentScore\n            winFlag = true\n        }\n        generator()\n    }\n}\n```\n- `注：`AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。\n\n## 2.5 DataBinding\n\n- 首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。\n\n```xml\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.leihao.kotlinapp.calculation.viewmodel.MyViewModel\" />\n    </data>\n```\n### 2.5.1 TitleFragment 页面\n\n- 只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/high_score(data.highScore)}\"\n/>\n```\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：\n```xml\n<string name=\"high_score\">历史最高分：%d</string>\n```\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。\n\n### 2.5.2 Question 页面\n\n- 当前得分的 TextView 添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/current_score(data.currentScore)}\"\n/>\n```\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.leftNumber)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{data.operator}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.rightNumber)}\"\n/>\n```\n\n### 2.5.3 WinFragment 和 LoseFragment 页面\n\n- 在分数对应的 TextView 中分别添加属性：\n```xml\n<TextView\n        android:text=\"@{@string/win_score_message(data.currentScore)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{@string/lose_score_message(data.currentScore)}\"\n/>\n```\n- 大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。\n\n## 2.6 功能完善\n\n- 接下来将各个页面的剩余功能完成。\n- TitleFragment：\n```kotlin\nclass TitleFragment : Fragment() {\n    private lateinit var binding: FragmentTitleBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentTitleBinding.inflate(inflater, container, false)\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //去答题界面\n        binding.btnBegin.setOnClickListener {\n            val navController = Navigation.findNavController(view)\n            navController.navigate(R.id.action_titleFragment_to_questionFragment)\n        }\n    }\n}\n```\n\n- QuestionFragment：\n```kotlin\nclass QuestionFragment : Fragment() {\n    private lateinit var binding: FragmentQuestionBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentQuestionBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        //生成题目\n        myViewModel.generator()\n\n        //当前分数置0\n        myViewModel.getCurrentScore().value = 0\n\n        //显示输入的内容或者提示信息\n        val builder = StringBuilder()\n\n        val listener = View.OnClickListener {\n            when (it.id) {\n                R.id.button0 -> builder.append(\"0\")\n                R.id.button1 -> builder.append(\"1\")\n                R.id.button2 -> builder.append(\"2\")\n                R.id.button3 -> builder.append(\"3\")\n                R.id.button4 -> builder.append(\"4\")\n                R.id.button5 -> builder.append(\"5\")\n                R.id.button6 -> builder.append(\"6\")\n                R.id.button7 -> builder.append(\"7\")\n                R.id.button8 -> builder.append(\"8\")\n                R.id.button9 -> builder.append(\"9\")\n                R.id.button_clear -> builder.setLength(0)\n            }\n\n            if (builder.isEmpty()) {\n                binding.textView10.text = getString(R.string.input_indicator)\n            } else {\n                binding.textView10.text = builder.toString()\n            }\n        }\n        //提交答案\n        binding.buttonSubmit.setOnClickListener {\n            if (builder.isNotEmpty()) {\n                //计算正确\n                if (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) {\n                    myViewModel.answerCorrect()\n                    builder.setLength(0)\n                    binding.textView10.text = getString(R.string.answer_correct)\n                } else {//计算错误\n                    val navController = Navigation.findNavController(it)\n                    if (myViewModel.winFlag) {\n                        navController.navigate(R.id.action_questionFragment_to_winFragment)\n                        myViewModel.winFlag = false\n                        myViewModel.save()\n                    } else {\n                        navController.navigate(R.id.action_questionFragment_to_loseFragment)\n                    }\n                }\n            }\n        }\n        binding.button0.setOnClickListener(listener)\n        binding.button1.setOnClickListener(listener)\n        binding.button2.setOnClickListener(listener)\n        binding.button3.setOnClickListener(listener)\n        binding.button4.setOnClickListener(listener)\n        binding.button5.setOnClickListener(listener)\n        binding.button6.setOnClickListener(listener)\n        binding.button7.setOnClickListener(listener)\n        binding.button8.setOnClickListener(listener)\n        binding.button9.setOnClickListener(listener)\n        binding.buttonClear.setOnClickListener(listener)\n    }\n}\n```\n\n- WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：\n```kotlin\nclass WinFragment : Fragment() {\n\n    private lateinit var binding: FragmentWinBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentWinBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.btnBack.setOnClickListener {\n            val navController = Navigation.findNavController(it)\n            navController.navigate(R.id.action_winFragment_to_titleFragment)\n        }\n    }\n}\n```\n\n# 三、总结\n\n- 通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。\n- 在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！\n","source":"_posts/安卓_05_Jetpack组件联合使用示例.md","raw":"---\ntitle: 'Jetpack 组件联合使用示例'\ndate: '2023-06-27'\ndescription: '总结目前学过的 Jetpack 组件，并使用他们写一个口算练习App'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oxIXog.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n# 一、概念汇总\n\n## 1.1 ViewModel\n\n- 官方定义：[官方文档](https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn)中并没有明确的定义。\n- 按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。\n- 简而言之，就是`帮我们管理数据，让数据变得清晰明白，知根知底。`\n\n## 1.2 Navigation\n\n- 官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。\n- 之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。\n- 简而言之，就是`让界面之间的跳转变得更统一、更清晰（可视化）。`\n\n## 1.3 DataBinding\n\n- 官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。\n- 通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。\n- 简而言之，就是`让你不需要写很多重复的代码来更新界面上的数据。`\n\n# 二、实际运用\n\n- 目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个`口算练习App`案例来实际运用一下他们。\n\n## 2.1 导入依赖\n\n- 我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的`app`级别的`build.gradle`文件中添加：\n\n```groovy\nandroid {\n    buildFeatures {\n        //开启DataBinding\n        dataBinding = true\n    }\n}\n\ndependencies {\n    // 添加 DataBinding 的依赖项\n    implementation 'androidx.databinding:databinding-runtime:7.3.1'\n}\n```\n\n## 2.2 创建页面\n\n### 2.2.1 文件\n\n- 创建一个 Activity 页面，作为我们的 Fragment 容器。\n- 创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。\n\n### 2.2.2 布局\n\n- 这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。\n- 首先是 TitleFragment（主界面）。\n- 然后是 QuestionFragment（答题界面），主要用于答题。\n- 最后是成功（超过最高分）和失败（未超过最高分）的界面。\n\n## 2.3 设置导航图(navGraph)\n\n### 2.3.1 新建导航图\n\n- 点击 res 资源路径，右键 -> new -> Android Resource File -> 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)\n\n### 2.3.2 编辑导航图\n\n- 将四个 Fragment 添加进来，并设置 TitleFragment 为`Start Destination`，然后将所有的跳转逻辑`action`添加进来，直接在视图中拉箭头指向就可以了。\n\n- 在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。\n\n## 2.4 ViewModel\n\n- 在项目目录下新建 MyViewModel 类，继承自`AndroidViewModel`，代码如下（有其他需求修改对应部分即可）：\n```kotlin\nclass MyViewModel(application: Application, savedStateHandle: SavedStateHandle) :\n    AndroidViewModel(application) {\n\n    private val handle: SavedStateHandle\n\n    private val spf: SharedPreferences\n    \n    var winFlag = false\n\n    companion object {\n        const val KEY_HIGH_SCORE = \"key_high_score\"\n        const val KEY_LEFT_NUMBER = \"key_left_number\"\n        const val KEY_RIGHT_NUMBER = \"key_right_number\"\n        const val KEY_OPERATOR = \"key_operator\"\n        const val KEY_ANSWER = \"key_answer\"\n        const val KEY_CURRENT_SCORE = \"key_current_score\"\n        const val SAVE_SHP_DATA_NAME = \"save_shp_data_name\"\n    }\n\n    init {\n        this.handle = savedStateHandle\n        spf = getApplication<Application>().getSharedPreferences(\n            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE\n        )\n        if (!handle.contains(KEY_HIGH_SCORE)) {\n            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, 0)\n            handle[KEY_LEFT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_RIGHT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_ANSWER] = 0\n            handle[KEY_CURRENT_SCORE] = 0\n        }\n    }\n\n    fun getLeftNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_LEFT_NUMBER)\n    }\n    \n    fun getRightNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_RIGHT_NUMBER)\n    }\n\n    fun getOperator(): MutableLiveData<String> {\n        return handle.getLiveData(KEY_OPERATOR)\n    }\n\n    fun getHighScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_HIGH_SCORE)\n    }\n\n    fun getCurrentScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_CURRENT_SCORE)\n    }\n\n    fun getAnswer(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_ANSWER)\n    }\n\n    //生成算式\n    fun generator() {\n        val level = 100\n        val random = Random()\n        val x = random.nextInt(level) + 1\n        val y = random.nextInt(level) + 1\n\n        if (x % 2 == 0) {\n            getOperator().value = \"+\"\n            if (x > y) {\n                getAnswer().value = x\n                getLeftNumber().value = y\n                getRightNumber().value = x - y\n            } else {\n                getAnswer().value = y\n                getLeftNumber().value = x\n                getRightNumber().value = y - x\n            }\n        } else {\n            getOperator().value = \"-\"\n            if (x > y) {\n                getAnswer().value = x - y\n                getLeftNumber().value = x\n                getRightNumber().value = y\n            } else {\n                getAnswer().value = y - x\n                getLeftNumber().value = y\n                getRightNumber().value = x\n            }\n        }\n\n\n    }\n\n    //保存新纪录\n    fun save() {\n        val edit = spf.edit()\n        getHighScore().value?.let { edit.putInt(KEY_HIGH_SCORE, it) }\n        edit.apply()\n    }\n\n\n    //答对处理\n    fun answerCorrect() {\n        val currentScore = getCurrentScore().value ?: 0\n        val highScore = getHighScore().value ?: 0\n        val updatedCurrentScore = currentScore + 1\n        //赋值最新得分结果\n        getCurrentScore().value = updatedCurrentScore\n        //如果超过最高分，就更新记录\n        if (updatedCurrentScore > highScore) {\n            getHighScore().value = updatedCurrentScore\n            winFlag = true\n        }\n        generator()\n    }\n}\n```\n- `注：`AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。\n\n## 2.5 DataBinding\n\n- 首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。\n\n```xml\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.leihao.kotlinapp.calculation.viewmodel.MyViewModel\" />\n    </data>\n```\n### 2.5.1 TitleFragment 页面\n\n- 只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/high_score(data.highScore)}\"\n/>\n```\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：\n```xml\n<string name=\"high_score\">历史最高分：%d</string>\n```\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。\n\n### 2.5.2 Question 页面\n\n- 当前得分的 TextView 添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/current_score(data.currentScore)}\"\n/>\n```\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.leftNumber)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{data.operator}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.rightNumber)}\"\n/>\n```\n\n### 2.5.3 WinFragment 和 LoseFragment 页面\n\n- 在分数对应的 TextView 中分别添加属性：\n```xml\n<TextView\n        android:text=\"@{@string/win_score_message(data.currentScore)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{@string/lose_score_message(data.currentScore)}\"\n/>\n```\n- 大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。\n\n## 2.6 功能完善\n\n- 接下来将各个页面的剩余功能完成。\n- TitleFragment：\n```kotlin\nclass TitleFragment : Fragment() {\n    private lateinit var binding: FragmentTitleBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentTitleBinding.inflate(inflater, container, false)\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //去答题界面\n        binding.btnBegin.setOnClickListener {\n            val navController = Navigation.findNavController(view)\n            navController.navigate(R.id.action_titleFragment_to_questionFragment)\n        }\n    }\n}\n```\n\n- QuestionFragment：\n```kotlin\nclass QuestionFragment : Fragment() {\n    private lateinit var binding: FragmentQuestionBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentQuestionBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        //生成题目\n        myViewModel.generator()\n\n        //当前分数置0\n        myViewModel.getCurrentScore().value = 0\n\n        //显示输入的内容或者提示信息\n        val builder = StringBuilder()\n\n        val listener = View.OnClickListener {\n            when (it.id) {\n                R.id.button0 -> builder.append(\"0\")\n                R.id.button1 -> builder.append(\"1\")\n                R.id.button2 -> builder.append(\"2\")\n                R.id.button3 -> builder.append(\"3\")\n                R.id.button4 -> builder.append(\"4\")\n                R.id.button5 -> builder.append(\"5\")\n                R.id.button6 -> builder.append(\"6\")\n                R.id.button7 -> builder.append(\"7\")\n                R.id.button8 -> builder.append(\"8\")\n                R.id.button9 -> builder.append(\"9\")\n                R.id.button_clear -> builder.setLength(0)\n            }\n\n            if (builder.isEmpty()) {\n                binding.textView10.text = getString(R.string.input_indicator)\n            } else {\n                binding.textView10.text = builder.toString()\n            }\n        }\n        //提交答案\n        binding.buttonSubmit.setOnClickListener {\n            if (builder.isNotEmpty()) {\n                //计算正确\n                if (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) {\n                    myViewModel.answerCorrect()\n                    builder.setLength(0)\n                    binding.textView10.text = getString(R.string.answer_correct)\n                } else {//计算错误\n                    val navController = Navigation.findNavController(it)\n                    if (myViewModel.winFlag) {\n                        navController.navigate(R.id.action_questionFragment_to_winFragment)\n                        myViewModel.winFlag = false\n                        myViewModel.save()\n                    } else {\n                        navController.navigate(R.id.action_questionFragment_to_loseFragment)\n                    }\n                }\n            }\n        }\n        binding.button0.setOnClickListener(listener)\n        binding.button1.setOnClickListener(listener)\n        binding.button2.setOnClickListener(listener)\n        binding.button3.setOnClickListener(listener)\n        binding.button4.setOnClickListener(listener)\n        binding.button5.setOnClickListener(listener)\n        binding.button6.setOnClickListener(listener)\n        binding.button7.setOnClickListener(listener)\n        binding.button8.setOnClickListener(listener)\n        binding.button9.setOnClickListener(listener)\n        binding.buttonClear.setOnClickListener(listener)\n    }\n}\n```\n\n- WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：\n```kotlin\nclass WinFragment : Fragment() {\n\n    private lateinit var binding: FragmentWinBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentWinBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.btnBack.setOnClickListener {\n            val navController = Navigation.findNavController(it)\n            navController.navigate(R.id.action_winFragment_to_titleFragment)\n        }\n    }\n}\n```\n\n# 三、总结\n\n- 通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。\n- 在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！\n","slug":"安卓_05_Jetpack组件联合使用示例","published":1,"updated":"2023-09-25T06:53:44.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5e000u27hohawn5gko","content":"<h1 id=\"一、概念汇总\"><a href=\"#一、概念汇总\" class=\"headerlink\" title=\"一、概念汇总\"></a>一、概念汇总</h1><h2 id=\"1-1-ViewModel\"><a href=\"#1-1-ViewModel\" class=\"headerlink\" title=\"1.1 ViewModel\"></a>1.1 ViewModel</h2><ul>\n<li>官方定义：<a href=\"https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn\">官方文档</a>中并没有明确的定义。</li>\n<li>按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。</li>\n<li>简而言之，就是<code>帮我们管理数据，让数据变得清晰明白，知根知底。</code></li>\n</ul>\n<h2 id=\"1-2-Navigation\"><a href=\"#1-2-Navigation\" class=\"headerlink\" title=\"1.2 Navigation\"></a>1.2 Navigation</h2><ul>\n<li>官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。</li>\n<li>之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。</li>\n<li>简而言之，就是<code>让界面之间的跳转变得更统一、更清晰（可视化）。</code></li>\n</ul>\n<h2 id=\"1-3-DataBinding\"><a href=\"#1-3-DataBinding\" class=\"headerlink\" title=\"1.3 DataBinding\"></a>1.3 DataBinding</h2><ul>\n<li>官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。</li>\n<li>通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。</li>\n<li>简而言之，就是<code>让你不需要写很多重复的代码来更新界面上的数据。</code></li>\n</ul>\n<h1 id=\"二、实际运用\"><a href=\"#二、实际运用\" class=\"headerlink\" title=\"二、实际运用\"></a>二、实际运用</h1><ul>\n<li>目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个<code>口算练习App</code>案例来实际运用一下他们。</li>\n</ul>\n<h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的<code>app</code>级别的<code>build.gradle</code>文件中添加：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开启DataBinding</span></span><br><span class=\"line\">        dataBinding = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 DataBinding 的依赖项</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.databinding:databinding-runtime:7.3.1&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-创建页面\"><a href=\"#2-2-创建页面\" class=\"headerlink\" title=\"2.2 创建页面\"></a>2.2 创建页面</h2><h3 id=\"2-2-1-文件\"><a href=\"#2-2-1-文件\" class=\"headerlink\" title=\"2.2.1 文件\"></a>2.2.1 文件</h3><ul>\n<li>创建一个 Activity 页面，作为我们的 Fragment 容器。</li>\n<li>创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。</li>\n</ul>\n<h3 id=\"2-2-2-布局\"><a href=\"#2-2-2-布局\" class=\"headerlink\" title=\"2.2.2 布局\"></a>2.2.2 布局</h3><ul>\n<li>这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。</li>\n<li>首先是 TitleFragment（主界面）。</li>\n<li>然后是 QuestionFragment（答题界面），主要用于答题。</li>\n<li>最后是成功（超过最高分）和失败（未超过最高分）的界面。</li>\n</ul>\n<h2 id=\"2-3-设置导航图-navGraph\"><a href=\"#2-3-设置导航图-navGraph\" class=\"headerlink\" title=\"2.3 设置导航图(navGraph)\"></a>2.3 设置导航图(navGraph)</h2><h3 id=\"2-3-1-新建导航图\"><a href=\"#2-3-1-新建导航图\" class=\"headerlink\" title=\"2.3.1 新建导航图\"></a>2.3.1 新建导航图</h3><ul>\n<li>点击 res 资源路径，右键 -&gt; new -&gt; Android Resource File -&gt; 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)</li>\n</ul>\n<h3 id=\"2-3-2-编辑导航图\"><a href=\"#2-3-2-编辑导航图\" class=\"headerlink\" title=\"2.3.2 编辑导航图\"></a>2.3.2 编辑导航图</h3><ul>\n<li><p>将四个 Fragment 添加进来，并设置 TitleFragment 为<code>Start Destination</code>，然后将所有的跳转逻辑<code>action</code>添加进来，直接在视图中拉箭头指向就可以了。</p>\n</li>\n<li><p>在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。</p>\n</li>\n</ul>\n<h2 id=\"2-4-ViewModel\"><a href=\"#2-4-ViewModel\" class=\"headerlink\" title=\"2.4 ViewModel\"></a>2.4 ViewModel</h2><ul>\n<li>在项目目录下新建 MyViewModel 类，继承自<code>AndroidViewModel</code>，代码如下（有其他需求修改对应部分即可）：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span>(application: Application, savedStateHandle: SavedStateHandle) :</span><br><span class=\"line\">    AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handle: SavedStateHandle</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> spf: SharedPreferences</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_HIGH_SCORE = <span class=\"string\">&quot;key_high_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_LEFT_NUMBER = <span class=\"string\">&quot;key_left_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_RIGHT_NUMBER = <span class=\"string\">&quot;key_right_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_OPERATOR = <span class=\"string\">&quot;key_operator&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_ANSWER = <span class=\"string\">&quot;key_answer&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_CURRENT_SCORE = <span class=\"string\">&quot;key_current_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> SAVE_SHP_DATA_NAME = <span class=\"string\">&quot;save_shp_data_name&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = savedStateHandle</span><br><span class=\"line\">        spf = getApplication&lt;Application&gt;().getSharedPreferences(</span><br><span class=\"line\">            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!handle.contains(KEY_HIGH_SCORE)) &#123;</span><br><span class=\"line\">            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, <span class=\"number\">0</span>)</span><br><span class=\"line\">            handle[KEY_LEFT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_RIGHT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_ANSWER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_CURRENT_SCORE] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getLeftNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_LEFT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRightNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_RIGHT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getOperator</span><span class=\"params\">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_OPERATOR)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getHighScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_HIGH_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCurrentScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_CURRENT_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAnswer</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_ANSWER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成算式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generator</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> level = <span class=\"number\">100</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> random = Random()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> x = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> y = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x - y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y - x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x - y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y - x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保存新纪录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">save</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> edit = spf.edit()</span><br><span class=\"line\">        getHighScore().value?.let &#123; edit.putInt(KEY_HIGH_SCORE, it) &#125;</span><br><span class=\"line\">        edit.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//答对处理</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">answerCorrect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentScore = getCurrentScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> highScore = getHighScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> updatedCurrentScore = currentScore + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值最新得分结果</span></span><br><span class=\"line\">        getCurrentScore().value = updatedCurrentScore</span><br><span class=\"line\">        <span class=\"comment\">//如果超过最高分，就更新记录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (updatedCurrentScore &gt; highScore) &#123;</span><br><span class=\"line\">            getHighScore().value = updatedCurrentScore</span><br><span class=\"line\">            winFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generator()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>注：</code>AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。</li>\n</ul>\n<h2 id=\"2-5-DataBinding\"><a href=\"#2-5-DataBinding\" class=\"headerlink\" title=\"2.5 DataBinding\"></a>2.5 DataBinding</h2><ul>\n<li>首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">&quot;data&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.leihao.kotlinapp.calculation.viewmodel.MyViewModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-1-TitleFragment-页面\"><a href=\"#2-5-1-TitleFragment-页面\" class=\"headerlink\" title=\"2.5.1 TitleFragment 页面\"></a>2.5.1 TitleFragment 页面</h3><ul>\n<li>只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/high_score(data.highScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;high_score&quot;</span>&gt;</span>历史最高分：%d<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br></pre></td></tr></table></figure>\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。</li>\n</ul>\n<h3 id=\"2-5-2-Question-页面\"><a href=\"#2-5-2-Question-页面\" class=\"headerlink\" title=\"2.5.2 Question 页面\"></a>2.5.2 Question 页面</h3><ul>\n<li>当前得分的 TextView 添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/current_score(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.leftNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;data.operator&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.rightNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-5-3-WinFragment-和-LoseFragment-页面\"><a href=\"#2-5-3-WinFragment-和-LoseFragment-页面\" class=\"headerlink\" title=\"2.5.3 WinFragment 和 LoseFragment 页面\"></a>2.5.3 WinFragment 和 LoseFragment 页面</h3><ul>\n<li>在分数对应的 TextView 中分别添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/win_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/lose_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。</li>\n</ul>\n<h2 id=\"2-6-功能完善\"><a href=\"#2-6-功能完善\" class=\"headerlink\" title=\"2.6 功能完善\"></a>2.6 功能完善</h2><ul>\n<li><p>接下来将各个页面的剩余功能完成。</p>\n</li>\n<li><p>TitleFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TitleFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentTitleBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentTitleBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//去答题界面</span></span><br><span class=\"line\">        binding.btnBegin.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(view)</span><br><span class=\"line\">            navController.navigate(R.id.action_titleFragment_to_questionFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>QuestionFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QuestionFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentQuestionBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentQuestionBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成题目</span></span><br><span class=\"line\">        myViewModel.generator()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前分数置0</span></span><br><span class=\"line\">        myViewModel.getCurrentScore().value = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//显示输入的内容或者提示信息</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> builder = StringBuilder()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> listener = View.OnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (it.id) &#123;</span><br><span class=\"line\">                R.id.button0 -&gt; builder.append(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">                R.id.button1 -&gt; builder.append(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">                R.id.button2 -&gt; builder.append(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">                R.id.button3 -&gt; builder.append(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">                R.id.button4 -&gt; builder.append(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">                R.id.button5 -&gt; builder.append(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">                R.id.button6 -&gt; builder.append(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">                R.id.button7 -&gt; builder.append(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">                R.id.button8 -&gt; builder.append(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">                R.id.button9 -&gt; builder.append(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">                R.id.button_clear -&gt; builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isEmpty()) &#123;</span><br><span class=\"line\">                binding.textView10.text = getString(R.string.input_indicator)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                binding.textView10.text = builder.toString()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//提交答案</span></span><br><span class=\"line\">        binding.buttonSubmit.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isNotEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算正确</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) &#123;</span><br><span class=\"line\">                    myViewModel.answerCorrect()</span><br><span class=\"line\">                    builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">                    binding.textView10.text = getString(R.string.answer_correct)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//计算错误</span></span><br><span class=\"line\">                    <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (myViewModel.winFlag) &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_winFragment)</span><br><span class=\"line\">                        myViewModel.winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">                        myViewModel.save()</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_loseFragment)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        binding.button0.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button1.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button2.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button3.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button4.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button5.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button6.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button7.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button8.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button9.setOnClickListener(listener)</span><br><span class=\"line\">        binding.buttonClear.setOnClickListener(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WinFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentWinBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentWinBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.btnBack.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">            navController.navigate(R.id.action_winFragment_to_titleFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。</li>\n<li>在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、概念汇总\"><a href=\"#一、概念汇总\" class=\"headerlink\" title=\"一、概念汇总\"></a>一、概念汇总</h1><h2 id=\"1-1-ViewModel\"><a href=\"#1-1-ViewModel\" class=\"headerlink\" title=\"1.1 ViewModel\"></a>1.1 ViewModel</h2><ul>\n<li>官方定义：<a href=\"https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn\">官方文档</a>中并没有明确的定义。</li>\n<li>按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。</li>\n<li>简而言之，就是<code>帮我们管理数据，让数据变得清晰明白，知根知底。</code></li>\n</ul>\n<h2 id=\"1-2-Navigation\"><a href=\"#1-2-Navigation\" class=\"headerlink\" title=\"1.2 Navigation\"></a>1.2 Navigation</h2><ul>\n<li>官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。</li>\n<li>之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。</li>\n<li>简而言之，就是<code>让界面之间的跳转变得更统一、更清晰（可视化）。</code></li>\n</ul>\n<h2 id=\"1-3-DataBinding\"><a href=\"#1-3-DataBinding\" class=\"headerlink\" title=\"1.3 DataBinding\"></a>1.3 DataBinding</h2><ul>\n<li>官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。</li>\n<li>通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。</li>\n<li>简而言之，就是<code>让你不需要写很多重复的代码来更新界面上的数据。</code></li>\n</ul>\n<h1 id=\"二、实际运用\"><a href=\"#二、实际运用\" class=\"headerlink\" title=\"二、实际运用\"></a>二、实际运用</h1><ul>\n<li>目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个<code>口算练习App</code>案例来实际运用一下他们。</li>\n</ul>\n<h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的<code>app</code>级别的<code>build.gradle</code>文件中添加：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开启DataBinding</span></span><br><span class=\"line\">        dataBinding = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 DataBinding 的依赖项</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.databinding:databinding-runtime:7.3.1&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-创建页面\"><a href=\"#2-2-创建页面\" class=\"headerlink\" title=\"2.2 创建页面\"></a>2.2 创建页面</h2><h3 id=\"2-2-1-文件\"><a href=\"#2-2-1-文件\" class=\"headerlink\" title=\"2.2.1 文件\"></a>2.2.1 文件</h3><ul>\n<li>创建一个 Activity 页面，作为我们的 Fragment 容器。</li>\n<li>创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。</li>\n</ul>\n<h3 id=\"2-2-2-布局\"><a href=\"#2-2-2-布局\" class=\"headerlink\" title=\"2.2.2 布局\"></a>2.2.2 布局</h3><ul>\n<li>这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。</li>\n<li>首先是 TitleFragment（主界面）。</li>\n<li>然后是 QuestionFragment（答题界面），主要用于答题。</li>\n<li>最后是成功（超过最高分）和失败（未超过最高分）的界面。</li>\n</ul>\n<h2 id=\"2-3-设置导航图-navGraph\"><a href=\"#2-3-设置导航图-navGraph\" class=\"headerlink\" title=\"2.3 设置导航图(navGraph)\"></a>2.3 设置导航图(navGraph)</h2><h3 id=\"2-3-1-新建导航图\"><a href=\"#2-3-1-新建导航图\" class=\"headerlink\" title=\"2.3.1 新建导航图\"></a>2.3.1 新建导航图</h3><ul>\n<li>点击 res 资源路径，右键 -&gt; new -&gt; Android Resource File -&gt; 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)</li>\n</ul>\n<h3 id=\"2-3-2-编辑导航图\"><a href=\"#2-3-2-编辑导航图\" class=\"headerlink\" title=\"2.3.2 编辑导航图\"></a>2.3.2 编辑导航图</h3><ul>\n<li><p>将四个 Fragment 添加进来，并设置 TitleFragment 为<code>Start Destination</code>，然后将所有的跳转逻辑<code>action</code>添加进来，直接在视图中拉箭头指向就可以了。</p>\n</li>\n<li><p>在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。</p>\n</li>\n</ul>\n<h2 id=\"2-4-ViewModel\"><a href=\"#2-4-ViewModel\" class=\"headerlink\" title=\"2.4 ViewModel\"></a>2.4 ViewModel</h2><ul>\n<li>在项目目录下新建 MyViewModel 类，继承自<code>AndroidViewModel</code>，代码如下（有其他需求修改对应部分即可）：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span>(application: Application, savedStateHandle: SavedStateHandle) :</span><br><span class=\"line\">    AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handle: SavedStateHandle</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> spf: SharedPreferences</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_HIGH_SCORE = <span class=\"string\">&quot;key_high_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_LEFT_NUMBER = <span class=\"string\">&quot;key_left_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_RIGHT_NUMBER = <span class=\"string\">&quot;key_right_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_OPERATOR = <span class=\"string\">&quot;key_operator&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_ANSWER = <span class=\"string\">&quot;key_answer&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_CURRENT_SCORE = <span class=\"string\">&quot;key_current_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> SAVE_SHP_DATA_NAME = <span class=\"string\">&quot;save_shp_data_name&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = savedStateHandle</span><br><span class=\"line\">        spf = getApplication&lt;Application&gt;().getSharedPreferences(</span><br><span class=\"line\">            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!handle.contains(KEY_HIGH_SCORE)) &#123;</span><br><span class=\"line\">            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, <span class=\"number\">0</span>)</span><br><span class=\"line\">            handle[KEY_LEFT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_RIGHT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_ANSWER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_CURRENT_SCORE] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getLeftNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_LEFT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRightNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_RIGHT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getOperator</span><span class=\"params\">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_OPERATOR)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getHighScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_HIGH_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCurrentScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_CURRENT_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAnswer</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_ANSWER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成算式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generator</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> level = <span class=\"number\">100</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> random = Random()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> x = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> y = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x - y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y - x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x - y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y - x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保存新纪录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">save</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> edit = spf.edit()</span><br><span class=\"line\">        getHighScore().value?.let &#123; edit.putInt(KEY_HIGH_SCORE, it) &#125;</span><br><span class=\"line\">        edit.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//答对处理</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">answerCorrect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentScore = getCurrentScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> highScore = getHighScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> updatedCurrentScore = currentScore + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值最新得分结果</span></span><br><span class=\"line\">        getCurrentScore().value = updatedCurrentScore</span><br><span class=\"line\">        <span class=\"comment\">//如果超过最高分，就更新记录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (updatedCurrentScore &gt; highScore) &#123;</span><br><span class=\"line\">            getHighScore().value = updatedCurrentScore</span><br><span class=\"line\">            winFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generator()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>注：</code>AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。</li>\n</ul>\n<h2 id=\"2-5-DataBinding\"><a href=\"#2-5-DataBinding\" class=\"headerlink\" title=\"2.5 DataBinding\"></a>2.5 DataBinding</h2><ul>\n<li>首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">&quot;data&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.leihao.kotlinapp.calculation.viewmodel.MyViewModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-1-TitleFragment-页面\"><a href=\"#2-5-1-TitleFragment-页面\" class=\"headerlink\" title=\"2.5.1 TitleFragment 页面\"></a>2.5.1 TitleFragment 页面</h3><ul>\n<li>只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/high_score(data.highScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;high_score&quot;</span>&gt;</span>历史最高分：%d<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br></pre></td></tr></table></figure>\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。</li>\n</ul>\n<h3 id=\"2-5-2-Question-页面\"><a href=\"#2-5-2-Question-页面\" class=\"headerlink\" title=\"2.5.2 Question 页面\"></a>2.5.2 Question 页面</h3><ul>\n<li>当前得分的 TextView 添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/current_score(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.leftNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;data.operator&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.rightNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-5-3-WinFragment-和-LoseFragment-页面\"><a href=\"#2-5-3-WinFragment-和-LoseFragment-页面\" class=\"headerlink\" title=\"2.5.3 WinFragment 和 LoseFragment 页面\"></a>2.5.3 WinFragment 和 LoseFragment 页面</h3><ul>\n<li>在分数对应的 TextView 中分别添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/win_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/lose_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。</li>\n</ul>\n<h2 id=\"2-6-功能完善\"><a href=\"#2-6-功能完善\" class=\"headerlink\" title=\"2.6 功能完善\"></a>2.6 功能完善</h2><ul>\n<li><p>接下来将各个页面的剩余功能完成。</p>\n</li>\n<li><p>TitleFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TitleFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentTitleBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentTitleBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//去答题界面</span></span><br><span class=\"line\">        binding.btnBegin.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(view)</span><br><span class=\"line\">            navController.navigate(R.id.action_titleFragment_to_questionFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>QuestionFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QuestionFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentQuestionBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentQuestionBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成题目</span></span><br><span class=\"line\">        myViewModel.generator()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前分数置0</span></span><br><span class=\"line\">        myViewModel.getCurrentScore().value = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//显示输入的内容或者提示信息</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> builder = StringBuilder()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> listener = View.OnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (it.id) &#123;</span><br><span class=\"line\">                R.id.button0 -&gt; builder.append(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">                R.id.button1 -&gt; builder.append(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">                R.id.button2 -&gt; builder.append(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">                R.id.button3 -&gt; builder.append(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">                R.id.button4 -&gt; builder.append(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">                R.id.button5 -&gt; builder.append(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">                R.id.button6 -&gt; builder.append(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">                R.id.button7 -&gt; builder.append(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">                R.id.button8 -&gt; builder.append(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">                R.id.button9 -&gt; builder.append(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">                R.id.button_clear -&gt; builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isEmpty()) &#123;</span><br><span class=\"line\">                binding.textView10.text = getString(R.string.input_indicator)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                binding.textView10.text = builder.toString()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//提交答案</span></span><br><span class=\"line\">        binding.buttonSubmit.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isNotEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算正确</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) &#123;</span><br><span class=\"line\">                    myViewModel.answerCorrect()</span><br><span class=\"line\">                    builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">                    binding.textView10.text = getString(R.string.answer_correct)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//计算错误</span></span><br><span class=\"line\">                    <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (myViewModel.winFlag) &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_winFragment)</span><br><span class=\"line\">                        myViewModel.winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">                        myViewModel.save()</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_loseFragment)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        binding.button0.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button1.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button2.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button3.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button4.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button5.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button6.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button7.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button8.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button9.setOnClickListener(listener)</span><br><span class=\"line\">        binding.buttonClear.setOnClickListener(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WinFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentWinBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentWinBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.btnBack.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">            navController.navigate(R.id.action_winFragment_to_titleFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。</li>\n<li>在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！</li>\n</ul>\n"},{"title":"Room 组件使用示例","date":"2023-07-22T00:00:00.000Z","description":"Room 是 Android 中的一个持久性库，用于简化数据库的访问和管理。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oAQU7o.png","_content":"\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- 为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。\n- 今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。\n- 简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","source":"_posts/安卓_06_Room.md","raw":"---\ntitle: 'Room 组件使用示例'\ndate: '2023-07-22'\ndescription: 'Room 是 Android 中的一个持久性库，用于简化数据库的访问和管理。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oAQU7o.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n- 数据库\n\n---\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- 为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。\n- 今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。\n- 简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","slug":"安卓_06_Room","published":1,"updated":"2023-09-25T06:48:27.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5g000x27hohvw2bya9","content":"<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。</li>\n<li>今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。</li>\n<li>简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。</li>\n<li>今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。</li>\n<li>简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n"},{"title":"ViewPager 与 ViewPager2 的使用示例","date":"2023-08-15T00:00:00.000Z","description":"介绍如何使用 ViewPager + BottomNavigationView 实现底部导航，ViewPager2 + TabLayout 实现顶部导航。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oSFPMc.png","_content":"\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- ViewPager 和 ViewPager2 看名字就知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用。\n\n## 1.2 用途\n\n- `以可滑动的格式显示视图或 Fragment。`文档这一句话已经将用途说得很清楚了，说白了就是让界面可以左右滑动，承担视图或者 Fragment 的切换工作。当然，Fragment 也算是一种视图控件，只不过有自己独立的生命周期而已。\n- 使用 ViewPager 或 ViewPager2，可以将不同的 Fragment 或 View 作为页面，并轻松地进行页面切换和管理。这对于构建需要在多个页面之间切换的应用程序非常有用，例如图片浏览器、新闻阅读器、引导页等。\n\n# 二、基本使用\n\n## 2.1 ViewPager + BottomNavigationView\n\n- ViewPager 不论是一代还是二代，一般都是配合其它控件进行使用的，比如这里举一个 ViewPager + BottomNavigationView 的例子。\n- BottomNavigationView 简单介绍一下，它是一个底部导航视图，通常由多个图标和标签组成，用于在应用程序的底部提供导航菜单栏。\n- 可以看出，我们要实现的就是点击 BottomNavigationView 的某个 item 时，切换到指定的 Fragment，并且 ViewPager 进行同步的切换。或者，滑动 ViewPager 时，切换到指定的 Fragment，并且 BottomNavigationView 切换到对应的 item。总结一下就是 `BottomNavigationView + ViewPager + Fragment 的三者联动`。\n\n### 2.1.1 创建 menu\n\n- 由于 BottomNavigationView 需要配合一个 menu 进行使用，所以我们先新建一个 menu 作为底部导航栏的可选项 item。\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:id=\"@+id/todoFragment\"\n        android:icon=\"@drawable/record_24\"\n        android:title=\"@string/record\" />\n    <item\n        android:id=\"@+id/accountFragment\"\n        android:icon=\"@drawable/shopping_24\"\n        android:title=\"@string/account\" />\n    <item\n        android:id=\"@+id/mineFragment\"\n        android:icon=\"@drawable/account_24\"\n        android:title=\"@string/mine\" />\n</menu>\n```\n\n- 每个 item 的 id 用于唯一标识底部导航栏中的各个选项，通过这些唯一的 id 来区分不同的选项，并在代码中进行相应的处理。\n\n### 2.1.2 创建主界面\n\n- 创建一个包含 ViewPager 和 BottomNavigationView 的页面，一般将 BottomNavigationView 放在下方，其余部分用 ViewPager 填充。不过你当然也可以将 BottomNavigationView 放在你想放的任意位置，只要它拥有自己的 id 就行。\n- 将上一步创建好的 menu 放入 BottomNavigationView 中，用`app:menu=\"@menu/your_menu\"`的方式，下面是示例：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".activity.HomeActivity\">\n\n    <androidx.viewpager.widget.ViewPager\n        android:id=\"@+id/viewPager_fragments\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toTopOf=\"@+id/bottomNavigationView\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <com.google.android.material.bottomnavigation.BottomNavigationView\n        android:id=\"@+id/bottomNavigationView\"\n        style=\"@style/Widget.Design.BottomNavigationView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@color/white\"\n        app:itemBackground=\"@color/white\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:menu=\"@menu/mint_menu\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n- 这个时候在 Design 界面上就已经可以看到一些预览效果了，但是现在点击和滑动是没有任何关联的，并且 ViewPager 里面现在还没有内容呢。\n\n### 2.1.3 配置 ViewPager 适配器\n\n- 创建一个继承自 FragmentStatePagerAdapter 的适配器类，在稍微高一点的 SDK 版本中，可以看到 IDE 提示该类已弃用，毕竟有更好的替代了嘛。我们先不管这个提示，暂时现在还是可用的，只是未来某个 SDK 更新可能就移除掉了。\n\n```kotlin\nclass HomeActivityAdapter(fm: FragmentManager, private val fragmentList: MutableList<Fragment>) :\n    FragmentStatePagerAdapter(fm) {\n\n    override fun getCount(): Int {\n        return fragmentList.size\n    }\n\n    override fun getItem(position: Int): Fragment {\n        return fragmentList[position]\n    }\n\n}\n```\n\n- 在创建时我们可以看到，它提示我们必须实现一个带 FragmentManager 为参数的构造器，原因是 FragmentStatePagerAdapter 内部需要使用 FragmentManager 来创建和管理 Fragment。\n- 接下来，在 Activity 中将适配器设置给 ViewPager：\n\n```kotlin\n        // -- 省略 -- \n        fragmentList = ArrayList()\n\n        val todoFragment = TodoFragment()\n        val accountFragment = AccountFragment()\n        val mineFragment = MineFragment()\n\n        fragmentList.add(todoFragment)\n        fragmentList.add(accountFragment)\n        fragmentList.add(mineFragment)\n        //实例化适配器\n        homeActivityAdapter = HomeActivityAdapter(supportFragmentManager, fragmentList)\n        //将适配器绑定给 ViewPager\n        binding.viewPagerFragments.adapter = homeActivityAdapter\n        // -- 省略 -- \n```\n\n### 2.1.4 实现联动\n\n- 滑动viewpager时，联动底部按钮：\n\n```kotlin\n            binding.viewPagerFragments.setOnPageChangeListener(object : OnPageChangeListener {\n            override fun onPageScrolled(\n                position: Int, positionOffset: Float, positionOffsetPixels: Int\n            ) {\n\n            }\n\n            override fun onPageSelected(position: Int) {\n                //设置顶部的 actionBar 标题变化为 bottomNavigationView 的 menu 对应 item 的\"android:title\"字段的值\n                supportActionBar?.title = binding.bottomNavigationView.menu.getItem(position).title\n                //判断 ViewPager 滑动的位置，并且根据位置更新 bottomNavigationView 的选中条目 id\n                when (position) {\n                    0 -> binding.bottomNavigationView.selectedItemId = R.id.todoFragment\n                    1 -> binding.bottomNavigationView.selectedItemId = R.id.accountFragment\n                    2 -> binding.bottomNavigationView.selectedItemId = R.id.mineFragment\n                }\n\n            }\n\n            override fun onPageScrollStateChanged(state: Int) {\n\n            }\n\n        })\n```\n\n- 点击底部按钮时，联动viewpager进行滑动：\n\n```kotlin\n            binding.bottomNavigationView.setOnNavigationItemSelectedListener { item ->\n            //在 Item 更新时，同步更新 ViewPager 的当前 item 项\n            when (item.itemId) {\n                R.id.todoFragment -> {\n                    binding.viewPagerFragments.currentItem = 0\n                }\n\n                R.id.accountFragment -> {\n                    binding.viewPagerFragments.currentItem = 1\n                }\n\n                R.id.mineFragment -> {\n                    binding.viewPagerFragments.currentItem = 2\n                }\n            }\n            true\n        }\n```\n\n- 到此为止，就实现了一个简单的底部导航 + 滑动视图切换的功能。不过上面用到的大多数方法或类都已经弃用，包括`setOnPageChangeListener`和`setOnNavigationItemSelectedListener`和前面提到的`FragmentStatePagerAdapter`。这样一看全是弃用的 API，如果是用在比较大的项目中显然是不合适的。\n\n## 2.2 ViewPager2 + TabLayout\n\n- 接下来介绍一下 ViewPager2 的使用，相比于一代，性能更优秀，使用更方便，当然也不会有那么多被弃用的 API 了。与其联动的控件不再选择 BottomNavigationView 而选择 TabLayout，当然喽，选择 BottomNavigationView 也是完全 ok 的，这里只是多举一些其他的情况。\n- TabLayout 也简单介绍一下，看名字和前面的 BottomNavigationView 像是两个相反作用的控件，实际也确实如此，TabLayout 是 Material Design 中的一个标签栏控件，用于显示多个选项卡，并与 ViewPager2 进行联动。功能和 BottomNavigationView 几乎一致，不过一般用于顶部的选项卡切换。\n- TabLayout 和 BottomNavigationView 在我看来其实是差不多的，他们所处的位置完全可以自己决定，样式也可以通过配置变得完全一样，但是还是尽量按照约定来行使各自的功能，毕竟我们的代码不仅要自己能看懂，也要尽量让别人看得舒服。\n\n### 2.2.1 创建页面\n\n- 直接构建一个包含 TabLayout 和 ViewPager2 的页面：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/fragment_account\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".fragment.account.AccountFragment\">\n\n    <com.google.android.material.tabs.TabLayout\n        android:id=\"@+id/TabLayout\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\">\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Monday\" />\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Tuesday\" />\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Wednesday\" />\n\n    </com.google.android.material.tabs.TabLayout>\n\n    <androidx.viewpager2.widget.ViewPager2\n        android:id=\"@+id/ViewPager2\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/TabLayout\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n- 我这里可以直接使用这两个控件，如果不能使用的话，去 Build.Gradle 文件中导入对应的依赖即可。\n\n### 2.2.2 实现联动\n\n- 没错，我们不需要再单独创建适配器了，可以直接使用 FragmentStateAdapter 创建一个匿名类实现适配器功能：\n\n```kotlin\n        // -- 省略 --\n        fragmentsList = ArrayList()\n\n        fragmentsList.add(PayFragment())\n        fragmentsList.add(IncomeFragment())\n        fragmentsList.add(ChartFragment())\n\n        binding.ViewPager2.adapter = object : FragmentStateAdapter(requireActivity()) {\n            //里面有几个页面\n            override fun getItemCount() = fragmentsList.size\n\n            //每一个位置对应哪个 Fragment\n            override fun createFragment(position: Int) = when (position) {\n                0 -> PayFragment()\n                1 -> IncomeFragment()\n                else -> ChartFragment()\n            }\n\n        }\n\n        //协调 viewpager2 与 TabLayout 的辅助类\n        TabLayoutMediator(\n            binding.TabLayout, binding.ViewPager2\n        ) { tab, position ->\n            when (position) {\n                0 -> tab.text = resources.getString(R.string.pay)\n                1 -> tab.text = resources.getString(R.string.income)\n                else -> tab.text = resources.getString(R.string.chart)\n            }\n        }.attach()\n\n        // -- 省略 --\n```\n\n- 上面代码就实现了 TabLayout + ViewPager2 的联动效果，具体来说：\n  1. 定义了一个继承自 FragmentStateAdapter 的匿名适配器类。在适配器中，重写了 getItemCount 方法，返回 fragmentsList 的大小，即页面的数量。然后，重写了 createFragment 方法，根据位置返回相应的 Fragment 实例。\n  2. 使用 TabLayoutMediator 类来协调 TabLayout 和 ViewPager2 之间的联动。通过传入 TabLayout 和 ViewPager2 的实例，以及一个 lambda 表达式，关联了 TabLayout 中的选项卡和 ViewPager2 中的页面。lambda 表达式中的 tab 参数表示当前选项卡，position 参数表示当前选项卡的位置，在 lambda 表达式中根据位置设置选项卡显示的文本。\n  3. 最后，调用 attach() 方法将 TabLayout 和 ViewPager2 进行关联。\n- 代码量来说确实少一些，不过差异主要集中在 TabLayout 和 BottomNavigationView 的实现上，实际上两个 ViewPager 的实现代码的代码量差别并不大，但是还是更推荐使用较新的 ViewPager2 来进行 Fragment 的管理。\n\n# 三、总结\n\n- 当开发 Android 应用程序时，我们经常需要在不同的页面之间进行切换。为了满足这种需求，我们可以使用 ViewPager 或 ViewPager2 作为页面容器控件，并结合 BottomNavigationView 或 TabLayout 实现页面切换的联动效果。\n- ViewPager 和 ViewPager2 都是用于实现页面切换的容器控件。ViewPager 适用于简单场景，而 ViewPager2 提供了更多的功能和更好的性能。BottomNavigationView 和 TabLayout 则分别为两者提供了与之联动的导航栏控件。无论选择哪种组合方式，都可以实现简洁、高效的页面切换效果，为用户提供良好的交互体验。","source":"_posts/安卓_07_ViewPager和ViewPager2的使用.md","raw":"---\ntitle: 'ViewPager 与 ViewPager2 的使用示例'\ndate: '2023-08-15'\ndescription: '介绍如何使用 ViewPager + BottomNavigationView 实现底部导航，ViewPager2 + TabLayout 实现顶部导航。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oSFPMc.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Jetpack\n- Android\n\n---\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- ViewPager 和 ViewPager2 看名字就知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用。\n\n## 1.2 用途\n\n- `以可滑动的格式显示视图或 Fragment。`文档这一句话已经将用途说得很清楚了，说白了就是让界面可以左右滑动，承担视图或者 Fragment 的切换工作。当然，Fragment 也算是一种视图控件，只不过有自己独立的生命周期而已。\n- 使用 ViewPager 或 ViewPager2，可以将不同的 Fragment 或 View 作为页面，并轻松地进行页面切换和管理。这对于构建需要在多个页面之间切换的应用程序非常有用，例如图片浏览器、新闻阅读器、引导页等。\n\n# 二、基本使用\n\n## 2.1 ViewPager + BottomNavigationView\n\n- ViewPager 不论是一代还是二代，一般都是配合其它控件进行使用的，比如这里举一个 ViewPager + BottomNavigationView 的例子。\n- BottomNavigationView 简单介绍一下，它是一个底部导航视图，通常由多个图标和标签组成，用于在应用程序的底部提供导航菜单栏。\n- 可以看出，我们要实现的就是点击 BottomNavigationView 的某个 item 时，切换到指定的 Fragment，并且 ViewPager 进行同步的切换。或者，滑动 ViewPager 时，切换到指定的 Fragment，并且 BottomNavigationView 切换到对应的 item。总结一下就是 `BottomNavigationView + ViewPager + Fragment 的三者联动`。\n\n### 2.1.1 创建 menu\n\n- 由于 BottomNavigationView 需要配合一个 menu 进行使用，所以我们先新建一个 menu 作为底部导航栏的可选项 item。\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:id=\"@+id/todoFragment\"\n        android:icon=\"@drawable/record_24\"\n        android:title=\"@string/record\" />\n    <item\n        android:id=\"@+id/accountFragment\"\n        android:icon=\"@drawable/shopping_24\"\n        android:title=\"@string/account\" />\n    <item\n        android:id=\"@+id/mineFragment\"\n        android:icon=\"@drawable/account_24\"\n        android:title=\"@string/mine\" />\n</menu>\n```\n\n- 每个 item 的 id 用于唯一标识底部导航栏中的各个选项，通过这些唯一的 id 来区分不同的选项，并在代码中进行相应的处理。\n\n### 2.1.2 创建主界面\n\n- 创建一个包含 ViewPager 和 BottomNavigationView 的页面，一般将 BottomNavigationView 放在下方，其余部分用 ViewPager 填充。不过你当然也可以将 BottomNavigationView 放在你想放的任意位置，只要它拥有自己的 id 就行。\n- 将上一步创建好的 menu 放入 BottomNavigationView 中，用`app:menu=\"@menu/your_menu\"`的方式，下面是示例：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".activity.HomeActivity\">\n\n    <androidx.viewpager.widget.ViewPager\n        android:id=\"@+id/viewPager_fragments\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toTopOf=\"@+id/bottomNavigationView\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <com.google.android.material.bottomnavigation.BottomNavigationView\n        android:id=\"@+id/bottomNavigationView\"\n        style=\"@style/Widget.Design.BottomNavigationView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@color/white\"\n        app:itemBackground=\"@color/white\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:menu=\"@menu/mint_menu\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n- 这个时候在 Design 界面上就已经可以看到一些预览效果了，但是现在点击和滑动是没有任何关联的，并且 ViewPager 里面现在还没有内容呢。\n\n### 2.1.3 配置 ViewPager 适配器\n\n- 创建一个继承自 FragmentStatePagerAdapter 的适配器类，在稍微高一点的 SDK 版本中，可以看到 IDE 提示该类已弃用，毕竟有更好的替代了嘛。我们先不管这个提示，暂时现在还是可用的，只是未来某个 SDK 更新可能就移除掉了。\n\n```kotlin\nclass HomeActivityAdapter(fm: FragmentManager, private val fragmentList: MutableList<Fragment>) :\n    FragmentStatePagerAdapter(fm) {\n\n    override fun getCount(): Int {\n        return fragmentList.size\n    }\n\n    override fun getItem(position: Int): Fragment {\n        return fragmentList[position]\n    }\n\n}\n```\n\n- 在创建时我们可以看到，它提示我们必须实现一个带 FragmentManager 为参数的构造器，原因是 FragmentStatePagerAdapter 内部需要使用 FragmentManager 来创建和管理 Fragment。\n- 接下来，在 Activity 中将适配器设置给 ViewPager：\n\n```kotlin\n        // -- 省略 -- \n        fragmentList = ArrayList()\n\n        val todoFragment = TodoFragment()\n        val accountFragment = AccountFragment()\n        val mineFragment = MineFragment()\n\n        fragmentList.add(todoFragment)\n        fragmentList.add(accountFragment)\n        fragmentList.add(mineFragment)\n        //实例化适配器\n        homeActivityAdapter = HomeActivityAdapter(supportFragmentManager, fragmentList)\n        //将适配器绑定给 ViewPager\n        binding.viewPagerFragments.adapter = homeActivityAdapter\n        // -- 省略 -- \n```\n\n### 2.1.4 实现联动\n\n- 滑动viewpager时，联动底部按钮：\n\n```kotlin\n            binding.viewPagerFragments.setOnPageChangeListener(object : OnPageChangeListener {\n            override fun onPageScrolled(\n                position: Int, positionOffset: Float, positionOffsetPixels: Int\n            ) {\n\n            }\n\n            override fun onPageSelected(position: Int) {\n                //设置顶部的 actionBar 标题变化为 bottomNavigationView 的 menu 对应 item 的\"android:title\"字段的值\n                supportActionBar?.title = binding.bottomNavigationView.menu.getItem(position).title\n                //判断 ViewPager 滑动的位置，并且根据位置更新 bottomNavigationView 的选中条目 id\n                when (position) {\n                    0 -> binding.bottomNavigationView.selectedItemId = R.id.todoFragment\n                    1 -> binding.bottomNavigationView.selectedItemId = R.id.accountFragment\n                    2 -> binding.bottomNavigationView.selectedItemId = R.id.mineFragment\n                }\n\n            }\n\n            override fun onPageScrollStateChanged(state: Int) {\n\n            }\n\n        })\n```\n\n- 点击底部按钮时，联动viewpager进行滑动：\n\n```kotlin\n            binding.bottomNavigationView.setOnNavigationItemSelectedListener { item ->\n            //在 Item 更新时，同步更新 ViewPager 的当前 item 项\n            when (item.itemId) {\n                R.id.todoFragment -> {\n                    binding.viewPagerFragments.currentItem = 0\n                }\n\n                R.id.accountFragment -> {\n                    binding.viewPagerFragments.currentItem = 1\n                }\n\n                R.id.mineFragment -> {\n                    binding.viewPagerFragments.currentItem = 2\n                }\n            }\n            true\n        }\n```\n\n- 到此为止，就实现了一个简单的底部导航 + 滑动视图切换的功能。不过上面用到的大多数方法或类都已经弃用，包括`setOnPageChangeListener`和`setOnNavigationItemSelectedListener`和前面提到的`FragmentStatePagerAdapter`。这样一看全是弃用的 API，如果是用在比较大的项目中显然是不合适的。\n\n## 2.2 ViewPager2 + TabLayout\n\n- 接下来介绍一下 ViewPager2 的使用，相比于一代，性能更优秀，使用更方便，当然也不会有那么多被弃用的 API 了。与其联动的控件不再选择 BottomNavigationView 而选择 TabLayout，当然喽，选择 BottomNavigationView 也是完全 ok 的，这里只是多举一些其他的情况。\n- TabLayout 也简单介绍一下，看名字和前面的 BottomNavigationView 像是两个相反作用的控件，实际也确实如此，TabLayout 是 Material Design 中的一个标签栏控件，用于显示多个选项卡，并与 ViewPager2 进行联动。功能和 BottomNavigationView 几乎一致，不过一般用于顶部的选项卡切换。\n- TabLayout 和 BottomNavigationView 在我看来其实是差不多的，他们所处的位置完全可以自己决定，样式也可以通过配置变得完全一样，但是还是尽量按照约定来行使各自的功能，毕竟我们的代码不仅要自己能看懂，也要尽量让别人看得舒服。\n\n### 2.2.1 创建页面\n\n- 直接构建一个包含 TabLayout 和 ViewPager2 的页面：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/fragment_account\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".fragment.account.AccountFragment\">\n\n    <com.google.android.material.tabs.TabLayout\n        android:id=\"@+id/TabLayout\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\">\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Monday\" />\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Tuesday\" />\n\n        <com.google.android.material.tabs.TabItem\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            tools:text=\"Wednesday\" />\n\n    </com.google.android.material.tabs.TabLayout>\n\n    <androidx.viewpager2.widget.ViewPager2\n        android:id=\"@+id/ViewPager2\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/TabLayout\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n- 我这里可以直接使用这两个控件，如果不能使用的话，去 Build.Gradle 文件中导入对应的依赖即可。\n\n### 2.2.2 实现联动\n\n- 没错，我们不需要再单独创建适配器了，可以直接使用 FragmentStateAdapter 创建一个匿名类实现适配器功能：\n\n```kotlin\n        // -- 省略 --\n        fragmentsList = ArrayList()\n\n        fragmentsList.add(PayFragment())\n        fragmentsList.add(IncomeFragment())\n        fragmentsList.add(ChartFragment())\n\n        binding.ViewPager2.adapter = object : FragmentStateAdapter(requireActivity()) {\n            //里面有几个页面\n            override fun getItemCount() = fragmentsList.size\n\n            //每一个位置对应哪个 Fragment\n            override fun createFragment(position: Int) = when (position) {\n                0 -> PayFragment()\n                1 -> IncomeFragment()\n                else -> ChartFragment()\n            }\n\n        }\n\n        //协调 viewpager2 与 TabLayout 的辅助类\n        TabLayoutMediator(\n            binding.TabLayout, binding.ViewPager2\n        ) { tab, position ->\n            when (position) {\n                0 -> tab.text = resources.getString(R.string.pay)\n                1 -> tab.text = resources.getString(R.string.income)\n                else -> tab.text = resources.getString(R.string.chart)\n            }\n        }.attach()\n\n        // -- 省略 --\n```\n\n- 上面代码就实现了 TabLayout + ViewPager2 的联动效果，具体来说：\n  1. 定义了一个继承自 FragmentStateAdapter 的匿名适配器类。在适配器中，重写了 getItemCount 方法，返回 fragmentsList 的大小，即页面的数量。然后，重写了 createFragment 方法，根据位置返回相应的 Fragment 实例。\n  2. 使用 TabLayoutMediator 类来协调 TabLayout 和 ViewPager2 之间的联动。通过传入 TabLayout 和 ViewPager2 的实例，以及一个 lambda 表达式，关联了 TabLayout 中的选项卡和 ViewPager2 中的页面。lambda 表达式中的 tab 参数表示当前选项卡，position 参数表示当前选项卡的位置，在 lambda 表达式中根据位置设置选项卡显示的文本。\n  3. 最后，调用 attach() 方法将 TabLayout 和 ViewPager2 进行关联。\n- 代码量来说确实少一些，不过差异主要集中在 TabLayout 和 BottomNavigationView 的实现上，实际上两个 ViewPager 的实现代码的代码量差别并不大，但是还是更推荐使用较新的 ViewPager2 来进行 Fragment 的管理。\n\n# 三、总结\n\n- 当开发 Android 应用程序时，我们经常需要在不同的页面之间进行切换。为了满足这种需求，我们可以使用 ViewPager 或 ViewPager2 作为页面容器控件，并结合 BottomNavigationView 或 TabLayout 实现页面切换的联动效果。\n- ViewPager 和 ViewPager2 都是用于实现页面切换的容器控件。ViewPager 适用于简单场景，而 ViewPager2 提供了更多的功能和更好的性能。BottomNavigationView 和 TabLayout 则分别为两者提供了与之联动的导航栏控件。无论选择哪种组合方式，都可以实现简洁、高效的页面切换效果，为用户提供良好的交互体验。","slug":"安卓_07_ViewPager和ViewPager2的使用","published":1,"updated":"2023-09-25T06:41:35.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5h001227ho9fivc3bt","content":"<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>ViewPager 和 ViewPager2 看名字就知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用。</li>\n</ul>\n<h2 id=\"1-2-用途\"><a href=\"#1-2-用途\" class=\"headerlink\" title=\"1.2 用途\"></a>1.2 用途</h2><ul>\n<li><code>以可滑动的格式显示视图或 Fragment。</code>文档这一句话已经将用途说得很清楚了，说白了就是让界面可以左右滑动，承担视图或者 Fragment 的切换工作。当然，Fragment 也算是一种视图控件，只不过有自己独立的生命周期而已。</li>\n<li>使用 ViewPager 或 ViewPager2，可以将不同的 Fragment 或 View 作为页面，并轻松地进行页面切换和管理。这对于构建需要在多个页面之间切换的应用程序非常有用，例如图片浏览器、新闻阅读器、引导页等。</li>\n</ul>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-ViewPager-BottomNavigationView\"><a href=\"#2-1-ViewPager-BottomNavigationView\" class=\"headerlink\" title=\"2.1 ViewPager + BottomNavigationView\"></a>2.1 ViewPager + BottomNavigationView</h2><ul>\n<li>ViewPager 不论是一代还是二代，一般都是配合其它控件进行使用的，比如这里举一个 ViewPager + BottomNavigationView 的例子。</li>\n<li>BottomNavigationView 简单介绍一下，它是一个底部导航视图，通常由多个图标和标签组成，用于在应用程序的底部提供导航菜单栏。</li>\n<li>可以看出，我们要实现的就是点击 BottomNavigationView 的某个 item 时，切换到指定的 Fragment，并且 ViewPager 进行同步的切换。或者，滑动 ViewPager 时，切换到指定的 Fragment，并且 BottomNavigationView 切换到对应的 item。总结一下就是 <code>BottomNavigationView + ViewPager + Fragment 的三者联动</code>。</li>\n</ul>\n<h3 id=\"2-1-1-创建-menu\"><a href=\"#2-1-1-创建-menu\" class=\"headerlink\" title=\"2.1.1 创建 menu\"></a>2.1.1 创建 menu</h3><ul>\n<li>由于 BottomNavigationView 需要配合一个 menu 进行使用，所以我们先新建一个 menu 作为底部导航栏的可选项 item。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">menu</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/todoFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/record_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/record&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/accountFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/shopping_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/account&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/mineFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/account_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/mine&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 item 的 id 用于唯一标识底部导航栏中的各个选项，通过这些唯一的 id 来区分不同的选项，并在代码中进行相应的处理。</li>\n</ul>\n<h3 id=\"2-1-2-创建主界面\"><a href=\"#2-1-2-创建主界面\" class=\"headerlink\" title=\"2.1.2 创建主界面\"></a>2.1.2 创建主界面</h3><ul>\n<li>创建一个包含 ViewPager 和 BottomNavigationView 的页面，一般将 BottomNavigationView 放在下方，其余部分用 ViewPager 填充。不过你当然也可以将 BottomNavigationView 放在你想放的任意位置，只要它拥有自己的 id 就行。</li>\n<li>将上一步创建好的 menu 放入 BottomNavigationView 中，用<code>app:menu=&quot;@menu/your_menu&quot;</code>的方式，下面是示例：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.activity.HomeActivity&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager.widget.ViewPager</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/viewPager_fragments&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toTopOf</span>=<span class=\"string\">&quot;@+id/bottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.bottomnavigation.BottomNavigationView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/bottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">style</span>=<span class=\"string\">&quot;@style/Widget.Design.BottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/white&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:itemBackground</span>=<span class=\"string\">&quot;@color/white&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:menu</span>=<span class=\"string\">&quot;@menu/mint_menu&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候在 Design 界面上就已经可以看到一些预览效果了，但是现在点击和滑动是没有任何关联的，并且 ViewPager 里面现在还没有内容呢。</li>\n</ul>\n<h3 id=\"2-1-3-配置-ViewPager-适配器\"><a href=\"#2-1-3-配置-ViewPager-适配器\" class=\"headerlink\" title=\"2.1.3 配置 ViewPager 适配器\"></a>2.1.3 配置 ViewPager 适配器</h3><ul>\n<li>创建一个继承自 FragmentStatePagerAdapter 的适配器类，在稍微高一点的 SDK 版本中，可以看到 IDE 提示该类已弃用，毕竟有更好的替代了嘛。我们先不管这个提示，暂时现在还是可用的，只是未来某个 SDK 更新可能就移除掉了。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeActivityAdapter</span>(fm: FragmentManager, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> fragmentList: MutableList&lt;Fragment&gt;) :</span><br><span class=\"line\">    FragmentStatePagerAdapter(fm) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentList.size</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getItem</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span>: Fragment &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentList[position]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在创建时我们可以看到，它提示我们必须实现一个带 FragmentManager 为参数的构造器，原因是 FragmentStatePagerAdapter 内部需要使用 FragmentManager 来创建和管理 Fragment。</li>\n<li>接下来，在 Activity 中将适配器设置给 ViewPager：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 省略 -- </span></span><br><span class=\"line\">fragmentList = ArrayList()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> todoFragment = TodoFragment()</span><br><span class=\"line\"><span class=\"keyword\">val</span> accountFragment = AccountFragment()</span><br><span class=\"line\"><span class=\"keyword\">val</span> mineFragment = MineFragment()</span><br><span class=\"line\"></span><br><span class=\"line\">fragmentList.add(todoFragment)</span><br><span class=\"line\">fragmentList.add(accountFragment)</span><br><span class=\"line\">fragmentList.add(mineFragment)</span><br><span class=\"line\"><span class=\"comment\">//实例化适配器</span></span><br><span class=\"line\">homeActivityAdapter = HomeActivityAdapter(supportFragmentManager, fragmentList)</span><br><span class=\"line\"><span class=\"comment\">//将适配器绑定给 ViewPager</span></span><br><span class=\"line\">binding.viewPagerFragments.adapter = homeActivityAdapter</span><br><span class=\"line\"><span class=\"comment\">// -- 省略 -- </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-4-实现联动\"><a href=\"#2-1-4-实现联动\" class=\"headerlink\" title=\"2.1.4 实现联动\"></a>2.1.4 实现联动</h3><ul>\n<li>滑动viewpager时，联动底部按钮：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    binding.viewPagerFragments.setOnPageChangeListener(<span class=\"keyword\">object</span> : OnPageChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageScrolled</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        position: <span class=\"type\">Int</span>, positionOffset: <span class=\"type\">Float</span>, positionOffsetPixels: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置顶部的 actionBar 标题变化为 bottomNavigationView 的 menu 对应 item 的&quot;android:title&quot;字段的值</span></span><br><span class=\"line\">        supportActionBar?.title = binding.bottomNavigationView.menu.getItem(position).title</span><br><span class=\"line\">        <span class=\"comment\">//判断 ViewPager 滑动的位置，并且根据位置更新 bottomNavigationView 的选中条目 id</span></span><br><span class=\"line\">        <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.todoFragment</span><br><span class=\"line\">            <span class=\"number\">1</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.accountFragment</span><br><span class=\"line\">            <span class=\"number\">2</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.mineFragment</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageScrollStateChanged</span><span class=\"params\">(state: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>点击底部按钮时，联动viewpager进行滑动：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    binding.bottomNavigationView.setOnNavigationItemSelectedListener &#123; item -&gt;</span><br><span class=\"line\">    <span class=\"comment\">//在 Item 更新时，同步更新 ViewPager 的当前 item 项</span></span><br><span class=\"line\">    <span class=\"keyword\">when</span> (item.itemId) &#123;</span><br><span class=\"line\">        R.id.todoFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        R.id.accountFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        R.id.mineFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到此为止，就实现了一个简单的底部导航 + 滑动视图切换的功能。不过上面用到的大多数方法或类都已经弃用，包括<code>setOnPageChangeListener</code>和<code>setOnNavigationItemSelectedListener</code>和前面提到的<code>FragmentStatePagerAdapter</code>。这样一看全是弃用的 API，如果是用在比较大的项目中显然是不合适的。</li>\n</ul>\n<h2 id=\"2-2-ViewPager2-TabLayout\"><a href=\"#2-2-ViewPager2-TabLayout\" class=\"headerlink\" title=\"2.2 ViewPager2 + TabLayout\"></a>2.2 ViewPager2 + TabLayout</h2><ul>\n<li>接下来介绍一下 ViewPager2 的使用，相比于一代，性能更优秀，使用更方便，当然也不会有那么多被弃用的 API 了。与其联动的控件不再选择 BottomNavigationView 而选择 TabLayout，当然喽，选择 BottomNavigationView 也是完全 ok 的，这里只是多举一些其他的情况。</li>\n<li>TabLayout 也简单介绍一下，看名字和前面的 BottomNavigationView 像是两个相反作用的控件，实际也确实如此，TabLayout 是 Material Design 中的一个标签栏控件，用于显示多个选项卡，并与 ViewPager2 进行联动。功能和 BottomNavigationView 几乎一致，不过一般用于顶部的选项卡切换。</li>\n<li>TabLayout 和 BottomNavigationView 在我看来其实是差不多的，他们所处的位置完全可以自己决定，样式也可以通过配置变得完全一样，但是还是尽量按照约定来行使各自的功能，毕竟我们的代码不仅要自己能看懂，也要尽量让别人看得舒服。</li>\n</ul>\n<h3 id=\"2-2-1-创建页面\"><a href=\"#2-2-1-创建页面\" class=\"headerlink\" title=\"2.2.1 创建页面\"></a>2.2.1 创建页面</h3><ul>\n<li>直接构建一个包含 TabLayout 和 ViewPager2 的页面：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/fragment_account&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.fragment.account.AccountFragment&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/TabLayout&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Monday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Tuesday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Wednesday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">com.google.android.material.tabs.TabLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager2.widget.ViewPager2</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/ViewPager2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toBottomOf</span>=<span class=\"string\">&quot;@+id/TabLayout&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我这里可以直接使用这两个控件，如果不能使用的话，去 Build.Gradle 文件中导入对应的依赖即可。</li>\n</ul>\n<h3 id=\"2-2-2-实现联动\"><a href=\"#2-2-2-实现联动\" class=\"headerlink\" title=\"2.2.2 实现联动\"></a>2.2.2 实现联动</h3><ul>\n<li>没错，我们不需要再单独创建适配器了，可以直接使用 FragmentStateAdapter 创建一个匿名类实现适配器功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 省略 --</span></span><br><span class=\"line\">fragmentsList = ArrayList()</span><br><span class=\"line\"></span><br><span class=\"line\">fragmentsList.add(PayFragment())</span><br><span class=\"line\">fragmentsList.add(IncomeFragment())</span><br><span class=\"line\">fragmentsList.add(ChartFragment())</span><br><span class=\"line\"></span><br><span class=\"line\">binding.ViewPager2.adapter = <span class=\"keyword\">object</span> : FragmentStateAdapter(requireActivity()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//里面有几个页面</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span></span> = fragmentsList.size</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//每一个位置对应哪个 Fragment</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createFragment</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> = <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> -&gt; PayFragment()</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; IncomeFragment()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; ChartFragment()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//协调 viewpager2 与 TabLayout 的辅助类</span></span><br><span class=\"line\">TabLayoutMediator(</span><br><span class=\"line\">    binding.TabLayout, binding.ViewPager2</span><br><span class=\"line\">) &#123; tab, position -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> -&gt; tab.text = resources.getString(R.string.pay)</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; tab.text = resources.getString(R.string.income)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; tab.text = resources.getString(R.string.chart)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.attach()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 省略 --</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面代码就实现了 TabLayout + ViewPager2 的联动效果，具体来说：<ol>\n<li>定义了一个继承自 FragmentStateAdapter 的匿名适配器类。在适配器中，重写了 getItemCount 方法，返回 fragmentsList 的大小，即页面的数量。然后，重写了 createFragment 方法，根据位置返回相应的 Fragment 实例。</li>\n<li>使用 TabLayoutMediator 类来协调 TabLayout 和 ViewPager2 之间的联动。通过传入 TabLayout 和 ViewPager2 的实例，以及一个 lambda 表达式，关联了 TabLayout 中的选项卡和 ViewPager2 中的页面。lambda 表达式中的 tab 参数表示当前选项卡，position 参数表示当前选项卡的位置，在 lambda 表达式中根据位置设置选项卡显示的文本。</li>\n<li>最后，调用 attach() 方法将 TabLayout 和 ViewPager2 进行关联。</li>\n</ol>\n</li>\n<li>代码量来说确实少一些，不过差异主要集中在 TabLayout 和 BottomNavigationView 的实现上，实际上两个 ViewPager 的实现代码的代码量差别并不大，但是还是更推荐使用较新的 ViewPager2 来进行 Fragment 的管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>当开发 Android 应用程序时，我们经常需要在不同的页面之间进行切换。为了满足这种需求，我们可以使用 ViewPager 或 ViewPager2 作为页面容器控件，并结合 BottomNavigationView 或 TabLayout 实现页面切换的联动效果。</li>\n<li>ViewPager 和 ViewPager2 都是用于实现页面切换的容器控件。ViewPager 适用于简单场景，而 ViewPager2 提供了更多的功能和更好的性能。BottomNavigationView 和 TabLayout 则分别为两者提供了与之联动的导航栏控件。无论选择哪种组合方式，都可以实现简洁、高效的页面切换效果，为用户提供良好的交互体验。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>ViewPager 和 ViewPager2 看名字就知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用。</li>\n</ul>\n<h2 id=\"1-2-用途\"><a href=\"#1-2-用途\" class=\"headerlink\" title=\"1.2 用途\"></a>1.2 用途</h2><ul>\n<li><code>以可滑动的格式显示视图或 Fragment。</code>文档这一句话已经将用途说得很清楚了，说白了就是让界面可以左右滑动，承担视图或者 Fragment 的切换工作。当然，Fragment 也算是一种视图控件，只不过有自己独立的生命周期而已。</li>\n<li>使用 ViewPager 或 ViewPager2，可以将不同的 Fragment 或 View 作为页面，并轻松地进行页面切换和管理。这对于构建需要在多个页面之间切换的应用程序非常有用，例如图片浏览器、新闻阅读器、引导页等。</li>\n</ul>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-ViewPager-BottomNavigationView\"><a href=\"#2-1-ViewPager-BottomNavigationView\" class=\"headerlink\" title=\"2.1 ViewPager + BottomNavigationView\"></a>2.1 ViewPager + BottomNavigationView</h2><ul>\n<li>ViewPager 不论是一代还是二代，一般都是配合其它控件进行使用的，比如这里举一个 ViewPager + BottomNavigationView 的例子。</li>\n<li>BottomNavigationView 简单介绍一下，它是一个底部导航视图，通常由多个图标和标签组成，用于在应用程序的底部提供导航菜单栏。</li>\n<li>可以看出，我们要实现的就是点击 BottomNavigationView 的某个 item 时，切换到指定的 Fragment，并且 ViewPager 进行同步的切换。或者，滑动 ViewPager 时，切换到指定的 Fragment，并且 BottomNavigationView 切换到对应的 item。总结一下就是 <code>BottomNavigationView + ViewPager + Fragment 的三者联动</code>。</li>\n</ul>\n<h3 id=\"2-1-1-创建-menu\"><a href=\"#2-1-1-创建-menu\" class=\"headerlink\" title=\"2.1.1 创建 menu\"></a>2.1.1 创建 menu</h3><ul>\n<li>由于 BottomNavigationView 需要配合一个 menu 进行使用，所以我们先新建一个 menu 作为底部导航栏的可选项 item。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">menu</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/todoFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/record_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/record&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/accountFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/shopping_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/account&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/mineFragment&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/account_24&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:title</span>=<span class=\"string\">&quot;@string/mine&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 item 的 id 用于唯一标识底部导航栏中的各个选项，通过这些唯一的 id 来区分不同的选项，并在代码中进行相应的处理。</li>\n</ul>\n<h3 id=\"2-1-2-创建主界面\"><a href=\"#2-1-2-创建主界面\" class=\"headerlink\" title=\"2.1.2 创建主界面\"></a>2.1.2 创建主界面</h3><ul>\n<li>创建一个包含 ViewPager 和 BottomNavigationView 的页面，一般将 BottomNavigationView 放在下方，其余部分用 ViewPager 填充。不过你当然也可以将 BottomNavigationView 放在你想放的任意位置，只要它拥有自己的 id 就行。</li>\n<li>将上一步创建好的 menu 放入 BottomNavigationView 中，用<code>app:menu=&quot;@menu/your_menu&quot;</code>的方式，下面是示例：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.activity.HomeActivity&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager.widget.ViewPager</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/viewPager_fragments&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toTopOf</span>=<span class=\"string\">&quot;@+id/bottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.bottomnavigation.BottomNavigationView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/bottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">style</span>=<span class=\"string\">&quot;@style/Widget.Design.BottomNavigationView&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@color/white&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:itemBackground</span>=<span class=\"string\">&quot;@color/white&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:menu</span>=<span class=\"string\">&quot;@menu/mint_menu&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候在 Design 界面上就已经可以看到一些预览效果了，但是现在点击和滑动是没有任何关联的，并且 ViewPager 里面现在还没有内容呢。</li>\n</ul>\n<h3 id=\"2-1-3-配置-ViewPager-适配器\"><a href=\"#2-1-3-配置-ViewPager-适配器\" class=\"headerlink\" title=\"2.1.3 配置 ViewPager 适配器\"></a>2.1.3 配置 ViewPager 适配器</h3><ul>\n<li>创建一个继承自 FragmentStatePagerAdapter 的适配器类，在稍微高一点的 SDK 版本中，可以看到 IDE 提示该类已弃用，毕竟有更好的替代了嘛。我们先不管这个提示，暂时现在还是可用的，只是未来某个 SDK 更新可能就移除掉了。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeActivityAdapter</span>(fm: FragmentManager, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> fragmentList: MutableList&lt;Fragment&gt;) :</span><br><span class=\"line\">    FragmentStatePagerAdapter(fm) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentList.size</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getItem</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span>: Fragment &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentList[position]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在创建时我们可以看到，它提示我们必须实现一个带 FragmentManager 为参数的构造器，原因是 FragmentStatePagerAdapter 内部需要使用 FragmentManager 来创建和管理 Fragment。</li>\n<li>接下来，在 Activity 中将适配器设置给 ViewPager：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 省略 -- </span></span><br><span class=\"line\">fragmentList = ArrayList()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> todoFragment = TodoFragment()</span><br><span class=\"line\"><span class=\"keyword\">val</span> accountFragment = AccountFragment()</span><br><span class=\"line\"><span class=\"keyword\">val</span> mineFragment = MineFragment()</span><br><span class=\"line\"></span><br><span class=\"line\">fragmentList.add(todoFragment)</span><br><span class=\"line\">fragmentList.add(accountFragment)</span><br><span class=\"line\">fragmentList.add(mineFragment)</span><br><span class=\"line\"><span class=\"comment\">//实例化适配器</span></span><br><span class=\"line\">homeActivityAdapter = HomeActivityAdapter(supportFragmentManager, fragmentList)</span><br><span class=\"line\"><span class=\"comment\">//将适配器绑定给 ViewPager</span></span><br><span class=\"line\">binding.viewPagerFragments.adapter = homeActivityAdapter</span><br><span class=\"line\"><span class=\"comment\">// -- 省略 -- </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-4-实现联动\"><a href=\"#2-1-4-实现联动\" class=\"headerlink\" title=\"2.1.4 实现联动\"></a>2.1.4 实现联动</h3><ul>\n<li>滑动viewpager时，联动底部按钮：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    binding.viewPagerFragments.setOnPageChangeListener(<span class=\"keyword\">object</span> : OnPageChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageScrolled</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        position: <span class=\"type\">Int</span>, positionOffset: <span class=\"type\">Float</span>, positionOffsetPixels: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置顶部的 actionBar 标题变化为 bottomNavigationView 的 menu 对应 item 的&quot;android:title&quot;字段的值</span></span><br><span class=\"line\">        supportActionBar?.title = binding.bottomNavigationView.menu.getItem(position).title</span><br><span class=\"line\">        <span class=\"comment\">//判断 ViewPager 滑动的位置，并且根据位置更新 bottomNavigationView 的选中条目 id</span></span><br><span class=\"line\">        <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.todoFragment</span><br><span class=\"line\">            <span class=\"number\">1</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.accountFragment</span><br><span class=\"line\">            <span class=\"number\">2</span> -&gt; binding.bottomNavigationView.selectedItemId = R.id.mineFragment</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageScrollStateChanged</span><span class=\"params\">(state: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>点击底部按钮时，联动viewpager进行滑动：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    binding.bottomNavigationView.setOnNavigationItemSelectedListener &#123; item -&gt;</span><br><span class=\"line\">    <span class=\"comment\">//在 Item 更新时，同步更新 ViewPager 的当前 item 项</span></span><br><span class=\"line\">    <span class=\"keyword\">when</span> (item.itemId) &#123;</span><br><span class=\"line\">        R.id.todoFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        R.id.accountFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        R.id.mineFragment -&gt; &#123;</span><br><span class=\"line\">            binding.viewPagerFragments.currentItem = <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到此为止，就实现了一个简单的底部导航 + 滑动视图切换的功能。不过上面用到的大多数方法或类都已经弃用，包括<code>setOnPageChangeListener</code>和<code>setOnNavigationItemSelectedListener</code>和前面提到的<code>FragmentStatePagerAdapter</code>。这样一看全是弃用的 API，如果是用在比较大的项目中显然是不合适的。</li>\n</ul>\n<h2 id=\"2-2-ViewPager2-TabLayout\"><a href=\"#2-2-ViewPager2-TabLayout\" class=\"headerlink\" title=\"2.2 ViewPager2 + TabLayout\"></a>2.2 ViewPager2 + TabLayout</h2><ul>\n<li>接下来介绍一下 ViewPager2 的使用，相比于一代，性能更优秀，使用更方便，当然也不会有那么多被弃用的 API 了。与其联动的控件不再选择 BottomNavigationView 而选择 TabLayout，当然喽，选择 BottomNavigationView 也是完全 ok 的，这里只是多举一些其他的情况。</li>\n<li>TabLayout 也简单介绍一下，看名字和前面的 BottomNavigationView 像是两个相反作用的控件，实际也确实如此，TabLayout 是 Material Design 中的一个标签栏控件，用于显示多个选项卡，并与 ViewPager2 进行联动。功能和 BottomNavigationView 几乎一致，不过一般用于顶部的选项卡切换。</li>\n<li>TabLayout 和 BottomNavigationView 在我看来其实是差不多的，他们所处的位置完全可以自己决定，样式也可以通过配置变得完全一样，但是还是尽量按照约定来行使各自的功能，毕竟我们的代码不仅要自己能看懂，也要尽量让别人看得舒服。</li>\n</ul>\n<h3 id=\"2-2-1-创建页面\"><a href=\"#2-2-1-创建页面\" class=\"headerlink\" title=\"2.2.1 创建页面\"></a>2.2.1 创建页面</h3><ul>\n<li>直接构建一个包含 TabLayout 和 ViewPager2 的页面：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/fragment_account&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">&quot;.fragment.account.AccountFragment&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/TabLayout&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Monday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Tuesday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.google.android.material.tabs.TabItem</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">tools:text</span>=<span class=\"string\">&quot;Wednesday&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">com.google.android.material.tabs.TabLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager2.widget.ViewPager2</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/ViewPager2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;0dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintEnd_toEndOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintStart_toStartOf</span>=<span class=\"string\">&quot;parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">app:layout_constraintTop_toBottomOf</span>=<span class=\"string\">&quot;@+id/TabLayout&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我这里可以直接使用这两个控件，如果不能使用的话，去 Build.Gradle 文件中导入对应的依赖即可。</li>\n</ul>\n<h3 id=\"2-2-2-实现联动\"><a href=\"#2-2-2-实现联动\" class=\"headerlink\" title=\"2.2.2 实现联动\"></a>2.2.2 实现联动</h3><ul>\n<li>没错，我们不需要再单独创建适配器了，可以直接使用 FragmentStateAdapter 创建一个匿名类实现适配器功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 省略 --</span></span><br><span class=\"line\">fragmentsList = ArrayList()</span><br><span class=\"line\"></span><br><span class=\"line\">fragmentsList.add(PayFragment())</span><br><span class=\"line\">fragmentsList.add(IncomeFragment())</span><br><span class=\"line\">fragmentsList.add(ChartFragment())</span><br><span class=\"line\"></span><br><span class=\"line\">binding.ViewPager2.adapter = <span class=\"keyword\">object</span> : FragmentStateAdapter(requireActivity()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//里面有几个页面</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span></span> = fragmentsList.size</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//每一个位置对应哪个 Fragment</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createFragment</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> = <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> -&gt; PayFragment()</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; IncomeFragment()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; ChartFragment()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//协调 viewpager2 与 TabLayout 的辅助类</span></span><br><span class=\"line\">TabLayoutMediator(</span><br><span class=\"line\">    binding.TabLayout, binding.ViewPager2</span><br><span class=\"line\">) &#123; tab, position -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (position) &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> -&gt; tab.text = resources.getString(R.string.pay)</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; tab.text = resources.getString(R.string.income)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; tab.text = resources.getString(R.string.chart)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.attach()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 省略 --</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面代码就实现了 TabLayout + ViewPager2 的联动效果，具体来说：<ol>\n<li>定义了一个继承自 FragmentStateAdapter 的匿名适配器类。在适配器中，重写了 getItemCount 方法，返回 fragmentsList 的大小，即页面的数量。然后，重写了 createFragment 方法，根据位置返回相应的 Fragment 实例。</li>\n<li>使用 TabLayoutMediator 类来协调 TabLayout 和 ViewPager2 之间的联动。通过传入 TabLayout 和 ViewPager2 的实例，以及一个 lambda 表达式，关联了 TabLayout 中的选项卡和 ViewPager2 中的页面。lambda 表达式中的 tab 参数表示当前选项卡，position 参数表示当前选项卡的位置，在 lambda 表达式中根据位置设置选项卡显示的文本。</li>\n<li>最后，调用 attach() 方法将 TabLayout 和 ViewPager2 进行关联。</li>\n</ol>\n</li>\n<li>代码量来说确实少一些，不过差异主要集中在 TabLayout 和 BottomNavigationView 的实现上，实际上两个 ViewPager 的实现代码的代码量差别并不大，但是还是更推荐使用较新的 ViewPager2 来进行 Fragment 的管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>当开发 Android 应用程序时，我们经常需要在不同的页面之间进行切换。为了满足这种需求，我们可以使用 ViewPager 或 ViewPager2 作为页面容器控件，并结合 BottomNavigationView 或 TabLayout 实现页面切换的联动效果。</li>\n<li>ViewPager 和 ViewPager2 都是用于实现页面切换的容器控件。ViewPager 适用于简单场景，而 ViewPager2 提供了更多的功能和更好的性能。BottomNavigationView 和 TabLayout 则分别为两者提供了与之联动的导航栏控件。无论选择哪种组合方式，都可以实现简洁、高效的页面切换效果，为用户提供良好的交互体验。</li>\n</ul>\n"},{"title":"安卓开发中常用的几种动画介绍","date":"2023-09-07T00:00:00.000Z","description":"介绍安卓开发中使用较多的动画，包括视图动画、属性动画、帧动画、揭露动画等。","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/oi8A2D.png","_content":" \n\n# 一、视图动画（View 动画）\n\n## 1.1 概念\n\n- 视图动画（View Animation）是一种在 Android 中用于为视图对象添加动画效果的机制。它允许你通过改变视图的属性值（如位置、尺寸、透明度等）来创建平滑的动画效果。\n- 视图动画的概念是基于补间动画（Tween Animation）的，在其中定义起始和结束状态，系统会在这两个状态之间自动生成过渡动画。\n\n## 1.2 使用示例\n\n- 首先我们要知道一点，视图动画其实就是安卓为我们提供了很多继承自 Animation 的类，例如 AlphaAnimation（透明度动画）、ScaleAnimation（缩放动画）等等。使用他们就可以实现某个视图的某个属性的动态变化。\n\n### 1.2.1 透明度动画\n\n- 下面是一个点击按钮后将图片透明度从 100% 变成 0% 的动画：\n- \n```kotlin\n        binding.button1.setOnClickListener { \n            //透明度动画\n            val animation = AlphaAnimation(1f, 0f)\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n- 参数很简单就是从哪个透明度到哪个透明度。\n\n### 1.2.2 旋转动画\n\n- 点击按钮后将图片从指定位置作为圆心（默认为图片左上角），旋转指定角度的动画：\n\n```kotlin\n        binding.button2.setOnClickListener {\n            //旋转动画\n            val animation = RotateAnimation(\n                0f,\n                360f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f,\n                Animation.RELATIVE_TO_SELF,\n                5f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n- 参数说明：\n  - 第一个参数 0f 表示起始的旋转角度为 0 度。\n  - 第二个参数 360f 表示结束时的旋转角度为 360 度，即完整的一圈。\n  - 第三个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。\n  - 第四个参数 0.5f 表示旋转的轴在 X 轴方向上的位置相对于视图自身宽度的比例为 0.5，即位于视图的中心点。\n  - 第五个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。\n  - 第六个参数 0.5f 表示旋转的轴在 Y 轴方向上的位置相对于视图自身高度的比例为 0.5，即位于视图的中心点。\n- 你可以直接不指定后四个参数，这样旋转的中心点默认就在图片左上角。\n\n### 1.2.3 平移动画\n\n- 点击按钮后将图片从指定位置开始向指定方向做平移操作：\n\n```kotlin\n        binding.button3.setOnClickListener {\n            //平移动画\n            val animation = TranslateAnimation(\n                Animation.RELATIVE_TO_SELF,\n                0f,\n                Animation.RELATIVE_TO_SELF,\n                1f,\n                Animation.RELATIVE_TO_SELF,\n                0f,\n                Animation.RELATIVE_TO_SELF,\n                1f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n\n- 参数说明：\n  - 第一个参数 Animation.RELATIVE_TO_SELF 表示起始点的 X 轴坐标相对于视图自身宽度的比例（即百分比），此处为 0% \n  - 第二个参数 0f 表示起始点的 X 轴坐标，此处为 0 \n  - 第三个参数 Animation.RELATIVE_TO_SELF 表示结束点的 X 轴坐标相对于视图自身宽度的比例，此处为 100% \n  - 第四个参数 1f 表示结束点的 X 轴坐标，此处为视图的宽度 \n  - 第五个参数 Animation.RELATIVE_TO_SELF 表示起始点的 Y 轴坐标相对于视图自身高度的比例，此处为 0% \n  - 第六个参数 0f 表示起始点的 Y 轴坐标，此处为 0 \n  - 第七个参数 Animation.RELATIVE_TO_SELF 表示结束点的 Y 轴坐标相对于视图自身高度的比例，此处为 100% \n  - 第八个参数 1f 表示结束点的 Y 轴坐标，此处为视图的高度\n- 上面的参数就实现了图片平移至图片右下角的操作。还有一个常用的4个参数的构造方法，可以直接指定平移的像素即可，感兴趣的自己探索一下。\n\n### 1.2.4 缩放动画\n\n- 点击按钮后将以指定位置为中心点将图片进行放大或者缩小动画：\n\n```kotlin\n        binding.button4.setOnClickListener {\n            //缩放动画\n            val animation = ScaleAnimation(\n                0.5f,\n                1f,\n                0.5f,\n                1f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n\n- 参数的作用和前面其实是差不多的，就不再介绍了。\n\n### 1.2.5 动画集合和差值器\n\n- 如果我们要实现多个动画同时执行呢？比如一边旋转一边透明度发生变化？这时你需要用到一个动画集合类：AnimationSet。\n\n```kotlin\n            val animationSet = AnimationSet(true)\n\n            // 透明度动画\n            val alphaAnimation = AlphaAnimation(0f, 1f)\n            alphaAnimation.duration = 2000\n            // 将透明度变化的动画添加进动画集合\n            animationSet.addAnimation(alphaAnimation)\n\n            // 缩放动画\n            val scaleAnimation = ScaleAnimation(\n                1f, 1.5f, // X 轴方向的起始和结束比例\n                1f, 1.5f, // Y 轴方向的起始和结束比例\n                Animation.RELATIVE_TO_SELF, 0.5f, // 缩放中心点的 X 坐标，相对于自身宽度的比例\n                Animation.RELATIVE_TO_SELF, 0.5f // 缩放中心点的 Y 坐标，相对于自身高度的比例\n            )\n            scaleAnimation.duration = 2000\n            // 将缩放的动画添加进动画集合\n            animationSet.addAnimation(scaleAnimation)\n            \n            //开始动画\n            binding.imageView.startAnimation(animationSet)\n```\n\n- 在 AnimationSet 的构造函数中，传入的参数 shareInterpolator 是一个布尔值，用于指定是否共享插值器。\n- 当 shareInterpolator 设置为 true 时，表示所有添加到 AnimationSet 中的子动画都将使用相同的插值器。这意味着无论您在哪个子动画中设置插值器，都会被应用到整个 AnimationSet 中的所有子动画上。 \n- 例如，假设您将 AnimationSet 设置为 true，并且在其中添加了一个缩放动画和一个旋转动画。如果您为缩放动画设置了一个加速插值器，那么旋转动画也会使用相同的加速插值器。\n- 这里顺便介绍一下几个常用的差值器：\n  1. 线性差值器（LinearInterpolator）：动画按照匀速进行，即在整个动画过程中，每个时间段内的变化量都相同。\n  2. 减速差值器（DecelerateInterpolator）：动画开始时较快，然后逐渐减速。 \n  3. 加速减速差值器（AccelerateDecelerateInterpolator）：动画开始和结束时较慢，中间阶段加速运动。 \n  4. 弹跳差值器（BounceInterpolator）：动画在结束时会反弹一下，形成弹跳效果。 \n  5. 周期差值器（CycleInterpolator）：动画按照正弦或余弦曲线进行循环运动。 \n  6. 反向差值器（AnticipateInterpolator）：动画开始前有一个向后的偏移，然后再开始正常的动画过程。 \n  7. 弹射差值器（OvershootInterpolator）：动画在结束时会超过目标值一段距离，然后再回弹到目标值。\n- 使用也非常简单：\n\n```kotlin\nval scaleAnimation = ScaleAnimation(...)\nscaleAnimation.interpolator = AccelerateInterpolator() // 设置加速差值器\n```\n\n# 二、属性动画（Property 动画）\n\n## 2.1 概念\n\n- 属性动画所提供的功能和视图动画十分相似。但两者在实现原理上完全不同，而且相对视图动画来说，属性动画要强大许多。\n- 视图动画和属性动画的对比：\n  1. 视图动画： \n     - View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。 \n     - View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。 \n     - View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。\n  2. 属性动画：\n     - 属性动画作用对象不局限在 View 上，而是任何提供了 Getter 和 Setter 方法的对象的属性上。 \n     - 属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。 \n     - 属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。 \n     - 属性动画上手难度较高，对于 propertyName 需要自己去挖掘，或者自己通过 Wrapper 的方式去自定义 propertyName。\n\n\n## 2.2 使用示例\n\n### 2.2.1 透明度动画\n\n```kotlin\n    // 创建透明度动画对象\n    val alphaAnimation = ObjectAnimator.ofFloat(view, \"alpha\", 0f, 1f)\n    // 设置动画属性\n    alphaAnimation.duration = 1000 // 动画时长，单位为毫秒\n    // 启动动画\n    alphaAnimation.start()\n```\n\n### 2.2.2 缩放动画\n\n```kotlin\n    // 创建缩放动画对象\n    val scaleXAnimation = ObjectAnimator.ofFloat(view, \"scaleX\", 1f, 2f)\n    val scaleYAnimation = ObjectAnimator.ofFloat(view, \"scaleY\", 1f, 2f)\n    \n    // 创建缩放动画集合\n    val scaleAnimationSet = AnimatorSet()\n    scaleAnimationSet.playTogether(scaleXAnimation, scaleYAnimation)\n    scaleAnimationSet.duration = 1000 // 动画时长，单位为毫秒\n    \n    // 启动动画\n    scaleAnimationSet.start()\n```\n\n### 2.2.3 旋转动画\n\n```kotlin\n// 创建旋转动画对象\nval rotationAnimation = ObjectAnimator.ofFloat(view, \"rotation\", 0f, 360f)\n// 设置动画属性\nrotationAnimation.duration = 1000 // 动画时长，单位为毫秒\nrotationAnimation.repeatCount = ValueAnimator.INFINITE // 无限循环\n// 启动动画\nrotationAnimation.start()\n```\n\n## 2.3 小结\n\n- 不用举太多例子了，因为光看上面几个例子就可以发现属性动画在代码实现上和视图动画很像，并且也可以添加差值器，使用 AnimationSet 等，可以简单的认为他就是视图动画的一个增强版，我们大部分情况下只需要指定第二个参数：propertyName，就可以实现多种多样的动画效果。\n- 此外，属性动画可以使用自定义的插值器（Interpolator）来控制动画的速度变化。你可以根据需要创建不同的插值器，实现各种动画效果。\n- 属性动画还可以通过添加监听器来监听动画开始、结束、重复等事件，并在特定事件发生时执行相应的操作。视图动画没有提供类似的事件监听机制。\n\n# 三、帧动画（Frame 动画）\n\n## 3.1 概念\n\n- 帧动画（Frame Animation），也称为逐帧动画或逐帧播放动画，是一种基于一系列预定义图像帧的动画效果。它通过按照一定的时间间隔依次显示不同的图像帧来创建动画效果。\n- 帧动画通常由多个连续的静态图像组成，这些图像按照特定的顺序排列。当播放帧动画时，系统会依次显示这些图像帧，给人以连续变化的动画感觉。\n\n## 3.2 使用示例\n\n- 在 Android 开发中，帧动画可以使用 XML 或代码来定义。您可以在 XML 文件中指定每个帧所对应的图像资源，以及每帧显示的持续时间。然后，通过加载该 XML 文件并将其设置为一个 ImageView 的背景，即可启动帧动画。\n- 以下是一个示例 XML 文件的结构，用于定义帧动画：\n```xml\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"true\">\n    <item\n        android:drawable=\"@drawable/frame1\"\n        android:duration=\"100\"/>\n    <item\n        android:drawable=\"@drawable/frame2\"\n        android:duration=\"100\"/>\n    <!-- 其他帧 -->\n</animation-list>\n```\n- 其中，每个 <item> 标签定义了一个图像帧。android:drawable 属性指定了该帧显示的图像资源，android:duration 属性定义了该帧显示的持续时间（以毫秒为单位）。\n- 帧动画适用于简单的、预先确定的动画效果，例如循环播放的加载动画、简单的图标动画等。然而，相对于属性动画和视图动画，它的灵活性较低，不能实现复杂的动画交互效果。\n- 同时，大多数场景下，其实帧动画可以直接用一个 GIF 图片进行替代，加上同时加载大量图片资源还可能导致 OOM，所以实际开发中使用得比较少。\n\n# 四、揭露动画（Reveal 动画）\n\n## 4.1 概念\n\n- 揭露动画（Reveal 动画）是我写博客的时候查资料看到的，就临时加进来了，之前我其实是没听过这个动画的，不过看到动画演示后我发现这种动画其实还挺常见的。\n- 揭露动画是一种视觉效果，它可以通过从屏幕的一个点开始扩散出去的方式，将一个视图或布局揭示出来，具有很好的用户体验和交互效果。\n\n## 4.2 使用示例\n\n- 下面是一个圆形揭露动画的效果，通过 ViewAnimationUtils.createCircularReveal() 就可以创建这样一个揭露动画：\n\n```kotlin\n        binding.imageView.setOnClickListener {\n            // 计算揭露动画的起始点和结束点\n            val cx = binding.imageView.width / 2\n            val cy = binding.imageView.height / 2\n            // hypot 函数用于计算揭露动画的最大半径\n            val endRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()\n        \n            // 创建揭露动画对象\n            val anim = ViewAnimationUtils.createCircularReveal(binding.imageView, cx, cy, 0f, endRadius)\n            anim.duration = 1000 // 设置动画持续时间\n            anim.start() // 启动揭露动画\n        }\n```\n\n# 五、总结\n\n- 以上就是安卓开发中几个比较常用的动画了，主要是用于某个控件的动态变化效果。\n- 除了上面介绍的几种动画，安卓开发中还有转场动画、矢量动画、触摸反馈动画等这里没有做介绍，感兴趣的可以自己研究研究。\n","source":"_posts/安卓_08_安卓开发中常用的几种动画介绍.md","raw":"---\ntitle: '安卓开发中常用的几种动画介绍'\ndate: '2023-09-07'\ndescription: '介绍安卓开发中使用较多的动画，包括视图动画、属性动画、帧动画、揭露动画等。'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/oi8A2D.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n\n--- \n\n# 一、视图动画（View 动画）\n\n## 1.1 概念\n\n- 视图动画（View Animation）是一种在 Android 中用于为视图对象添加动画效果的机制。它允许你通过改变视图的属性值（如位置、尺寸、透明度等）来创建平滑的动画效果。\n- 视图动画的概念是基于补间动画（Tween Animation）的，在其中定义起始和结束状态，系统会在这两个状态之间自动生成过渡动画。\n\n## 1.2 使用示例\n\n- 首先我们要知道一点，视图动画其实就是安卓为我们提供了很多继承自 Animation 的类，例如 AlphaAnimation（透明度动画）、ScaleAnimation（缩放动画）等等。使用他们就可以实现某个视图的某个属性的动态变化。\n\n### 1.2.1 透明度动画\n\n- 下面是一个点击按钮后将图片透明度从 100% 变成 0% 的动画：\n- \n```kotlin\n        binding.button1.setOnClickListener { \n            //透明度动画\n            val animation = AlphaAnimation(1f, 0f)\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n- 参数很简单就是从哪个透明度到哪个透明度。\n\n### 1.2.2 旋转动画\n\n- 点击按钮后将图片从指定位置作为圆心（默认为图片左上角），旋转指定角度的动画：\n\n```kotlin\n        binding.button2.setOnClickListener {\n            //旋转动画\n            val animation = RotateAnimation(\n                0f,\n                360f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f,\n                Animation.RELATIVE_TO_SELF,\n                5f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n- 参数说明：\n  - 第一个参数 0f 表示起始的旋转角度为 0 度。\n  - 第二个参数 360f 表示结束时的旋转角度为 360 度，即完整的一圈。\n  - 第三个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。\n  - 第四个参数 0.5f 表示旋转的轴在 X 轴方向上的位置相对于视图自身宽度的比例为 0.5，即位于视图的中心点。\n  - 第五个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。\n  - 第六个参数 0.5f 表示旋转的轴在 Y 轴方向上的位置相对于视图自身高度的比例为 0.5，即位于视图的中心点。\n- 你可以直接不指定后四个参数，这样旋转的中心点默认就在图片左上角。\n\n### 1.2.3 平移动画\n\n- 点击按钮后将图片从指定位置开始向指定方向做平移操作：\n\n```kotlin\n        binding.button3.setOnClickListener {\n            //平移动画\n            val animation = TranslateAnimation(\n                Animation.RELATIVE_TO_SELF,\n                0f,\n                Animation.RELATIVE_TO_SELF,\n                1f,\n                Animation.RELATIVE_TO_SELF,\n                0f,\n                Animation.RELATIVE_TO_SELF,\n                1f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n\n- 参数说明：\n  - 第一个参数 Animation.RELATIVE_TO_SELF 表示起始点的 X 轴坐标相对于视图自身宽度的比例（即百分比），此处为 0% \n  - 第二个参数 0f 表示起始点的 X 轴坐标，此处为 0 \n  - 第三个参数 Animation.RELATIVE_TO_SELF 表示结束点的 X 轴坐标相对于视图自身宽度的比例，此处为 100% \n  - 第四个参数 1f 表示结束点的 X 轴坐标，此处为视图的宽度 \n  - 第五个参数 Animation.RELATIVE_TO_SELF 表示起始点的 Y 轴坐标相对于视图自身高度的比例，此处为 0% \n  - 第六个参数 0f 表示起始点的 Y 轴坐标，此处为 0 \n  - 第七个参数 Animation.RELATIVE_TO_SELF 表示结束点的 Y 轴坐标相对于视图自身高度的比例，此处为 100% \n  - 第八个参数 1f 表示结束点的 Y 轴坐标，此处为视图的高度\n- 上面的参数就实现了图片平移至图片右下角的操作。还有一个常用的4个参数的构造方法，可以直接指定平移的像素即可，感兴趣的自己探索一下。\n\n### 1.2.4 缩放动画\n\n- 点击按钮后将以指定位置为中心点将图片进行放大或者缩小动画：\n\n```kotlin\n        binding.button4.setOnClickListener {\n            //缩放动画\n            val animation = ScaleAnimation(\n                0.5f,\n                1f,\n                0.5f,\n                1f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f,\n                Animation.RELATIVE_TO_SELF,\n                0.5f\n            )\n            //动画持续时间\n            animation.duration = 2000\n            binding.imageView.startAnimation(animation)\n        }\n```\n\n- 参数的作用和前面其实是差不多的，就不再介绍了。\n\n### 1.2.5 动画集合和差值器\n\n- 如果我们要实现多个动画同时执行呢？比如一边旋转一边透明度发生变化？这时你需要用到一个动画集合类：AnimationSet。\n\n```kotlin\n            val animationSet = AnimationSet(true)\n\n            // 透明度动画\n            val alphaAnimation = AlphaAnimation(0f, 1f)\n            alphaAnimation.duration = 2000\n            // 将透明度变化的动画添加进动画集合\n            animationSet.addAnimation(alphaAnimation)\n\n            // 缩放动画\n            val scaleAnimation = ScaleAnimation(\n                1f, 1.5f, // X 轴方向的起始和结束比例\n                1f, 1.5f, // Y 轴方向的起始和结束比例\n                Animation.RELATIVE_TO_SELF, 0.5f, // 缩放中心点的 X 坐标，相对于自身宽度的比例\n                Animation.RELATIVE_TO_SELF, 0.5f // 缩放中心点的 Y 坐标，相对于自身高度的比例\n            )\n            scaleAnimation.duration = 2000\n            // 将缩放的动画添加进动画集合\n            animationSet.addAnimation(scaleAnimation)\n            \n            //开始动画\n            binding.imageView.startAnimation(animationSet)\n```\n\n- 在 AnimationSet 的构造函数中，传入的参数 shareInterpolator 是一个布尔值，用于指定是否共享插值器。\n- 当 shareInterpolator 设置为 true 时，表示所有添加到 AnimationSet 中的子动画都将使用相同的插值器。这意味着无论您在哪个子动画中设置插值器，都会被应用到整个 AnimationSet 中的所有子动画上。 \n- 例如，假设您将 AnimationSet 设置为 true，并且在其中添加了一个缩放动画和一个旋转动画。如果您为缩放动画设置了一个加速插值器，那么旋转动画也会使用相同的加速插值器。\n- 这里顺便介绍一下几个常用的差值器：\n  1. 线性差值器（LinearInterpolator）：动画按照匀速进行，即在整个动画过程中，每个时间段内的变化量都相同。\n  2. 减速差值器（DecelerateInterpolator）：动画开始时较快，然后逐渐减速。 \n  3. 加速减速差值器（AccelerateDecelerateInterpolator）：动画开始和结束时较慢，中间阶段加速运动。 \n  4. 弹跳差值器（BounceInterpolator）：动画在结束时会反弹一下，形成弹跳效果。 \n  5. 周期差值器（CycleInterpolator）：动画按照正弦或余弦曲线进行循环运动。 \n  6. 反向差值器（AnticipateInterpolator）：动画开始前有一个向后的偏移，然后再开始正常的动画过程。 \n  7. 弹射差值器（OvershootInterpolator）：动画在结束时会超过目标值一段距离，然后再回弹到目标值。\n- 使用也非常简单：\n\n```kotlin\nval scaleAnimation = ScaleAnimation(...)\nscaleAnimation.interpolator = AccelerateInterpolator() // 设置加速差值器\n```\n\n# 二、属性动画（Property 动画）\n\n## 2.1 概念\n\n- 属性动画所提供的功能和视图动画十分相似。但两者在实现原理上完全不同，而且相对视图动画来说，属性动画要强大许多。\n- 视图动画和属性动画的对比：\n  1. 视图动画： \n     - View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。 \n     - View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。 \n     - View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。\n  2. 属性动画：\n     - 属性动画作用对象不局限在 View 上，而是任何提供了 Getter 和 Setter 方法的对象的属性上。 \n     - 属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。 \n     - 属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。 \n     - 属性动画上手难度较高，对于 propertyName 需要自己去挖掘，或者自己通过 Wrapper 的方式去自定义 propertyName。\n\n\n## 2.2 使用示例\n\n### 2.2.1 透明度动画\n\n```kotlin\n    // 创建透明度动画对象\n    val alphaAnimation = ObjectAnimator.ofFloat(view, \"alpha\", 0f, 1f)\n    // 设置动画属性\n    alphaAnimation.duration = 1000 // 动画时长，单位为毫秒\n    // 启动动画\n    alphaAnimation.start()\n```\n\n### 2.2.2 缩放动画\n\n```kotlin\n    // 创建缩放动画对象\n    val scaleXAnimation = ObjectAnimator.ofFloat(view, \"scaleX\", 1f, 2f)\n    val scaleYAnimation = ObjectAnimator.ofFloat(view, \"scaleY\", 1f, 2f)\n    \n    // 创建缩放动画集合\n    val scaleAnimationSet = AnimatorSet()\n    scaleAnimationSet.playTogether(scaleXAnimation, scaleYAnimation)\n    scaleAnimationSet.duration = 1000 // 动画时长，单位为毫秒\n    \n    // 启动动画\n    scaleAnimationSet.start()\n```\n\n### 2.2.3 旋转动画\n\n```kotlin\n// 创建旋转动画对象\nval rotationAnimation = ObjectAnimator.ofFloat(view, \"rotation\", 0f, 360f)\n// 设置动画属性\nrotationAnimation.duration = 1000 // 动画时长，单位为毫秒\nrotationAnimation.repeatCount = ValueAnimator.INFINITE // 无限循环\n// 启动动画\nrotationAnimation.start()\n```\n\n## 2.3 小结\n\n- 不用举太多例子了，因为光看上面几个例子就可以发现属性动画在代码实现上和视图动画很像，并且也可以添加差值器，使用 AnimationSet 等，可以简单的认为他就是视图动画的一个增强版，我们大部分情况下只需要指定第二个参数：propertyName，就可以实现多种多样的动画效果。\n- 此外，属性动画可以使用自定义的插值器（Interpolator）来控制动画的速度变化。你可以根据需要创建不同的插值器，实现各种动画效果。\n- 属性动画还可以通过添加监听器来监听动画开始、结束、重复等事件，并在特定事件发生时执行相应的操作。视图动画没有提供类似的事件监听机制。\n\n# 三、帧动画（Frame 动画）\n\n## 3.1 概念\n\n- 帧动画（Frame Animation），也称为逐帧动画或逐帧播放动画，是一种基于一系列预定义图像帧的动画效果。它通过按照一定的时间间隔依次显示不同的图像帧来创建动画效果。\n- 帧动画通常由多个连续的静态图像组成，这些图像按照特定的顺序排列。当播放帧动画时，系统会依次显示这些图像帧，给人以连续变化的动画感觉。\n\n## 3.2 使用示例\n\n- 在 Android 开发中，帧动画可以使用 XML 或代码来定义。您可以在 XML 文件中指定每个帧所对应的图像资源，以及每帧显示的持续时间。然后，通过加载该 XML 文件并将其设置为一个 ImageView 的背景，即可启动帧动画。\n- 以下是一个示例 XML 文件的结构，用于定义帧动画：\n```xml\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"true\">\n    <item\n        android:drawable=\"@drawable/frame1\"\n        android:duration=\"100\"/>\n    <item\n        android:drawable=\"@drawable/frame2\"\n        android:duration=\"100\"/>\n    <!-- 其他帧 -->\n</animation-list>\n```\n- 其中，每个 <item> 标签定义了一个图像帧。android:drawable 属性指定了该帧显示的图像资源，android:duration 属性定义了该帧显示的持续时间（以毫秒为单位）。\n- 帧动画适用于简单的、预先确定的动画效果，例如循环播放的加载动画、简单的图标动画等。然而，相对于属性动画和视图动画，它的灵活性较低，不能实现复杂的动画交互效果。\n- 同时，大多数场景下，其实帧动画可以直接用一个 GIF 图片进行替代，加上同时加载大量图片资源还可能导致 OOM，所以实际开发中使用得比较少。\n\n# 四、揭露动画（Reveal 动画）\n\n## 4.1 概念\n\n- 揭露动画（Reveal 动画）是我写博客的时候查资料看到的，就临时加进来了，之前我其实是没听过这个动画的，不过看到动画演示后我发现这种动画其实还挺常见的。\n- 揭露动画是一种视觉效果，它可以通过从屏幕的一个点开始扩散出去的方式，将一个视图或布局揭示出来，具有很好的用户体验和交互效果。\n\n## 4.2 使用示例\n\n- 下面是一个圆形揭露动画的效果，通过 ViewAnimationUtils.createCircularReveal() 就可以创建这样一个揭露动画：\n\n```kotlin\n        binding.imageView.setOnClickListener {\n            // 计算揭露动画的起始点和结束点\n            val cx = binding.imageView.width / 2\n            val cy = binding.imageView.height / 2\n            // hypot 函数用于计算揭露动画的最大半径\n            val endRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()\n        \n            // 创建揭露动画对象\n            val anim = ViewAnimationUtils.createCircularReveal(binding.imageView, cx, cy, 0f, endRadius)\n            anim.duration = 1000 // 设置动画持续时间\n            anim.start() // 启动揭露动画\n        }\n```\n\n# 五、总结\n\n- 以上就是安卓开发中几个比较常用的动画了，主要是用于某个控件的动态变化效果。\n- 除了上面介绍的几种动画，安卓开发中还有转场动画、矢量动画、触摸反馈动画等这里没有做介绍，感兴趣的可以自己研究研究。\n","slug":"安卓_08_安卓开发中常用的几种动画介绍","published":1,"updated":"2023-09-25T07:09:12.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5i001527hoezbg9eeq","content":"<h1 id=\"一、视图动画（View-动画）\"><a href=\"#一、视图动画（View-动画）\" class=\"headerlink\" title=\"一、视图动画（View 动画）\"></a>一、视图动画（View 动画）</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>视图动画（View Animation）是一种在 Android 中用于为视图对象添加动画效果的机制。它允许你通过改变视图的属性值（如位置、尺寸、透明度等）来创建平滑的动画效果。</li>\n<li>视图动画的概念是基于补间动画（Tween Animation）的，在其中定义起始和结束状态，系统会在这两个状态之间自动生成过渡动画。</li>\n</ul>\n<h2 id=\"1-2-使用示例\"><a href=\"#1-2-使用示例\" class=\"headerlink\" title=\"1.2 使用示例\"></a>1.2 使用示例</h2><ul>\n<li>首先我们要知道一点，视图动画其实就是安卓为我们提供了很多继承自 Animation 的类，例如 AlphaAnimation（透明度动画）、ScaleAnimation（缩放动画）等等。使用他们就可以实现某个视图的某个属性的动态变化。</li>\n</ul>\n<h3 id=\"1-2-1-透明度动画\"><a href=\"#1-2-1-透明度动画\" class=\"headerlink\" title=\"1.2.1 透明度动画\"></a>1.2.1 透明度动画</h3><ul>\n<li>下面是一个点击按钮后将图片透明度从 100% 变成 0% 的动画：</li>\n<li><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button1.setOnClickListener &#123; </span><br><span class=\"line\">    <span class=\"comment\">//透明度动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = AlphaAnimation(<span class=\"number\">1f</span>, <span class=\"number\">0f</span>)</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>参数很简单就是从哪个透明度到哪个透明度。</li>\n</ul>\n<h3 id=\"1-2-2-旋转动画\"><a href=\"#1-2-2-旋转动画\" class=\"headerlink\" title=\"1.2.2 旋转动画\"></a>1.2.2 旋转动画</h3><ul>\n<li>点击按钮后将图片从指定位置作为圆心（默认为图片左上角），旋转指定角度的动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button2.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//旋转动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = RotateAnimation(</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        <span class=\"number\">360f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">5f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数说明：<ul>\n<li>第一个参数 0f 表示起始的旋转角度为 0 度。</li>\n<li>第二个参数 360f 表示结束时的旋转角度为 360 度，即完整的一圈。</li>\n<li>第三个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。</li>\n<li>第四个参数 0.5f 表示旋转的轴在 X 轴方向上的位置相对于视图自身宽度的比例为 0.5，即位于视图的中心点。</li>\n<li>第五个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。</li>\n<li>第六个参数 0.5f 表示旋转的轴在 Y 轴方向上的位置相对于视图自身高度的比例为 0.5，即位于视图的中心点。</li>\n</ul>\n</li>\n<li>你可以直接不指定后四个参数，这样旋转的中心点默认就在图片左上角。</li>\n</ul>\n<h3 id=\"1-2-3-平移动画\"><a href=\"#1-2-3-平移动画\" class=\"headerlink\" title=\"1.2.3 平移动画\"></a>1.2.3 平移动画</h3><ul>\n<li>点击按钮后将图片从指定位置开始向指定方向做平移操作：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button3.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//平移动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = TranslateAnimation(</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">1f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数说明：<ul>\n<li>第一个参数 Animation.RELATIVE_TO_SELF 表示起始点的 X 轴坐标相对于视图自身宽度的比例（即百分比），此处为 0% </li>\n<li>第二个参数 0f 表示起始点的 X 轴坐标，此处为 0 </li>\n<li>第三个参数 Animation.RELATIVE_TO_SELF 表示结束点的 X 轴坐标相对于视图自身宽度的比例，此处为 100% </li>\n<li>第四个参数 1f 表示结束点的 X 轴坐标，此处为视图的宽度 </li>\n<li>第五个参数 Animation.RELATIVE_TO_SELF 表示起始点的 Y 轴坐标相对于视图自身高度的比例，此处为 0% </li>\n<li>第六个参数 0f 表示起始点的 Y 轴坐标，此处为 0 </li>\n<li>第七个参数 Animation.RELATIVE_TO_SELF 表示结束点的 Y 轴坐标相对于视图自身高度的比例，此处为 100% </li>\n<li>第八个参数 1f 表示结束点的 Y 轴坐标，此处为视图的高度</li>\n</ul>\n</li>\n<li>上面的参数就实现了图片平移至图片右下角的操作。还有一个常用的4个参数的构造方法，可以直接指定平移的像素即可，感兴趣的自己探索一下。</li>\n</ul>\n<h3 id=\"1-2-4-缩放动画\"><a href=\"#1-2-4-缩放动画\" class=\"headerlink\" title=\"1.2.4 缩放动画\"></a>1.2.4 缩放动画</h3><ul>\n<li>点击按钮后将以指定位置为中心点将图片进行放大或者缩小动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button4.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//缩放动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = ScaleAnimation(</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数的作用和前面其实是差不多的，就不再介绍了。</li>\n</ul>\n<h3 id=\"1-2-5-动画集合和差值器\"><a href=\"#1-2-5-动画集合和差值器\" class=\"headerlink\" title=\"1.2.5 动画集合和差值器\"></a>1.2.5 动画集合和差值器</h3><ul>\n<li>如果我们要实现多个动画同时执行呢？比如一边旋转一边透明度发生变化？这时你需要用到一个动画集合类：AnimationSet。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> animationSet = AnimationSet(<span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 透明度动画</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> alphaAnimation = AlphaAnimation(<span class=\"number\">0f</span>, <span class=\"number\">1f</span>)</span><br><span class=\"line\">alphaAnimation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\"><span class=\"comment\">// 将透明度变化的动画添加进动画集合</span></span><br><span class=\"line\">animationSet.addAnimation(alphaAnimation)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缩放动画</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimation = ScaleAnimation(</span><br><span class=\"line\">    <span class=\"number\">1f</span>, <span class=\"number\">1.5f</span>, <span class=\"comment\">// X 轴方向的起始和结束比例</span></span><br><span class=\"line\">    <span class=\"number\">1f</span>, <span class=\"number\">1.5f</span>, <span class=\"comment\">// Y 轴方向的起始和结束比例</span></span><br><span class=\"line\">    Animation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span>, <span class=\"comment\">// 缩放中心点的 X 坐标，相对于自身宽度的比例</span></span><br><span class=\"line\">    Animation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span> <span class=\"comment\">// 缩放中心点的 Y 坐标，相对于自身高度的比例</span></span><br><span class=\"line\">)</span><br><span class=\"line\">scaleAnimation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\"><span class=\"comment\">// 将缩放的动画添加进动画集合</span></span><br><span class=\"line\">animationSet.addAnimation(scaleAnimation)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//开始动画</span></span><br><span class=\"line\">binding.imageView.startAnimation(animationSet)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 AnimationSet 的构造函数中，传入的参数 shareInterpolator 是一个布尔值，用于指定是否共享插值器。</li>\n<li>当 shareInterpolator 设置为 true 时，表示所有添加到 AnimationSet 中的子动画都将使用相同的插值器。这意味着无论您在哪个子动画中设置插值器，都会被应用到整个 AnimationSet 中的所有子动画上。 </li>\n<li>例如，假设您将 AnimationSet 设置为 true，并且在其中添加了一个缩放动画和一个旋转动画。如果您为缩放动画设置了一个加速插值器，那么旋转动画也会使用相同的加速插值器。</li>\n<li>这里顺便介绍一下几个常用的差值器：<ol>\n<li>线性差值器（LinearInterpolator）：动画按照匀速进行，即在整个动画过程中，每个时间段内的变化量都相同。</li>\n<li>减速差值器（DecelerateInterpolator）：动画开始时较快，然后逐渐减速。 </li>\n<li>加速减速差值器（AccelerateDecelerateInterpolator）：动画开始和结束时较慢，中间阶段加速运动。 </li>\n<li>弹跳差值器（BounceInterpolator）：动画在结束时会反弹一下，形成弹跳效果。 </li>\n<li>周期差值器（CycleInterpolator）：动画按照正弦或余弦曲线进行循环运动。 </li>\n<li>反向差值器（AnticipateInterpolator）：动画开始前有一个向后的偏移，然后再开始正常的动画过程。 </li>\n<li>弹射差值器（OvershootInterpolator）：动画在结束时会超过目标值一段距离，然后再回弹到目标值。</li>\n</ol>\n</li>\n<li>使用也非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimation = ScaleAnimation(...)</span><br><span class=\"line\">scaleAnimation.interpolator = AccelerateInterpolator() <span class=\"comment\">// 设置加速差值器</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、属性动画（Property-动画）\"><a href=\"#二、属性动画（Property-动画）\" class=\"headerlink\" title=\"二、属性动画（Property 动画）\"></a>二、属性动画（Property 动画）</h1><h2 id=\"2-1-概念\"><a href=\"#2-1-概念\" class=\"headerlink\" title=\"2.1 概念\"></a>2.1 概念</h2><ul>\n<li>属性动画所提供的功能和视图动画十分相似。但两者在实现原理上完全不同，而且相对视图动画来说，属性动画要强大许多。</li>\n<li>视图动画和属性动画的对比：<ol>\n<li>视图动画： <ul>\n<li>View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。 </li>\n<li>View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。 </li>\n<li>View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。</li>\n</ul>\n</li>\n<li>属性动画：<ul>\n<li>属性动画作用对象不局限在 View 上，而是任何提供了 Getter 和 Setter 方法的对象的属性上。 </li>\n<li>属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。 </li>\n<li>属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。 </li>\n<li>属性动画上手难度较高，对于 propertyName 需要自己去挖掘，或者自己通过 Wrapper 的方式去自定义 propertyName。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-使用示例\"><a href=\"#2-2-使用示例\" class=\"headerlink\" title=\"2.2 使用示例\"></a>2.2 使用示例</h2><h3 id=\"2-2-1-透明度动画\"><a href=\"#2-2-1-透明度动画\" class=\"headerlink\" title=\"2.2.1 透明度动画\"></a>2.2.1 透明度动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建透明度动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> alphaAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>)</span><br><span class=\"line\"><span class=\"comment\">// 设置动画属性</span></span><br><span class=\"line\">alphaAnimation.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">alphaAnimation.start()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-缩放动画\"><a href=\"#2-2-2-缩放动画\" class=\"headerlink\" title=\"2.2.2 缩放动画\"></a>2.2.2 缩放动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建缩放动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleXAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;scaleX&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleYAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;scaleY&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建缩放动画集合</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimationSet = AnimatorSet()</span><br><span class=\"line\">scaleAnimationSet.playTogether(scaleXAnimation, scaleYAnimation)</span><br><span class=\"line\">scaleAnimationSet.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">scaleAnimationSet.start()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-3-旋转动画\"><a href=\"#2-2-3-旋转动画\" class=\"headerlink\" title=\"2.2.3 旋转动画\"></a>2.2.3 旋转动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建旋转动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rotationAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;rotation&quot;</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>)</span><br><span class=\"line\"><span class=\"comment\">// 设置动画属性</span></span><br><span class=\"line\">rotationAnimation.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\">rotationAnimation.repeatCount = ValueAnimator.INFINITE <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">rotationAnimation.start()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-小结\"><a href=\"#2-3-小结\" class=\"headerlink\" title=\"2.3 小结\"></a>2.3 小结</h2><ul>\n<li>不用举太多例子了，因为光看上面几个例子就可以发现属性动画在代码实现上和视图动画很像，并且也可以添加差值器，使用 AnimationSet 等，可以简单的认为他就是视图动画的一个增强版，我们大部分情况下只需要指定第二个参数：propertyName，就可以实现多种多样的动画效果。</li>\n<li>此外，属性动画可以使用自定义的插值器（Interpolator）来控制动画的速度变化。你可以根据需要创建不同的插值器，实现各种动画效果。</li>\n<li>属性动画还可以通过添加监听器来监听动画开始、结束、重复等事件，并在特定事件发生时执行相应的操作。视图动画没有提供类似的事件监听机制。</li>\n</ul>\n<h1 id=\"三、帧动画（Frame-动画）\"><a href=\"#三、帧动画（Frame-动画）\" class=\"headerlink\" title=\"三、帧动画（Frame 动画）\"></a>三、帧动画（Frame 动画）</h1><h2 id=\"3-1-概念\"><a href=\"#3-1-概念\" class=\"headerlink\" title=\"3.1 概念\"></a>3.1 概念</h2><ul>\n<li>帧动画（Frame Animation），也称为逐帧动画或逐帧播放动画，是一种基于一系列预定义图像帧的动画效果。它通过按照一定的时间间隔依次显示不同的图像帧来创建动画效果。</li>\n<li>帧动画通常由多个连续的静态图像组成，这些图像按照特定的顺序排列。当播放帧动画时，系统会依次显示这些图像帧，给人以连续变化的动画感觉。</li>\n</ul>\n<h2 id=\"3-2-使用示例\"><a href=\"#3-2-使用示例\" class=\"headerlink\" title=\"3.2 使用示例\"></a>3.2 使用示例</h2><ul>\n<li>在 Android 开发中，帧动画可以使用 XML 或代码来定义。您可以在 XML 文件中指定每个帧所对应的图像资源，以及每帧显示的持续时间。然后，通过加载该 XML 文件并将其设置为一个 ImageView 的背景，即可启动帧动画。</li>\n<li>以下是一个示例 XML 文件的结构，用于定义帧动画：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">&quot;@drawable/frame1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">&quot;@drawable/frame2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 其他帧 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>其中，每个 <item> 标签定义了一个图像帧。android:drawable 属性指定了该帧显示的图像资源，android:duration 属性定义了该帧显示的持续时间（以毫秒为单位）。</li>\n<li>帧动画适用于简单的、预先确定的动画效果，例如循环播放的加载动画、简单的图标动画等。然而，相对于属性动画和视图动画，它的灵活性较低，不能实现复杂的动画交互效果。</li>\n<li>同时，大多数场景下，其实帧动画可以直接用一个 GIF 图片进行替代，加上同时加载大量图片资源还可能导致 OOM，所以实际开发中使用得比较少。</li>\n</ul>\n<h1 id=\"四、揭露动画（Reveal-动画）\"><a href=\"#四、揭露动画（Reveal-动画）\" class=\"headerlink\" title=\"四、揭露动画（Reveal 动画）\"></a>四、揭露动画（Reveal 动画）</h1><h2 id=\"4-1-概念\"><a href=\"#4-1-概念\" class=\"headerlink\" title=\"4.1 概念\"></a>4.1 概念</h2><ul>\n<li>揭露动画（Reveal 动画）是我写博客的时候查资料看到的，就临时加进来了，之前我其实是没听过这个动画的，不过看到动画演示后我发现这种动画其实还挺常见的。</li>\n<li>揭露动画是一种视觉效果，它可以通过从屏幕的一个点开始扩散出去的方式，将一个视图或布局揭示出来，具有很好的用户体验和交互效果。</li>\n</ul>\n<h2 id=\"4-2-使用示例\"><a href=\"#4-2-使用示例\" class=\"headerlink\" title=\"4.2 使用示例\"></a>4.2 使用示例</h2><ul>\n<li>下面是一个圆形揭露动画的效果，通过 ViewAnimationUtils.createCircularReveal() 就可以创建这样一个揭露动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.imageView.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算揭露动画的起始点和结束点</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> cx = binding.imageView.width / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> cy = binding.imageView.height / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\">// hypot 函数用于计算揭露动画的最大半径</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> endRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建揭露动画对象</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> anim = ViewAnimationUtils.createCircularReveal(binding.imageView, cx, cy, <span class=\"number\">0f</span>, endRadius)</span><br><span class=\"line\">    anim.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 设置动画持续时间</span></span><br><span class=\"line\">    anim.start() <span class=\"comment\">// 启动揭露动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><ul>\n<li>以上就是安卓开发中几个比较常用的动画了，主要是用于某个控件的动态变化效果。</li>\n<li>除了上面介绍的几种动画，安卓开发中还有转场动画、矢量动画、触摸反馈动画等这里没有做介绍，感兴趣的可以自己研究研究。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、视图动画（View-动画）\"><a href=\"#一、视图动画（View-动画）\" class=\"headerlink\" title=\"一、视图动画（View 动画）\"></a>一、视图动画（View 动画）</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>视图动画（View Animation）是一种在 Android 中用于为视图对象添加动画效果的机制。它允许你通过改变视图的属性值（如位置、尺寸、透明度等）来创建平滑的动画效果。</li>\n<li>视图动画的概念是基于补间动画（Tween Animation）的，在其中定义起始和结束状态，系统会在这两个状态之间自动生成过渡动画。</li>\n</ul>\n<h2 id=\"1-2-使用示例\"><a href=\"#1-2-使用示例\" class=\"headerlink\" title=\"1.2 使用示例\"></a>1.2 使用示例</h2><ul>\n<li>首先我们要知道一点，视图动画其实就是安卓为我们提供了很多继承自 Animation 的类，例如 AlphaAnimation（透明度动画）、ScaleAnimation（缩放动画）等等。使用他们就可以实现某个视图的某个属性的动态变化。</li>\n</ul>\n<h3 id=\"1-2-1-透明度动画\"><a href=\"#1-2-1-透明度动画\" class=\"headerlink\" title=\"1.2.1 透明度动画\"></a>1.2.1 透明度动画</h3><ul>\n<li>下面是一个点击按钮后将图片透明度从 100% 变成 0% 的动画：</li>\n<li><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button1.setOnClickListener &#123; </span><br><span class=\"line\">    <span class=\"comment\">//透明度动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = AlphaAnimation(<span class=\"number\">1f</span>, <span class=\"number\">0f</span>)</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>参数很简单就是从哪个透明度到哪个透明度。</li>\n</ul>\n<h3 id=\"1-2-2-旋转动画\"><a href=\"#1-2-2-旋转动画\" class=\"headerlink\" title=\"1.2.2 旋转动画\"></a>1.2.2 旋转动画</h3><ul>\n<li>点击按钮后将图片从指定位置作为圆心（默认为图片左上角），旋转指定角度的动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button2.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//旋转动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = RotateAnimation(</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        <span class=\"number\">360f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">5f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数说明：<ul>\n<li>第一个参数 0f 表示起始的旋转角度为 0 度。</li>\n<li>第二个参数 360f 表示结束时的旋转角度为 360 度，即完整的一圈。</li>\n<li>第三个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。</li>\n<li>第四个参数 0.5f 表示旋转的轴在 X 轴方向上的位置相对于视图自身宽度的比例为 0.5，即位于视图的中心点。</li>\n<li>第五个参数 Animation.RELATIVE_TO_SELF 表示旋转的轴相对于视图自身。</li>\n<li>第六个参数 0.5f 表示旋转的轴在 Y 轴方向上的位置相对于视图自身高度的比例为 0.5，即位于视图的中心点。</li>\n</ul>\n</li>\n<li>你可以直接不指定后四个参数，这样旋转的中心点默认就在图片左上角。</li>\n</ul>\n<h3 id=\"1-2-3-平移动画\"><a href=\"#1-2-3-平移动画\" class=\"headerlink\" title=\"1.2.3 平移动画\"></a>1.2.3 平移动画</h3><ul>\n<li>点击按钮后将图片从指定位置开始向指定方向做平移操作：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button3.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//平移动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = TranslateAnimation(</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">1f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数说明：<ul>\n<li>第一个参数 Animation.RELATIVE_TO_SELF 表示起始点的 X 轴坐标相对于视图自身宽度的比例（即百分比），此处为 0% </li>\n<li>第二个参数 0f 表示起始点的 X 轴坐标，此处为 0 </li>\n<li>第三个参数 Animation.RELATIVE_TO_SELF 表示结束点的 X 轴坐标相对于视图自身宽度的比例，此处为 100% </li>\n<li>第四个参数 1f 表示结束点的 X 轴坐标，此处为视图的宽度 </li>\n<li>第五个参数 Animation.RELATIVE_TO_SELF 表示起始点的 Y 轴坐标相对于视图自身高度的比例，此处为 0% </li>\n<li>第六个参数 0f 表示起始点的 Y 轴坐标，此处为 0 </li>\n<li>第七个参数 Animation.RELATIVE_TO_SELF 表示结束点的 Y 轴坐标相对于视图自身高度的比例，此处为 100% </li>\n<li>第八个参数 1f 表示结束点的 Y 轴坐标，此处为视图的高度</li>\n</ul>\n</li>\n<li>上面的参数就实现了图片平移至图片右下角的操作。还有一个常用的4个参数的构造方法，可以直接指定平移的像素即可，感兴趣的自己探索一下。</li>\n</ul>\n<h3 id=\"1-2-4-缩放动画\"><a href=\"#1-2-4-缩放动画\" class=\"headerlink\" title=\"1.2.4 缩放动画\"></a>1.2.4 缩放动画</h3><ul>\n<li>点击按钮后将以指定位置为中心点将图片进行放大或者缩小动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.button4.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">//缩放动画</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> animation = ScaleAnimation(</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        <span class=\"number\">1f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">        Animation.RELATIVE_TO_SELF,</span><br><span class=\"line\">        <span class=\"number\">0.5f</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//动画持续时间</span></span><br><span class=\"line\">    animation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\">    binding.imageView.startAnimation(animation)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数的作用和前面其实是差不多的，就不再介绍了。</li>\n</ul>\n<h3 id=\"1-2-5-动画集合和差值器\"><a href=\"#1-2-5-动画集合和差值器\" class=\"headerlink\" title=\"1.2.5 动画集合和差值器\"></a>1.2.5 动画集合和差值器</h3><ul>\n<li>如果我们要实现多个动画同时执行呢？比如一边旋转一边透明度发生变化？这时你需要用到一个动画集合类：AnimationSet。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> animationSet = AnimationSet(<span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 透明度动画</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> alphaAnimation = AlphaAnimation(<span class=\"number\">0f</span>, <span class=\"number\">1f</span>)</span><br><span class=\"line\">alphaAnimation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\"><span class=\"comment\">// 将透明度变化的动画添加进动画集合</span></span><br><span class=\"line\">animationSet.addAnimation(alphaAnimation)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缩放动画</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimation = ScaleAnimation(</span><br><span class=\"line\">    <span class=\"number\">1f</span>, <span class=\"number\">1.5f</span>, <span class=\"comment\">// X 轴方向的起始和结束比例</span></span><br><span class=\"line\">    <span class=\"number\">1f</span>, <span class=\"number\">1.5f</span>, <span class=\"comment\">// Y 轴方向的起始和结束比例</span></span><br><span class=\"line\">    Animation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span>, <span class=\"comment\">// 缩放中心点的 X 坐标，相对于自身宽度的比例</span></span><br><span class=\"line\">    Animation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span> <span class=\"comment\">// 缩放中心点的 Y 坐标，相对于自身高度的比例</span></span><br><span class=\"line\">)</span><br><span class=\"line\">scaleAnimation.duration = <span class=\"number\">2000</span></span><br><span class=\"line\"><span class=\"comment\">// 将缩放的动画添加进动画集合</span></span><br><span class=\"line\">animationSet.addAnimation(scaleAnimation)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//开始动画</span></span><br><span class=\"line\">binding.imageView.startAnimation(animationSet)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 AnimationSet 的构造函数中，传入的参数 shareInterpolator 是一个布尔值，用于指定是否共享插值器。</li>\n<li>当 shareInterpolator 设置为 true 时，表示所有添加到 AnimationSet 中的子动画都将使用相同的插值器。这意味着无论您在哪个子动画中设置插值器，都会被应用到整个 AnimationSet 中的所有子动画上。 </li>\n<li>例如，假设您将 AnimationSet 设置为 true，并且在其中添加了一个缩放动画和一个旋转动画。如果您为缩放动画设置了一个加速插值器，那么旋转动画也会使用相同的加速插值器。</li>\n<li>这里顺便介绍一下几个常用的差值器：<ol>\n<li>线性差值器（LinearInterpolator）：动画按照匀速进行，即在整个动画过程中，每个时间段内的变化量都相同。</li>\n<li>减速差值器（DecelerateInterpolator）：动画开始时较快，然后逐渐减速。 </li>\n<li>加速减速差值器（AccelerateDecelerateInterpolator）：动画开始和结束时较慢，中间阶段加速运动。 </li>\n<li>弹跳差值器（BounceInterpolator）：动画在结束时会反弹一下，形成弹跳效果。 </li>\n<li>周期差值器（CycleInterpolator）：动画按照正弦或余弦曲线进行循环运动。 </li>\n<li>反向差值器（AnticipateInterpolator）：动画开始前有一个向后的偏移，然后再开始正常的动画过程。 </li>\n<li>弹射差值器（OvershootInterpolator）：动画在结束时会超过目标值一段距离，然后再回弹到目标值。</li>\n</ol>\n</li>\n<li>使用也非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimation = ScaleAnimation(...)</span><br><span class=\"line\">scaleAnimation.interpolator = AccelerateInterpolator() <span class=\"comment\">// 设置加速差值器</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、属性动画（Property-动画）\"><a href=\"#二、属性动画（Property-动画）\" class=\"headerlink\" title=\"二、属性动画（Property 动画）\"></a>二、属性动画（Property 动画）</h1><h2 id=\"2-1-概念\"><a href=\"#2-1-概念\" class=\"headerlink\" title=\"2.1 概念\"></a>2.1 概念</h2><ul>\n<li>属性动画所提供的功能和视图动画十分相似。但两者在实现原理上完全不同，而且相对视图动画来说，属性动画要强大许多。</li>\n<li>视图动画和属性动画的对比：<ol>\n<li>视图动画： <ul>\n<li>View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。 </li>\n<li>View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。 </li>\n<li>View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。</li>\n</ul>\n</li>\n<li>属性动画：<ul>\n<li>属性动画作用对象不局限在 View 上，而是任何提供了 Getter 和 Setter 方法的对象的属性上。 </li>\n<li>属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。 </li>\n<li>属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。 </li>\n<li>属性动画上手难度较高，对于 propertyName 需要自己去挖掘，或者自己通过 Wrapper 的方式去自定义 propertyName。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-使用示例\"><a href=\"#2-2-使用示例\" class=\"headerlink\" title=\"2.2 使用示例\"></a>2.2 使用示例</h2><h3 id=\"2-2-1-透明度动画\"><a href=\"#2-2-1-透明度动画\" class=\"headerlink\" title=\"2.2.1 透明度动画\"></a>2.2.1 透明度动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建透明度动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> alphaAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>)</span><br><span class=\"line\"><span class=\"comment\">// 设置动画属性</span></span><br><span class=\"line\">alphaAnimation.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">alphaAnimation.start()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-缩放动画\"><a href=\"#2-2-2-缩放动画\" class=\"headerlink\" title=\"2.2.2 缩放动画\"></a>2.2.2 缩放动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建缩放动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleXAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;scaleX&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleYAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;scaleY&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建缩放动画集合</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scaleAnimationSet = AnimatorSet()</span><br><span class=\"line\">scaleAnimationSet.playTogether(scaleXAnimation, scaleYAnimation)</span><br><span class=\"line\">scaleAnimationSet.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">scaleAnimationSet.start()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-3-旋转动画\"><a href=\"#2-2-3-旋转动画\" class=\"headerlink\" title=\"2.2.3 旋转动画\"></a>2.2.3 旋转动画</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建旋转动画对象</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rotationAnimation = ObjectAnimator.ofFloat(view, <span class=\"string\">&quot;rotation&quot;</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>)</span><br><span class=\"line\"><span class=\"comment\">// 设置动画属性</span></span><br><span class=\"line\">rotationAnimation.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 动画时长，单位为毫秒</span></span><br><span class=\"line\">rotationAnimation.repeatCount = ValueAnimator.INFINITE <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\"><span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">rotationAnimation.start()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-小结\"><a href=\"#2-3-小结\" class=\"headerlink\" title=\"2.3 小结\"></a>2.3 小结</h2><ul>\n<li>不用举太多例子了，因为光看上面几个例子就可以发现属性动画在代码实现上和视图动画很像，并且也可以添加差值器，使用 AnimationSet 等，可以简单的认为他就是视图动画的一个增强版，我们大部分情况下只需要指定第二个参数：propertyName，就可以实现多种多样的动画效果。</li>\n<li>此外，属性动画可以使用自定义的插值器（Interpolator）来控制动画的速度变化。你可以根据需要创建不同的插值器，实现各种动画效果。</li>\n<li>属性动画还可以通过添加监听器来监听动画开始、结束、重复等事件，并在特定事件发生时执行相应的操作。视图动画没有提供类似的事件监听机制。</li>\n</ul>\n<h1 id=\"三、帧动画（Frame-动画）\"><a href=\"#三、帧动画（Frame-动画）\" class=\"headerlink\" title=\"三、帧动画（Frame 动画）\"></a>三、帧动画（Frame 动画）</h1><h2 id=\"3-1-概念\"><a href=\"#3-1-概念\" class=\"headerlink\" title=\"3.1 概念\"></a>3.1 概念</h2><ul>\n<li>帧动画（Frame Animation），也称为逐帧动画或逐帧播放动画，是一种基于一系列预定义图像帧的动画效果。它通过按照一定的时间间隔依次显示不同的图像帧来创建动画效果。</li>\n<li>帧动画通常由多个连续的静态图像组成，这些图像按照特定的顺序排列。当播放帧动画时，系统会依次显示这些图像帧，给人以连续变化的动画感觉。</li>\n</ul>\n<h2 id=\"3-2-使用示例\"><a href=\"#3-2-使用示例\" class=\"headerlink\" title=\"3.2 使用示例\"></a>3.2 使用示例</h2><ul>\n<li>在 Android 开发中，帧动画可以使用 XML 或代码来定义。您可以在 XML 文件中指定每个帧所对应的图像资源，以及每帧显示的持续时间。然后，通过加载该 XML 文件并将其设置为一个 ImageView 的背景，即可启动帧动画。</li>\n<li>以下是一个示例 XML 文件的结构，用于定义帧动画：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">&quot;@drawable/frame1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">&quot;@drawable/frame2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 其他帧 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>其中，每个 <item> 标签定义了一个图像帧。android:drawable 属性指定了该帧显示的图像资源，android:duration 属性定义了该帧显示的持续时间（以毫秒为单位）。</li>\n<li>帧动画适用于简单的、预先确定的动画效果，例如循环播放的加载动画、简单的图标动画等。然而，相对于属性动画和视图动画，它的灵活性较低，不能实现复杂的动画交互效果。</li>\n<li>同时，大多数场景下，其实帧动画可以直接用一个 GIF 图片进行替代，加上同时加载大量图片资源还可能导致 OOM，所以实际开发中使用得比较少。</li>\n</ul>\n<h1 id=\"四、揭露动画（Reveal-动画）\"><a href=\"#四、揭露动画（Reveal-动画）\" class=\"headerlink\" title=\"四、揭露动画（Reveal 动画）\"></a>四、揭露动画（Reveal 动画）</h1><h2 id=\"4-1-概念\"><a href=\"#4-1-概念\" class=\"headerlink\" title=\"4.1 概念\"></a>4.1 概念</h2><ul>\n<li>揭露动画（Reveal 动画）是我写博客的时候查资料看到的，就临时加进来了，之前我其实是没听过这个动画的，不过看到动画演示后我发现这种动画其实还挺常见的。</li>\n<li>揭露动画是一种视觉效果，它可以通过从屏幕的一个点开始扩散出去的方式，将一个视图或布局揭示出来，具有很好的用户体验和交互效果。</li>\n</ul>\n<h2 id=\"4-2-使用示例\"><a href=\"#4-2-使用示例\" class=\"headerlink\" title=\"4.2 使用示例\"></a>4.2 使用示例</h2><ul>\n<li>下面是一个圆形揭露动画的效果，通过 ViewAnimationUtils.createCircularReveal() 就可以创建这样一个揭露动画：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.imageView.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算揭露动画的起始点和结束点</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> cx = binding.imageView.width / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> cy = binding.imageView.height / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\">// hypot 函数用于计算揭露动画的最大半径</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> endRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建揭露动画对象</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> anim = ViewAnimationUtils.createCircularReveal(binding.imageView, cx, cy, <span class=\"number\">0f</span>, endRadius)</span><br><span class=\"line\">    anim.duration = <span class=\"number\">1000</span> <span class=\"comment\">// 设置动画持续时间</span></span><br><span class=\"line\">    anim.start() <span class=\"comment\">// 启动揭露动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><ul>\n<li>以上就是安卓开发中几个比较常用的动画了，主要是用于某个控件的动态变化效果。</li>\n<li>除了上面介绍的几种动画，安卓开发中还有转场动画、矢量动画、触摸反馈动画等这里没有做介绍，感兴趣的可以自己研究研究。</li>\n</ul>\n"},{"title":"拆分成最多数目的正偶数之和","date":"2023-07-06T00:00:00.000Z","description":"贪心算法入门题目 - 拆分成最多数目的正偶数之和","cover":"https://raw.githubusercontent.com/leihaogit/image-host/main/o47s96.jpg","_content":"\n# 一、题目\n\n给你一个整数 `finalSum`。请你将它拆分成若干个`互不相同`的正偶数之和，且拆分出来的正偶数数目`最多`。\n\n比方说，给你 `finalSum = 12`，那么这些拆分是`符合要求`的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意`finalSum`不能拆分成`(2 + 2 + 4 + 4)`，因为拆分出来的整数必须互不相同。\n请你返回一个整数数组，表示将整数拆分成`最多`数目的正偶数数组。如果没有办法将`finalSum`进行拆分，请你返回一个`空`数组。你可以按`任意`顺序返回这些整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/maximum-split-of-positive-even-integers\n\n# 二、思路\n\n## 2.1 贪心算法\n\n- 为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图`当前最优`的选择，即局部最优解，而`不考虑`该选择对后续步骤的影响。\n- 举个非常简单的例子：假设现在有`4`张钞票：1元、5元、10元和20元，现在允许你每次拿`1`张，最多拿`2`张，你会怎么拿才能让自己得到最多的钱？\n- 一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：`贪图当前最优`。\n\n## 2.2 确定算法\n\n- 回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？\n- 对于贪心算法，我们需要知道一点：`不保证最优解`，什么意思？大白话说就是可能得到的答案是`错误的`！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。\n- 一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：\n  1. 问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。\n  2. 问题的子问题相互独立：当前的选择不会影响后续的选择。\n- 来看本题目：\n  1. 要拆分 finalSum，并取得`最大`的拆分数目，并且拆分出来的偶数`互不相同`。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了`问题具有贪心选择性质`的特点。\n  2. 当前的选择也并不会影响之后的选择，满足了`问题的子问题相互独立`的特点。所以自然而然，我们想到了使用贪心算法进行求解。\n\n# 三、详细算法\n\n## 3.1 算法分析\n\n- 前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。\n  1. 从`最小的偶整数2`开始依次尝试拆分，直到剩余的数值`小于等于`当前被拆分的`最大偶整数`为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。\n  2. 如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。\n- 还是举个例子可能会更清楚一点。比如拿`32`来拆分。\n  1. 取 `2`，此时 finalSum = 30    `ans = [2]`\n  2. 取 `4`，此时 finalSum = 26    `ans = [2,4]`\n  3. 取 `6`，此时 finalSum = 20    `ans = [2,4,6]`\n  4. 取 `8`，此时 finalSum = 12    `ans = [2,4,6,8]`\n  5. 取 `10`，此时 finalSum = 2    `ans = [2,4,6,8,10]` \n  6. 这时，能取的最小偶数已经比剩下的数还大了`(10 > 2)`，自然已经无法进行拆分了，最后将剩下的`2`加在当前的最大值`10`上面，这样可以保证结果不重复。\n  7. 最终我们得到了正确结果(之一)：`[2,4,6,8,12]`\n\n## 3.2 详细题解\n\n```java\nclass Solution {\n    public List<Long> maximumEvenSplit(long finalSum) {\n        //结果集合，用来保存最终结果\n        List<Long> ans = new ArrayList<>();\n        //如果不是偶数，不能被拆分，返回空集合\n        if (finalSum % 2 != 0) {\n            return ans;\n        }\n        //开始遍历，每次将 i 加2\n        for(long i = 2;i <= finalSum;i += 2){\n            //将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合\n            ans.add(i);\n            //finalSum 减去 i\n            finalSum -= i;\n            //如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复\n            //比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i >= finalSum（8） 了，将 8 加到上一个结果中\n            //最终结果变为：2，4，6，8 + 8  即 2，4，6，16\n            if(i >= finalSum){\n                //由于前面已经将 i 放入了集合，主要更改最后放入的值\n                ans.set(ans.size() - 1,finalSum += ans.get(ans.size() - 1));\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 四、总结\n\n- 看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。\n- 贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。\n- 对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。","source":"_posts/贪心_01_拆分成最多数目的正偶数之和.md","raw":"---\ntitle: '拆分成最多数目的正偶数之和'\ndate: '2023-07-06'\ndescription: '贪心算法入门题目 - 拆分成最多数目的正偶数之和'\ncover: 'https://raw.githubusercontent.com/leihaogit/image-host/main/o47s96.jpg'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 贪心\n\n---\n\n# 一、题目\n\n给你一个整数 `finalSum`。请你将它拆分成若干个`互不相同`的正偶数之和，且拆分出来的正偶数数目`最多`。\n\n比方说，给你 `finalSum = 12`，那么这些拆分是`符合要求`的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意`finalSum`不能拆分成`(2 + 2 + 4 + 4)`，因为拆分出来的整数必须互不相同。\n请你返回一个整数数组，表示将整数拆分成`最多`数目的正偶数数组。如果没有办法将`finalSum`进行拆分，请你返回一个`空`数组。你可以按`任意`顺序返回这些整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/maximum-split-of-positive-even-integers\n\n# 二、思路\n\n## 2.1 贪心算法\n\n- 为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图`当前最优`的选择，即局部最优解，而`不考虑`该选择对后续步骤的影响。\n- 举个非常简单的例子：假设现在有`4`张钞票：1元、5元、10元和20元，现在允许你每次拿`1`张，最多拿`2`张，你会怎么拿才能让自己得到最多的钱？\n- 一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：`贪图当前最优`。\n\n## 2.2 确定算法\n\n- 回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？\n- 对于贪心算法，我们需要知道一点：`不保证最优解`，什么意思？大白话说就是可能得到的答案是`错误的`！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。\n- 一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：\n  1. 问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。\n  2. 问题的子问题相互独立：当前的选择不会影响后续的选择。\n- 来看本题目：\n  1. 要拆分 finalSum，并取得`最大`的拆分数目，并且拆分出来的偶数`互不相同`。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了`问题具有贪心选择性质`的特点。\n  2. 当前的选择也并不会影响之后的选择，满足了`问题的子问题相互独立`的特点。所以自然而然，我们想到了使用贪心算法进行求解。\n\n# 三、详细算法\n\n## 3.1 算法分析\n\n- 前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。\n  1. 从`最小的偶整数2`开始依次尝试拆分，直到剩余的数值`小于等于`当前被拆分的`最大偶整数`为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。\n  2. 如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。\n- 还是举个例子可能会更清楚一点。比如拿`32`来拆分。\n  1. 取 `2`，此时 finalSum = 30    `ans = [2]`\n  2. 取 `4`，此时 finalSum = 26    `ans = [2,4]`\n  3. 取 `6`，此时 finalSum = 20    `ans = [2,4,6]`\n  4. 取 `8`，此时 finalSum = 12    `ans = [2,4,6,8]`\n  5. 取 `10`，此时 finalSum = 2    `ans = [2,4,6,8,10]` \n  6. 这时，能取的最小偶数已经比剩下的数还大了`(10 > 2)`，自然已经无法进行拆分了，最后将剩下的`2`加在当前的最大值`10`上面，这样可以保证结果不重复。\n  7. 最终我们得到了正确结果(之一)：`[2,4,6,8,12]`\n\n## 3.2 详细题解\n\n```java\nclass Solution {\n    public List<Long> maximumEvenSplit(long finalSum) {\n        //结果集合，用来保存最终结果\n        List<Long> ans = new ArrayList<>();\n        //如果不是偶数，不能被拆分，返回空集合\n        if (finalSum % 2 != 0) {\n            return ans;\n        }\n        //开始遍历，每次将 i 加2\n        for(long i = 2;i <= finalSum;i += 2){\n            //将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合\n            ans.add(i);\n            //finalSum 减去 i\n            finalSum -= i;\n            //如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复\n            //比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i >= finalSum（8） 了，将 8 加到上一个结果中\n            //最终结果变为：2，4，6，8 + 8  即 2，4，6，16\n            if(i >= finalSum){\n                //由于前面已经将 i 放入了集合，主要更改最后放入的值\n                ans.set(ans.size() - 1,finalSum += ans.get(ans.size() - 1));\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 四、总结\n\n- 看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。\n- 贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。\n- 对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。","slug":"贪心_01_拆分成最多数目的正偶数之和","published":1,"updated":"2023-09-25T06:50:31.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5j001827hoh8wxer4o","content":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你一个整数 <code>finalSum</code>。请你将它拆分成若干个<code>互不相同</code>的正偶数之和，且拆分出来的正偶数数目<code>最多</code>。</p>\n<p>比方说，给你 <code>finalSum = 12</code>，那么这些拆分是<code>符合要求</code>的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意<code>finalSum</code>不能拆分成<code>(2 + 2 + 4 + 4)</code>，因为拆分出来的整数必须互不相同。<br>请你返回一个整数数组，表示将整数拆分成<code>最多</code>数目的正偶数数组。如果没有办法将<code>finalSum</code>进行拆分，请你返回一个<code>空</code>数组。你可以按<code>任意</code>顺序返回这些整数。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/maximum-split-of-positive-even-integers\">https://leetcode.cn/problems/maximum-split-of-positive-even-integers</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-贪心算法\"><a href=\"#2-1-贪心算法\" class=\"headerlink\" title=\"2.1 贪心算法\"></a>2.1 贪心算法</h2><ul>\n<li>为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图<code>当前最优</code>的选择，即局部最优解，而<code>不考虑</code>该选择对后续步骤的影响。</li>\n<li>举个非常简单的例子：假设现在有<code>4</code>张钞票：1元、5元、10元和20元，现在允许你每次拿<code>1</code>张，最多拿<code>2</code>张，你会怎么拿才能让自己得到最多的钱？</li>\n<li>一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：<code>贪图当前最优</code>。</li>\n</ul>\n<h2 id=\"2-2-确定算法\"><a href=\"#2-2-确定算法\" class=\"headerlink\" title=\"2.2 确定算法\"></a>2.2 确定算法</h2><ul>\n<li>回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？</li>\n<li>对于贪心算法，我们需要知道一点：<code>不保证最优解</code>，什么意思？大白话说就是可能得到的答案是<code>错误的</code>！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。</li>\n<li>一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：<ol>\n<li>问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。</li>\n<li>问题的子问题相互独立：当前的选择不会影响后续的选择。</li>\n</ol>\n</li>\n<li>来看本题目：<ol>\n<li>要拆分 finalSum，并取得<code>最大</code>的拆分数目，并且拆分出来的偶数<code>互不相同</code>。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了<code>问题具有贪心选择性质</code>的特点。</li>\n<li>当前的选择也并不会影响之后的选择，满足了<code>问题的子问题相互独立</code>的特点。所以自然而然，我们想到了使用贪心算法进行求解。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、详细算法\"><a href=\"#三、详细算法\" class=\"headerlink\" title=\"三、详细算法\"></a>三、详细算法</h1><h2 id=\"3-1-算法分析\"><a href=\"#3-1-算法分析\" class=\"headerlink\" title=\"3.1 算法分析\"></a>3.1 算法分析</h2><ul>\n<li>前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。<ol>\n<li>从<code>最小的偶整数2</code>开始依次尝试拆分，直到剩余的数值<code>小于等于</code>当前被拆分的<code>最大偶整数</code>为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。</li>\n<li>如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。</li>\n</ol>\n</li>\n<li>还是举个例子可能会更清楚一点。比如拿<code>32</code>来拆分。<ol>\n<li>取 <code>2</code>，此时 finalSum = 30    <code>ans = [2]</code></li>\n<li>取 <code>4</code>，此时 finalSum = 26    <code>ans = [2,4]</code></li>\n<li>取 <code>6</code>，此时 finalSum = 20    <code>ans = [2,4,6]</code></li>\n<li>取 <code>8</code>，此时 finalSum = 12    <code>ans = [2,4,6,8]</code></li>\n<li>取 <code>10</code>，此时 finalSum = 2    <code>ans = [2,4,6,8,10]</code> </li>\n<li>这时，能取的最小偶数已经比剩下的数还大了<code>(10 &gt; 2)</code>，自然已经无法进行拆分了，最后将剩下的<code>2</code>加在当前的最大值<code>10</code>上面，这样可以保证结果不重复。</li>\n<li>最终我们得到了正确结果(之一)：<code>[2,4,6,8,12]</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-详细题解\"><a href=\"#3-2-详细题解\" class=\"headerlink\" title=\"3.2 详细题解\"></a>3.2 详细题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">maximumEvenSplit</span><span class=\"params\">(<span class=\"type\">long</span> finalSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//结果集合，用来保存最终结果</span></span><br><span class=\"line\">        List&lt;Long&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//如果不是偶数，不能被拆分，返回空集合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalSum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开始遍历，每次将 i 加2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;i &lt;= finalSum;i += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合</span></span><br><span class=\"line\">            ans.add(i);</span><br><span class=\"line\">            <span class=\"comment\">//finalSum 减去 i</span></span><br><span class=\"line\">            finalSum -= i;</span><br><span class=\"line\">            <span class=\"comment\">//如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复</span></span><br><span class=\"line\">            <span class=\"comment\">//比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i &gt;= finalSum（8） 了，将 8 加到上一个结果中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终结果变为：2，4，6，8 + 8  即 2，4，6，16</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= finalSum)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//由于前面已经将 i 放入了集合，主要更改最后放入的值</span></span><br><span class=\"line\">                ans.set(ans.size() - <span class=\"number\">1</span>,finalSum += ans.get(ans.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。</li>\n<li>贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。</li>\n<li>对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你一个整数 <code>finalSum</code>。请你将它拆分成若干个<code>互不相同</code>的正偶数之和，且拆分出来的正偶数数目<code>最多</code>。</p>\n<p>比方说，给你 <code>finalSum = 12</code>，那么这些拆分是<code>符合要求</code>的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意<code>finalSum</code>不能拆分成<code>(2 + 2 + 4 + 4)</code>，因为拆分出来的整数必须互不相同。<br>请你返回一个整数数组，表示将整数拆分成<code>最多</code>数目的正偶数数组。如果没有办法将<code>finalSum</code>进行拆分，请你返回一个<code>空</code>数组。你可以按<code>任意</code>顺序返回这些整数。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/maximum-split-of-positive-even-integers\">https://leetcode.cn/problems/maximum-split-of-positive-even-integers</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-贪心算法\"><a href=\"#2-1-贪心算法\" class=\"headerlink\" title=\"2.1 贪心算法\"></a>2.1 贪心算法</h2><ul>\n<li>为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图<code>当前最优</code>的选择，即局部最优解，而<code>不考虑</code>该选择对后续步骤的影响。</li>\n<li>举个非常简单的例子：假设现在有<code>4</code>张钞票：1元、5元、10元和20元，现在允许你每次拿<code>1</code>张，最多拿<code>2</code>张，你会怎么拿才能让自己得到最多的钱？</li>\n<li>一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：<code>贪图当前最优</code>。</li>\n</ul>\n<h2 id=\"2-2-确定算法\"><a href=\"#2-2-确定算法\" class=\"headerlink\" title=\"2.2 确定算法\"></a>2.2 确定算法</h2><ul>\n<li>回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？</li>\n<li>对于贪心算法，我们需要知道一点：<code>不保证最优解</code>，什么意思？大白话说就是可能得到的答案是<code>错误的</code>！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。</li>\n<li>一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：<ol>\n<li>问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。</li>\n<li>问题的子问题相互独立：当前的选择不会影响后续的选择。</li>\n</ol>\n</li>\n<li>来看本题目：<ol>\n<li>要拆分 finalSum，并取得<code>最大</code>的拆分数目，并且拆分出来的偶数<code>互不相同</code>。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了<code>问题具有贪心选择性质</code>的特点。</li>\n<li>当前的选择也并不会影响之后的选择，满足了<code>问题的子问题相互独立</code>的特点。所以自然而然，我们想到了使用贪心算法进行求解。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、详细算法\"><a href=\"#三、详细算法\" class=\"headerlink\" title=\"三、详细算法\"></a>三、详细算法</h1><h2 id=\"3-1-算法分析\"><a href=\"#3-1-算法分析\" class=\"headerlink\" title=\"3.1 算法分析\"></a>3.1 算法分析</h2><ul>\n<li>前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。<ol>\n<li>从<code>最小的偶整数2</code>开始依次尝试拆分，直到剩余的数值<code>小于等于</code>当前被拆分的<code>最大偶整数</code>为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。</li>\n<li>如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。</li>\n</ol>\n</li>\n<li>还是举个例子可能会更清楚一点。比如拿<code>32</code>来拆分。<ol>\n<li>取 <code>2</code>，此时 finalSum = 30    <code>ans = [2]</code></li>\n<li>取 <code>4</code>，此时 finalSum = 26    <code>ans = [2,4]</code></li>\n<li>取 <code>6</code>，此时 finalSum = 20    <code>ans = [2,4,6]</code></li>\n<li>取 <code>8</code>，此时 finalSum = 12    <code>ans = [2,4,6,8]</code></li>\n<li>取 <code>10</code>，此时 finalSum = 2    <code>ans = [2,4,6,8,10]</code> </li>\n<li>这时，能取的最小偶数已经比剩下的数还大了<code>(10 &gt; 2)</code>，自然已经无法进行拆分了，最后将剩下的<code>2</code>加在当前的最大值<code>10</code>上面，这样可以保证结果不重复。</li>\n<li>最终我们得到了正确结果(之一)：<code>[2,4,6,8,12]</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-详细题解\"><a href=\"#3-2-详细题解\" class=\"headerlink\" title=\"3.2 详细题解\"></a>3.2 详细题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">maximumEvenSplit</span><span class=\"params\">(<span class=\"type\">long</span> finalSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//结果集合，用来保存最终结果</span></span><br><span class=\"line\">        List&lt;Long&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//如果不是偶数，不能被拆分，返回空集合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalSum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开始遍历，每次将 i 加2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;i &lt;= finalSum;i += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合</span></span><br><span class=\"line\">            ans.add(i);</span><br><span class=\"line\">            <span class=\"comment\">//finalSum 减去 i</span></span><br><span class=\"line\">            finalSum -= i;</span><br><span class=\"line\">            <span class=\"comment\">//如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复</span></span><br><span class=\"line\">            <span class=\"comment\">//比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i &gt;= finalSum（8） 了，将 8 加到上一个结果中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终结果变为：2，4，6，8 + 8  即 2，4，6，16</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= finalSum)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//由于前面已经将 i 放入了集合，主要更改最后放入的值</span></span><br><span class=\"line\">                ans.set(ans.size() - <span class=\"number\">1</span>,finalSum += ans.get(ans.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。</li>\n<li>贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。</li>\n<li>对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。</li>\n</ul>\n"},{"title":"相交链表","date":"2023-04-08T00:00:00.000Z","description":"一个有意思的链表相关算法题目 - 相交链表","cover":"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png","_content":"\n# 一、题目\n\n给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n\n图示两个链表在节点 c1 开始相交：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n题目数据保证整个链式结构中不存在环。\n注意，函数返回结果后，链表必须保持其原始结构。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/intersection-of-two-linked-lists\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么样的算法来求解此题。\n\n### 2.1.1 哈希集合\n\n- 我第一眼看到这个题目的时候，想到的是使用**哈希集合**来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。\n- 然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：\n    1. 如果当前节点不在哈希集合中，则继续遍历下一个节点；\n    2. 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。\n\n- 如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。\n\n上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。\n\n### 2.1.2 双指针\n\n- 今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。\n- 有些同学可能不知道双指针是啥，或者还是第一次听到**指针**这个概念。\n    - 指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。\n- 学过C语言的都知道，指针是个相对麻烦的东西。但是**双指针**中的'指针'并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）\n    - 使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。\n    - 一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。\n\n举个例子可能更有利于理解，下面是一个使用双指针技巧[判断字符串是否为回文字符串](https://leetcode.cn/problems/valid-palindrome/)的算法：\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        StringBuffer sgood = new StringBuffer();\n        int length = s.length();\n        for (int i = 0; i < length; i++) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) {\n                sgood.append(Character.toLowerCase(ch));\n            }\n        }\n        int n = sgood.length();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n}\n```\n\n## 2.2 算法分析\n\n可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。\n\n### 2.2.1 定义指针\n\n- 再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n- 我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们**保持原始的链表结构！** 所以不建议直接使用链表的头结点。\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        ListNode pA = headA;\n        ListNode pB = headB;\n        /*  省略  */\n    }\n}\n```\n\n### 2.2.2 核心算法\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        /*  省略  */\n    }\n}\n```\n\n- 上面的代码就是整个算法的灵魂，解释一下：\n- pA = pA == null ? headB : pA.next;\n    - 这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。\n- pB = pB == null ? headA : pB.next;\n    - 这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。\n\n  自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。\n\n### 2.2.3 思路总结\n\n- Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：\n\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png\">\n\n- 做个大白话分析：\n    1. 首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；\n    2. 然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；\n    3. 如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；\n    4. 如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和\n       pB 相遇时，它们所遍历的路程长度相等；\n    5. 最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA\n       遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB\n       相遇为止，此时它们指向的节点就是链表的交点。\n\n  时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {//排除特殊情况\n            return null;\n        }\n        ListNode pA = headA, pB = headB;//定义双指针\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;//return pB当然也一样，并且不会漏掉为null的情况\n    }\n}\n```\n\n# 四、总结\n\n- 我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种\" 我去！还能这样！\"的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。","source":"_posts/链表_01_相交链表.md","raw":"---\ntitle: '相交链表'\ndate: '2023-04-08'\ndescription: '一个有意思的链表相关算法题目 - 相交链表'\ncover: 'https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 链表\n- 双指针\n\n---\n\n# 一、题目\n\n给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n\n图示两个链表在节点 c1 开始相交：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n题目数据保证整个链式结构中不存在环。\n注意，函数返回结果后，链表必须保持其原始结构。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/intersection-of-two-linked-lists\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么样的算法来求解此题。\n\n### 2.1.1 哈希集合\n\n- 我第一眼看到这个题目的时候，想到的是使用**哈希集合**来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。\n- 然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：\n    1. 如果当前节点不在哈希集合中，则继续遍历下一个节点；\n    2. 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。\n\n- 如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。\n\n上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。\n\n### 2.1.2 双指针\n\n- 今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。\n- 有些同学可能不知道双指针是啥，或者还是第一次听到**指针**这个概念。\n    - 指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。\n- 学过C语言的都知道，指针是个相对麻烦的东西。但是**双指针**中的'指针'并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）\n    - 使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。\n    - 一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。\n\n举个例子可能更有利于理解，下面是一个使用双指针技巧[判断字符串是否为回文字符串](https://leetcode.cn/problems/valid-palindrome/)的算法：\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        StringBuffer sgood = new StringBuffer();\n        int length = s.length();\n        for (int i = 0; i < length; i++) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) {\n                sgood.append(Character.toLowerCase(ch));\n            }\n        }\n        int n = sgood.length();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n}\n```\n\n## 2.2 算法分析\n\n可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。\n\n### 2.2.1 定义指针\n\n- 再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n- 我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们**保持原始的链表结构！** 所以不建议直接使用链表的头结点。\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        ListNode pA = headA;\n        ListNode pB = headB;\n        /*  省略  */\n    }\n}\n```\n\n### 2.2.2 核心算法\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        /*  省略  */\n    }\n}\n```\n\n- 上面的代码就是整个算法的灵魂，解释一下：\n- pA = pA == null ? headB : pA.next;\n    - 这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。\n- pB = pB == null ? headA : pB.next;\n    - 这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。\n\n  自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。\n\n### 2.2.3 思路总结\n\n- Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：\n\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png\">\n\n- 做个大白话分析：\n    1. 首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；\n    2. 然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；\n    3. 如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；\n    4. 如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和\n       pB 相遇时，它们所遍历的路程长度相等；\n    5. 最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA\n       遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB\n       相遇为止，此时它们指向的节点就是链表的交点。\n\n  时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {//排除特殊情况\n            return null;\n        }\n        ListNode pA = headA, pB = headB;//定义双指针\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;//return pB当然也一样，并且不会漏掉为null的情况\n    }\n}\n```\n\n# 四、总结\n\n- 我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种\" 我去！还能这样！\"的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。","slug":"链表_01_相交链表","published":1,"updated":"2023-09-25T07:10:09.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmynji5j001a27hoaf5b04ne","content":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n<p>题目数据保证整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须保持其原始结构。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists\">https://leetcode.cn/problems/intersection-of-two-linked-lists</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么样的算法来求解此题。</p>\n<h3 id=\"2-1-1-哈希集合\"><a href=\"#2-1-1-哈希集合\" class=\"headerlink\" title=\"2.1.1 哈希集合\"></a>2.1.1 哈希集合</h3><ul>\n<li><p>我第一眼看到这个题目的时候，想到的是使用<strong>哈希集合</strong>来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。</p>\n</li>\n<li><p>然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：</p>\n<ol>\n<li>如果当前节点不在哈希集合中，则继续遍历下一个节点；</li>\n<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。</li>\n</ol>\n</li>\n<li><p>如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。</p>\n</li>\n</ul>\n<p>上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。</p>\n<h3 id=\"2-1-2-双指针\"><a href=\"#2-1-2-双指针\" class=\"headerlink\" title=\"2.1.2 双指针\"></a>2.1.2 双指针</h3><ul>\n<li>今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。</li>\n<li>有些同学可能不知道双指针是啥，或者还是第一次听到<strong>指针</strong>这个概念。<ul>\n<li>指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。</li>\n</ul>\n</li>\n<li>学过C语言的都知道，指针是个相对麻烦的东西。但是<strong>双指针</strong>中的’指针’并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）<ul>\n<li>使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。</li>\n<li>一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子可能更有利于理解，下面是一个使用双指针技巧<a href=\"https://leetcode.cn/problems/valid-palindrome/\">判断字符串是否为回文字符串</a>的算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">sgood</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class=\"line\">                sgood.append(Character.toLowerCase(ch));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sgood.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++left;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。</p>\n<h3 id=\"2-2-1-定义指针\"><a href=\"#2-2-1-定义指针\" class=\"headerlink\" title=\"2.2.1 定义指针\"></a>2.2.1 定义指针</h3><ul>\n<li>再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</li>\n<li>我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们<strong>保持原始的链表结构！</strong> 所以不建议直接使用链表的头结点。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pB</span> <span class=\"operator\">=</span> headB;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-核心算法\"><a href=\"#2-2-2-核心算法\" class=\"headerlink\" title=\"2.2.2 核心算法\"></a>2.2.2 核心算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面的代码就是整个算法的灵魂，解释一下：</p>\n</li>\n<li><p>pA = pA == null ? headB : pA.next;</p>\n<ul>\n<li>这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。</li>\n</ul>\n</li>\n<li><p>pB = pB == null ? headA : pB.next;</p>\n<ul>\n<li>这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。</li>\n</ul>\n<p>自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-3-思路总结\"><a href=\"#2-2-3-思路总结\" class=\"headerlink\" title=\"2.2.3 思路总结\"></a>2.2.3 思路总结</h3><ul>\n<li>Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png\">\n\n<ul>\n<li><p>做个大白话分析：</p>\n<ol>\n<li>首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；</li>\n<li>然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；</li>\n<li>如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；</li>\n<li>如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和<br>pB 相遇时，它们所遍历的路程长度相等；</li>\n<li>最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA<br>遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB<br>相遇为止，此时它们指向的节点就是链表的交点。</li>\n</ol>\n<p>时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。</p>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">null</span> || headB == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA, pB = headB;<span class=\"comment\">//定义双指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pA;<span class=\"comment\">//return pB当然也一样，并且不会漏掉为null的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种” 我去！还能这样！”的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n<p>题目数据保证整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须保持其原始结构。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists\">https://leetcode.cn/problems/intersection-of-two-linked-lists</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么样的算法来求解此题。</p>\n<h3 id=\"2-1-1-哈希集合\"><a href=\"#2-1-1-哈希集合\" class=\"headerlink\" title=\"2.1.1 哈希集合\"></a>2.1.1 哈希集合</h3><ul>\n<li><p>我第一眼看到这个题目的时候，想到的是使用<strong>哈希集合</strong>来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。</p>\n</li>\n<li><p>然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：</p>\n<ol>\n<li>如果当前节点不在哈希集合中，则继续遍历下一个节点；</li>\n<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。</li>\n</ol>\n</li>\n<li><p>如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。</p>\n</li>\n</ul>\n<p>上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。</p>\n<h3 id=\"2-1-2-双指针\"><a href=\"#2-1-2-双指针\" class=\"headerlink\" title=\"2.1.2 双指针\"></a>2.1.2 双指针</h3><ul>\n<li>今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。</li>\n<li>有些同学可能不知道双指针是啥，或者还是第一次听到<strong>指针</strong>这个概念。<ul>\n<li>指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。</li>\n</ul>\n</li>\n<li>学过C语言的都知道，指针是个相对麻烦的东西。但是<strong>双指针</strong>中的’指针’并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）<ul>\n<li>使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。</li>\n<li>一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子可能更有利于理解，下面是一个使用双指针技巧<a href=\"https://leetcode.cn/problems/valid-palindrome/\">判断字符串是否为回文字符串</a>的算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">sgood</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class=\"line\">                sgood.append(Character.toLowerCase(ch));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sgood.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++left;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。</p>\n<h3 id=\"2-2-1-定义指针\"><a href=\"#2-2-1-定义指针\" class=\"headerlink\" title=\"2.2.1 定义指针\"></a>2.2.1 定义指针</h3><ul>\n<li>再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</li>\n<li>我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们<strong>保持原始的链表结构！</strong> 所以不建议直接使用链表的头结点。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pB</span> <span class=\"operator\">=</span> headB;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-核心算法\"><a href=\"#2-2-2-核心算法\" class=\"headerlink\" title=\"2.2.2 核心算法\"></a>2.2.2 核心算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面的代码就是整个算法的灵魂，解释一下：</p>\n</li>\n<li><p>pA = pA == null ? headB : pA.next;</p>\n<ul>\n<li>这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。</li>\n</ul>\n</li>\n<li><p>pB = pB == null ? headA : pB.next;</p>\n<ul>\n<li>这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。</li>\n</ul>\n<p>自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-3-思路总结\"><a href=\"#2-2-3-思路总结\" class=\"headerlink\" title=\"2.2.3 思路总结\"></a>2.2.3 思路总结</h3><ul>\n<li>Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/leihaogit/image-host/main/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png\">\n\n<ul>\n<li><p>做个大白话分析：</p>\n<ol>\n<li>首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；</li>\n<li>然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；</li>\n<li>如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；</li>\n<li>如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和<br>pB 相遇时，它们所遍历的路程长度相等；</li>\n<li>最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA<br>遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB<br>相遇为止，此时它们指向的节点就是链表的交点。</li>\n</ol>\n<p>时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。</p>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">null</span> || headB == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA, pB = headB;<span class=\"comment\">//定义双指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pA;<span class=\"comment\">//return pB当然也一样，并且不会漏掉为null的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种” 我去！还能这样！”的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clmynji54000827ho9as8023a","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji58000f27hodpkd1jmy"},{"post_id":"clmynji4w000127hoge2vc7rd","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5a000j27ho3szu0b1u"},{"post_id":"clmynji55000927ho0bzp41wr","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5b000l27ho81vz4up1"},{"post_id":"clmynji4z000327hogtlp8z7l","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5c000p27ho8xs516ga"},{"post_id":"clmynji53000727ho3orq721x","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5d000r27ho8adibqfr"},{"post_id":"clmynji5a000k27ho8gup2fmb","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5f000v27ho6ia917sp"},{"post_id":"clmynji5b000o27hogi39fh5e","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5g000y27hohige49oi"},{"post_id":"clmynji57000d27hoel2febn9","category_id":"clmynji5b000m27ho9erx5rlo","_id":"clmynji5h001327ho34b00f90"},{"post_id":"clmynji5d000q27hobs2263m1","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5i001627ho8dk3dlyj"},{"post_id":"clmynji5e000u27hohawn5gko","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5j001927hobgsb6s4w"},{"post_id":"clmynji58000e27ho9tbd4vak","category_id":"clmynji5b000m27ho9erx5rlo","_id":"clmynji5k001b27ho74jx934z"},{"post_id":"clmynji5g000x27hohvw2bya9","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5k001d27ho9jh59mmu"},{"post_id":"clmynji5h001227ho9fivc3bt","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5l001f27ho8t24fm7q"},{"post_id":"clmynji59000i27ho2vv86h78","category_id":"clmynji5g000z27ho200s7qdf","_id":"clmynji5l001i27ho3sjcg5xv"},{"post_id":"clmynji5i001527hoezbg9eeq","category_id":"clmynji51000427ho5tp03wrb","_id":"clmynji5l001k27hobpdm1e7e"},{"post_id":"clmynji5j001827hoh8wxer4o","category_id":"clmynji5b000m27ho9erx5rlo","_id":"clmynji5l001m27hoc9e04gx6"},{"post_id":"clmynji5j001a27hoaf5b04ne","category_id":"clmynji5b000m27ho9erx5rlo","_id":"clmynji5m001n27hoc42v59ks"}],"PostTag":[{"post_id":"clmynji4w000127hoge2vc7rd","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji57000c27ho9vzi3u01"},{"post_id":"clmynji4z000327hogtlp8z7l","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5f000w27ho9d6y9lc2"},{"post_id":"clmynji4z000327hogtlp8z7l","tag_id":"clmynji59000h27hogs0pfzoc","_id":"clmynji5h001027hoc0s0bahg"},{"post_id":"clmynji4z000327hogtlp8z7l","tag_id":"clmynji5b000n27hoaljy43q8","_id":"clmynji5i001427ho3a4ggijk"},{"post_id":"clmynji53000727ho3orq721x","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5l001e27ho1lyif1qy"},{"post_id":"clmynji53000727ho3orq721x","tag_id":"clmynji59000h27hogs0pfzoc","_id":"clmynji5l001g27ho6cq05vss"},{"post_id":"clmynji53000727ho3orq721x","tag_id":"clmynji5b000n27hoaljy43q8","_id":"clmynji5l001j27hoc6oi3wa4"},{"post_id":"clmynji54000827ho9as8023a","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5m001p27ho4tdi9ia6"},{"post_id":"clmynji54000827ho9as8023a","tag_id":"clmynji59000h27hogs0pfzoc","_id":"clmynji5m001q27ho70a30v2i"},{"post_id":"clmynji54000827ho9as8023a","tag_id":"clmynji5b000n27hoaljy43q8","_id":"clmynji5m001s27hofvdne64g"},{"post_id":"clmynji55000927ho0bzp41wr","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5n001v27hogddc8p7y"},{"post_id":"clmynji55000927ho0bzp41wr","tag_id":"clmynji59000h27hogs0pfzoc","_id":"clmynji5n001w27hof4kvf1b3"},{"post_id":"clmynji55000927ho0bzp41wr","tag_id":"clmynji5b000n27hoaljy43q8","_id":"clmynji5n001y27hoa05d2wok"},{"post_id":"clmynji57000d27hoel2febn9","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5o002027hoanrv6jsl"},{"post_id":"clmynji57000d27hoel2febn9","tag_id":"clmynji5n001u27ho765wfms7","_id":"clmynji5o002127ho4p25e8q6"},{"post_id":"clmynji57000d27hoel2febn9","tag_id":"clmynji5n001x27hoahcl4gv8","_id":"clmynji5o002327hobvig98o7"},{"post_id":"clmynji58000e27ho9tbd4vak","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5o002527hodo7shija"},{"post_id":"clmynji58000e27ho9tbd4vak","tag_id":"clmynji5n001u27ho765wfms7","_id":"clmynji5p002627hob7uj0evp"},{"post_id":"clmynji58000e27ho9tbd4vak","tag_id":"clmynji5n001x27hoahcl4gv8","_id":"clmynji5p002827hohapm8ccv"},{"post_id":"clmynji59000i27ho2vv86h78","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5p002b27ho99bc5bh9"},{"post_id":"clmynji59000i27ho2vv86h78","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5p002c27ho394x6c9z"},{"post_id":"clmynji59000i27ho2vv86h78","tag_id":"clmynji5p002727hoh39vb2ps","_id":"clmynji5q002e27ho2j9lcp2g"},{"post_id":"clmynji59000i27ho2vv86h78","tag_id":"clmynji5p002927ho8utt8ik8","_id":"clmynji5q002f27hoe9px9pi3"},{"post_id":"clmynji5a000k27ho8gup2fmb","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5q002h27ho4ukm5glx"},{"post_id":"clmynji5a000k27ho8gup2fmb","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5q002i27ho5ft57jac"},{"post_id":"clmynji5a000k27ho8gup2fmb","tag_id":"clmynji5p002d27ho5hz7gpf1","_id":"clmynji5q002k27hodi3vbfcu"},{"post_id":"clmynji5b000o27hogi39fh5e","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5r002m27hoedzrcy5h"},{"post_id":"clmynji5b000o27hogi39fh5e","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5r002n27ho4ggg1y9y"},{"post_id":"clmynji5b000o27hogi39fh5e","tag_id":"clmynji5q002j27ho1nbg035t","_id":"clmynji5r002p27ho70is8slq"},{"post_id":"clmynji5d000q27hobs2263m1","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5r002r27ho7sb7ehe3"},{"post_id":"clmynji5d000q27hobs2263m1","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5r002s27hoeym4a2ft"},{"post_id":"clmynji5d000q27hobs2263m1","tag_id":"clmynji5q002j27ho1nbg035t","_id":"clmynji5s002u27hoe1dk43v8"},{"post_id":"clmynji5e000u27hohawn5gko","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5s002w27hoabro1s27"},{"post_id":"clmynji5e000u27hohawn5gko","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5s002x27hogi40cg29"},{"post_id":"clmynji5e000u27hohawn5gko","tag_id":"clmynji5q002j27ho1nbg035t","_id":"clmynji5t002z27hobuo3663i"},{"post_id":"clmynji5g000x27hohvw2bya9","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5t003227hobszke2qg"},{"post_id":"clmynji5g000x27hohvw2bya9","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5t003327hocssp2grs"},{"post_id":"clmynji5g000x27hohvw2bya9","tag_id":"clmynji5q002j27ho1nbg035t","_id":"clmynji5u003527hoejw36ym5"},{"post_id":"clmynji5g000x27hohvw2bya9","tag_id":"clmynji5p002727hoh39vb2ps","_id":"clmynji5u003627ho62rb76xj"},{"post_id":"clmynji5h001227ho9fivc3bt","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5u003827hog2ua416q"},{"post_id":"clmynji5h001227ho9fivc3bt","tag_id":"clmynji5q002j27ho1nbg035t","_id":"clmynji5v003927hobccpgkjv"},{"post_id":"clmynji5h001227ho9fivc3bt","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5v003b27hodkjx8agy"},{"post_id":"clmynji5i001527hoezbg9eeq","tag_id":"clmynji55000b27hohg9p7ft5","_id":"clmynji5v003c27ho43b8752r"},{"post_id":"clmynji5i001527hoezbg9eeq","tag_id":"clmynji5o002427hoats41q7r","_id":"clmynji5x003e27ho9ezqg0y3"},{"post_id":"clmynji5j001827hoh8wxer4o","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5y003g27hobtxhbd9u"},{"post_id":"clmynji5j001827hoh8wxer4o","tag_id":"clmynji5n001u27ho765wfms7","_id":"clmynji5y003h27ho96yof7jb"},{"post_id":"clmynji5j001827hoh8wxer4o","tag_id":"clmynji5v003d27ho85pt28nn","_id":"clmynji5z003j27ho8s9h68pd"},{"post_id":"clmynji5j001a27hoaf5b04ne","tag_id":"clmynji52000527hof96icwlc","_id":"clmynji5z003l27hocyvv29gn"},{"post_id":"clmynji5j001a27hoaf5b04ne","tag_id":"clmynji5n001u27ho765wfms7","_id":"clmynji5z003m27hobchp53cg"},{"post_id":"clmynji5j001a27hoaf5b04ne","tag_id":"clmynji5y003i27ho6nwh60n8","_id":"clmynji5z003n27ho5mpq9c6t"},{"post_id":"clmynji5j001a27hoaf5b04ne","tag_id":"clmynji5z003k27hoh0c7fram","_id":"clmynji5z003o27hofbxkdl0r"}],"Tag":[{"name":"Java","_id":"clmynji52000527hof96icwlc"},{"name":"Kotlin","_id":"clmynji55000b27hohg9p7ft5"},{"name":"面向对象编程","_id":"clmynji59000h27hogs0pfzoc"},{"name":"函数式编程","_id":"clmynji5b000n27hoaljy43q8"},{"name":"数据结构与算法","_id":"clmynji5n001u27ho765wfms7"},{"name":"动态规划","_id":"clmynji5n001x27hoahcl4gv8"},{"name":"Android","_id":"clmynji5o002427hoats41q7r"},{"name":"数据库","_id":"clmynji5p002727hoh39vb2ps"},{"name":"SQLite","_id":"clmynji5p002927ho8utt8ik8"},{"name":"并发编程","_id":"clmynji5p002d27ho5hz7gpf1"},{"name":"Jetpack","_id":"clmynji5q002j27ho1nbg035t"},{"name":"贪心","_id":"clmynji5v003d27ho85pt28nn"},{"name":"链表","_id":"clmynji5y003i27ho6nwh60n8"},{"name":"双指针","_id":"clmynji5z003k27hoh0c7fram"}]}}