{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/link.yml","hash":"22f28aba86083268a97e3ed64d5cc5b72e7bcaf1","modified":1689758624792},{"_id":"source/_posts/Java_01_Java集合框架体系概述.md","hash":"a963a55cdab4e8bb86b866bd3401bc2d6a699069","modified":1689758624793},{"_id":"source/_posts/Kotlin_01_初识Kotlin.md","hash":"f20f52aaa53de77e99e9478238ea817d962bbb6d","modified":1689758624794},{"_id":"source/_posts/二叉树_01_认识二叉树.md","hash":"51a7182ba27662ed06c67566371eb51a56d98064","modified":1689758624794},{"_id":"source/_posts/动态规划_02_不同路径.md","hash":"bff20b68f4a04e29642c6136abcb09006f3885a4","modified":1689758624795},{"_id":"source/_posts/动态规划_01_爬楼梯.md","hash":"1b8bd2dd06ae1fd103cd8be57b2fda320524b2e7","modified":1689758624795},{"_id":"source/_posts/Kotlin_02_Kotlin函数式编程思想概述.md","hash":"0230e90b6485023033d84ef828521cffb0b8301c","modified":1689815620037},{"_id":"source/_posts/回溯_01_组合.md","hash":"9282651a2111c065d047a3467030a3dd504b645e","modified":1689815900308},{"_id":"source/_posts/安卓_02_OrmLite框架的简单使用.md","hash":"c27852ea2afa964696a56391ab061f6b8f740414","modified":1689815587769},{"_id":"source/_posts/Kotlin_03_Kotlin中的空安全设计详解.md","hash":"f76d7b3cfc6480098658fb63e59cac8b4618f200","modified":1690011367850},{"_id":"source/_posts/安卓_04_Navigation.md","hash":"2706a5c92f367482172549a1245c2754e24393e4","modified":1690253148898},{"_id":"source/_posts/安卓_03_初识Jetpack.md","hash":"7a3f11bb15d0a9417895764e059bbe8e88765129","modified":1689815864633},{"_id":"source/_posts/Kotlin_04_Kotlin中那些和Java不一样的写法.md","hash":"d128580ea289829b3c0ba202cdcaba3b22ccf20e","modified":1690184317060},{"_id":"source/_posts/安卓_07_ViewPager和ViewPager2的使用.md","hash":"88ac98676306af66859cff4b682c533bdf2cdc19","modified":1692061255797},{"_id":"source/_posts/安卓_01_安卓线程间通信的两种方式.md","hash":"72585a056a7b863880576c417601123258a78fc4","modified":1689758624795},{"_id":"source/_posts/安卓_05_Jetpack组件联合使用示例.md","hash":"19528390da429ec55f8ebb480c68648569d16d1e","modified":1689758624797},{"_id":"source/_posts/安卓_06_Room.md","hash":"4ee4d664d840e7f5295c528874686698abaffb2b","modified":1690253007456},{"_id":"source/_posts/栈_01_下一个更大元素.md","hash":"01c81ed9738aa77c052e74aadc7e8fa9d9c9cda5","modified":1689812800768},{"_id":"source/_posts/栈_02_有效的括号.md","hash":"83b020fabcf3f063c0d5eb1160f8ea1b86c4ebc2","modified":1689812862501},{"_id":"source/_posts/杂谈_01_搭建一个属于自己的ChatGPT镜像网站.md","hash":"357cc53322de903d7ca2be996a46b8474f69d3f9","modified":1689815745310},{"_id":"source/_posts/杂谈_02_如何使用Vercel部署自己的Hexo博客.md","hash":"cecbedf6771466d12b674eff53abf69cd513885d","modified":1689815727537},{"_id":"source/_posts/链表_01_相交链表.md","hash":"25ee5329528c7e86e021fbf5383b0e6fe5b90c8d","modified":1689812937629},{"_id":"source/_posts/贪心_01_拆分成最多数目的正偶数之和.md","hash":"61e3f9b2fc123daa540507fb28a5197f80668870","modified":1689758624800},{"_id":"source/categories/index.md","hash":"76c1a5b079afbcbf59ccdf7571df2630fa39bfa9","modified":1689758624801},{"_id":"source/link/index.md","hash":"52e5f7bd9692704ed5b265599770c1b8da79124d","modified":1689758624801},{"_id":"source/tags/index.md","hash":"c2f816c41de811079375aabc589fefbc005b7f81","modified":1689758624802},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1689758624804},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1689758624854},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1689758624804},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1689758624805},{"_id":"themes/butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1689758624805},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1689758624802},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1689758624803},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1689758624803},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1689758624852},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1689758624854},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1689758624853},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1689758624853},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1689758624853},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1689758624803},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1689758624806},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1689758624804},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1689758624806},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1689758624807},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1689758624854},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1689758624855},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1689758624856},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1689758624856},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1689758624857},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1689758624857},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1689758624858},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1689758624858},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1689758624858},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1689758624859},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1689758624859},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1689758624860},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1689758624861},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1689758624862},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1689758624863},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1689758624864},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1689758624864},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1689758624806},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1689758624884},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1689758624806},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1689758624865},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1689758624865},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1689758624806},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1689758624866},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1689758624883},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1689758624868},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1689758624811},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1689758624813},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1689758624810},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1689758624814},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1689758624825},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1689758624825},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1689758624887},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1689758624888},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1689758624889},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1689758624878},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1689758624878},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1689758624879},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1689758624874},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1689758624874},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1689758624883},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1689758624869},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1689758624869},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1689758624870},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1689758624869},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1689758624890},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1689758624891},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1689758624871},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1689758624872},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1689758624872},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1689758624873},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1689758624873},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1689758624874},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1689758624874},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1689758624875},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1689758624876},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1689758624877},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1689758624877},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1689758624877},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1689758624880},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1689758624881},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1689758624882},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1689758624882},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1689758624882},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1689758624887},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1689758624867},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1689758624867},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1689758624867},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1689758624868},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1689758624868},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1689758624816},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1689758624816},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1689758624818},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1689758624819},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1689758624820},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1689758624821},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1689758624822},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1689758624823},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1689758624823},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1689758624823},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1689758624823},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1689758624824},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1689758624826},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1689758624837},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1689758624843},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1689758624844},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1689758624847},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1689758624889},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1689758624848},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1689758624848},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1689758624849},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1689758624849},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1689758624849},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1689758624890},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1689758624850},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1689758624851},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1689758624851},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1689758624852},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1689758624852},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1689758624825},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1689758624851},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1689758624825},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1689758624826},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1689758624827},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1689758624828},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1689758624839},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1689758624840},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1689758624841},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1689758624841},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1689758624842},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1689758624837},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1689758624838},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1689758624846},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1689758624846},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1689758624847},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1689758624847},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1689758624844},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1689758624845},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1689758624829},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1689758624830},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1689758624831},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1689758624831},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1689758624832},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1689758624832},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1689758624833},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1689758624834},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1689758624835},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1689758624836},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1689758624836},{"_id":"public/search.xml","hash":"f8d720c72e9987e16b342734eacc42645ccd55d1","modified":1692061251724},{"_id":"public/categories/index.html","hash":"d5073074eed2349db589c2d0c81de8d7ebd01013","modified":1692061251724},{"_id":"public/link/index.html","hash":"1291fba847ed205a54c3fe4ec07602256253660b","modified":1692061251724},{"_id":"public/tags/index.html","hash":"9a665e7048b6cbdb5c2237515c28bc67f6c44e39","modified":1692061251724},{"_id":"public/2023/08/15/安卓_07_ViewPager和ViewPager2的使用/index.html","hash":"1028c63b9d6f92e6294b58f7374e70acc040c529","modified":1692061251724},{"_id":"public/2023/07/24/Kotlin_04_Kotlin中那些和Java不一样的写法/index.html","hash":"f6c30a2ed47954133c26c46dcdc1a49f3ef0fd6c","modified":1692061251724},{"_id":"public/2023/07/22/安卓_06_Room/index.html","hash":"5f8d29226578587918428ada77174df0984e3953","modified":1692061251724},{"_id":"public/2023/07/19/Kotlin_03_Kotlin中的空安全设计详解/index.html","hash":"da0ca027ef3c87c77e754fc20f5afed18431c8e2","modified":1692061251724},{"_id":"public/2023/07/06/贪心_01_拆分成最多数目的正偶数之和/index.html","hash":"300e0fdafab53a7c4031d37662eb9188dc44eb73","modified":1692061251724},{"_id":"public/2023/07/03/Java_01_Java集合框架体系概述/index.html","hash":"03e902a7aac74e38e0764feee73942bc850e342d","modified":1692061251724},{"_id":"public/2023/06/27/安卓_05_Jetpack组件联合使用示例/index.html","hash":"740fd248779ebfc696ba4f52fd690c298889a3cf","modified":1692061251724},{"_id":"public/2023/06/10/杂谈_02_如何使用Vercel部署自己的Hexo博客/index.html","hash":"fc7eda440e4e284727a4ce74cb56d25baa2c0db5","modified":1692061251724},{"_id":"public/2023/06/08/杂谈_01_搭建一个属于自己的ChatGPT镜像网站/index.html","hash":"bba0e1fd1f19fc89bd138e1975cfc8a9883fa0aa","modified":1692061251724},{"_id":"public/2023/05/13/安卓_04_Navigation/index.html","hash":"3b1b293b73d86162e91bfae6484a41881c2d1528","modified":1692061251724},{"_id":"public/2023/05/12/安卓_03_初识Jetpack/index.html","hash":"e1fe63d96e91a90cd3c72b48139e10fdef89e0d7","modified":1692061251724},{"_id":"public/2023/05/10/回溯_01_组合/index.html","hash":"3afbb7bbd05a808e8a3fe6bfcb659a0e352ed7d8","modified":1692061251724},{"_id":"public/2023/05/03/栈_02_有效的括号/index.html","hash":"e491e22256f4cfcc425cd15c0f19c4eefdc21608","modified":1692061251724},{"_id":"public/2023/04/28/栈_01_下一个更大元素/index.html","hash":"f925edd95128f9e56ec6669329c7dcc95d511100","modified":1692061251724},{"_id":"public/2023/04/19/安卓_02_OrmLite框架的简单使用/index.html","hash":"526634394e5f54907533998ab8ae5bcd2f2eb5b2","modified":1692061251724},{"_id":"public/2023/04/11/二叉树_01_认识二叉树/index.html","hash":"2041d88fe568a0ad6c6cbab8d04b6bcbf072179e","modified":1692061251724},{"_id":"public/2023/04/10/Kotlin_02_Kotlin函数式编程思想概述/index.html","hash":"205ce5d2debf6a6d04f5721693df221093742d09","modified":1692061251724},{"_id":"public/2023/04/08/Kotlin_01_初识Kotlin/index.html","hash":"f5e3e3adcc219e74b2e903779b8f70fcc0d272bc","modified":1692061251724},{"_id":"public/2023/04/08/链表_01_相交链表/index.html","hash":"85f5ef65ff02d9e9abdad452f025aff244212fda","modified":1692061251724},{"_id":"public/2023/04/03/动态规划_02_不同路径/index.html","hash":"862630a5c11c6515c195a5aa4a53a64c6057d64e","modified":1692061251724},{"_id":"public/2023/04/01/动态规划_01_爬楼梯/index.html","hash":"aecee4a568488493abeb5e34cc96d2b4af97c036","modified":1692061251724},{"_id":"public/2023/03/31/安卓_01_安卓线程间通信的两种方式/index.html","hash":"436cebfcaedd0993e93abd88f225a5617a8b83fe","modified":1692061251724},{"_id":"public/archives/index.html","hash":"8182fb1e84260594e0e8b80ddd1d7d99d7fa2ed3","modified":1692061251724},{"_id":"public/archives/page/2/index.html","hash":"f23ad32cfc0327eae33458121538a10aee487167","modified":1692061251724},{"_id":"public/archives/page/3/index.html","hash":"e01eb8ac821daf8ac83bd4632ea81b90c7334db7","modified":1692061251724},{"_id":"public/archives/2023/index.html","hash":"f02d2d17b2179af17ea37609dd4da0f287b6d4c0","modified":1692061251724},{"_id":"public/archives/2023/page/2/index.html","hash":"3f356a2e84fc2c26865deedd01c977dc29030840","modified":1692061251724},{"_id":"public/archives/2023/page/3/index.html","hash":"2ea8834fa84cdf68215227661c24f35b36cdaec8","modified":1692061251724},{"_id":"public/archives/2023/03/index.html","hash":"19a2420d4d9ea11099097088a7bec454bba26667","modified":1692061251724},{"_id":"public/archives/2023/04/index.html","hash":"ebb4f868c35e7c78b399860f90215eb9e3b4c2b5","modified":1692061251724},{"_id":"public/archives/2023/05/index.html","hash":"937ec0a73e5de264b20ca282d2e9955ee61c223e","modified":1692061251724},{"_id":"public/archives/2023/06/index.html","hash":"905c1f931aa0c0602d1e1019bc0cdbc701ab396f","modified":1692061251724},{"_id":"public/archives/2023/07/index.html","hash":"98404bdc28a02bf827fae15a897c1add6acc6481","modified":1692061251724},{"_id":"public/archives/2023/08/index.html","hash":"4ff07a3ee8526fdf7305e5cbd693e6b0f32e8691","modified":1692061251724},{"_id":"public/categories/编程开发/index.html","hash":"afc0907a82bae45c3d58a0d04915ae17bd0996d1","modified":1692061251724},{"_id":"public/categories/编程开发/page/2/index.html","hash":"b8b028e5944766d43d79cfac12a82fa8140f563c","modified":1692061251724},{"_id":"public/categories/数据结构与算法/index.html","hash":"0f32a5cb5931ec46f35854c0c13cd5c9283c49da","modified":1692061251724},{"_id":"public/categories/数据库/index.html","hash":"290238283b557f385b654491affd1f731c37452e","modified":1692061251724},{"_id":"public/categories/杂谈/index.html","hash":"a74a00ebd580ef03cf9460f43f6095828af4bc79","modified":1692061251724},{"_id":"public/index.html","hash":"55e5e27b3c710aff86cea54e3e0e6a5012c7b9cc","modified":1692061251724},{"_id":"public/page/2/index.html","hash":"9fadd0af7349ee3b8c3244b9680e068636c75cf1","modified":1692061251724},{"_id":"public/page/3/index.html","hash":"1d5a24dc9c0e8e6a5f47f6452c8f2f05d6a4983b","modified":1692061251724},{"_id":"public/tags/Java/index.html","hash":"bb12d3298026aeb3ad580484dc80a28a6fbdfdf1","modified":1692061251724},{"_id":"public/tags/Java/page/2/index.html","hash":"dd0e5d7bb54c9974ae08ee36086cf05590f5fb68","modified":1692061251724},{"_id":"public/tags/Kotlin/index.html","hash":"73222ea2a5c62cbf863720aa50b2fa85dcbefdc5","modified":1692061251724},{"_id":"public/tags/面向对象编程/index.html","hash":"812020065bb4eced9bf15bba89131d5ed2a8f973","modified":1692061251724},{"_id":"public/tags/函数式编程/index.html","hash":"dcf63cd62d0cc213474a8a30690b5ee525c43c07","modified":1692061251724},{"_id":"public/tags/数据结构与算法/index.html","hash":"aabe7056fd6eb804e337f095604eee8928184e3c","modified":1692061251724},{"_id":"public/tags/二叉树/index.html","hash":"52fcdc49df098f212d9b14d23c306fba16f3cbd0","modified":1692061251724},{"_id":"public/tags/动态规划/index.html","hash":"895e47723c1c01d6a3f7cfcaa87f23a3fc7701fd","modified":1692061251724},{"_id":"public/tags/回溯/index.html","hash":"060bd9aad88276842897f9219bef5350afbb3680","modified":1692061251724},{"_id":"public/tags/Android/index.html","hash":"c86ae25ee53ef94b4262c3dc5c047cc8d9bb3813","modified":1692061251724},{"_id":"public/tags/并发编程/index.html","hash":"790216e81c0f12a38f8fcfc5a11dc17b5391e08f","modified":1692061251724},{"_id":"public/tags/Jetpack/index.html","hash":"b2a8f965fa7bf36eb0f227bcfd51836168e22906","modified":1692061251724},{"_id":"public/tags/数据库/index.html","hash":"d27edbfc971031d61a94b2fae2745cab2b336314","modified":1692061251724},{"_id":"public/tags/SQLite/index.html","hash":"01ca5be59842a1187cbc4ce5767956e82f03de25","modified":1692061251724},{"_id":"public/tags/ChatGPT/index.html","hash":"20ec76489422620bac54b1228f6e7adff157ed60","modified":1692061251724},{"_id":"public/tags/Blog/index.html","hash":"319a0f768fdd30f0082380336317e97037e1a6ad","modified":1692061251724},{"_id":"public/tags/栈/index.html","hash":"1e37c2d76fee7b4837b73778db2fc5f5ed6a46c6","modified":1692061251724},{"_id":"public/tags/贪心/index.html","hash":"5f35e3b18d9348991c43d903c86647db34612a04","modified":1692061251724},{"_id":"public/tags/链表/index.html","hash":"d6db6b99d2d4cfaf2982392f27a0de152bb26118","modified":1692061251724},{"_id":"public/tags/双指针/index.html","hash":"438be96e69c3d3475bc51ddfa025814f80c73ef7","modified":1692061251724},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692061251724},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692061251724},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692061251724},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1692061251724},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692061251724},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692061251724},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692061251724},{"_id":"public/css/index.css","hash":"73fab15294f019f903e184f5e20308ce8959a045","modified":1692061251724},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692061251724},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692061251724}],"Category":[{"name":"编程开发","_id":"cllblkyro0004m7ho83ykhzuw"},{"name":"数据结构与算法","_id":"cllblkytn000lm7ho9dbk0vc7"},{"name":"数据库","_id":"cllblkyuj001cm7hoabpq2522"},{"name":"杂谈","_id":"cllblkyum001jm7hoe2ubecxy"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}],"Page":[{"title":"分类","date":"2023-03-30T16:00:00.000Z","type":"categories","_content":"---\ntitle: 数据结构与算法\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 编程开发\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"categories\"\n---\n---\ntitle: 杂谈\ndate: 2023-06-08\ntype: \"categories\"\n---","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 编程开发\ndate: 2023-03-31\ntype: \"categories\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"categories\"\n---\n---\ntitle: 杂谈\ndate: 2023-06-08\ntype: \"categories\"\n---","updated":"2023-07-19T09:23:44.801Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllblkyqx0000m7hoeg297itz","content":"<hr>\n<p>title: 数据结构与算法<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 编程开发<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 杂谈<br>date: 2023-06-08<br>type: “categories”</p>\n<hr>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":"<hr>\n<p>title: 数据结构与算法<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 编程开发<br>date: 2023-03-31<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “categories”</p>\n<hr>\n<hr>\n<p>title: 杂谈<br>date: 2023-06-08<br>type: “categories”</p>\n<hr>\n"},{"title":"友情链接","date":"2023-03-30T16:00:00.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2023-03-31\ntype: \"link\"\n---\n","updated":"2023-07-19T09:23:44.801Z","path":"link/index.html","comments":1,"layout":"page","_id":"cllblkyrl0002m7hocxxyg7hm","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"标签","date":"2023-03-30T16:00:00.000Z","type":"tags","_content":"---\ntitle: Android\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Java\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Kotlin\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: Jetpack\ndate: 2023-05-12\ntype: \"tags\"\n---\n---\ntitle: 面向对象编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 函数式编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 并发编程\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 动态规划\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数组\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 二叉树\ndate: 2023-04-11\ntype: \"tags\"\n---\n---\ntitle: 链表\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 双指针\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 栈\ndate: 2023-04-28\ntype: \"tags\"\n------\ntitle: 回溯\ndate: 2023-05-10\ntype: \"tags\"\n---\n---\ntitle: 贪心\ndate: 2023-07-06\ntype: \"tags\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: SQLite\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: ChatGPT\ndate: 2023-06-08\ntype: \"tags\"\n---\n---\ntitle: Blog\ndate: 2023-06-10\ntype: \"tags\"\n---","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Android\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Java\ndate: 2023-03-31\ntype: \"tags\"\n---\n---\ntitle: Kotlin\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: Jetpack\ndate: 2023-05-12\ntype: \"tags\"\n---\n---\ntitle: 面向对象编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 函数式编程\ndate: 2023-04-10\ntype: \"tags\"\n---\n---\ntitle: 并发编程\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数据结构与算法\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 动态规划\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 数组\ndate: 2023-04-01\ntype: \"tags\"\n---\n---\ntitle: 二叉树\ndate: 2023-04-11\ntype: \"tags\"\n---\n---\ntitle: 链表\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 双指针\ndate: 2023-04-08\ntype: \"tags\"\n---\n---\ntitle: 栈\ndate: 2023-04-28\ntype: \"tags\"\n------\ntitle: 回溯\ndate: 2023-05-10\ntype: \"tags\"\n---\n---\ntitle: 贪心\ndate: 2023-07-06\ntype: \"tags\"\n---\n---\ntitle: 数据库\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: SQLite\ndate: 2023-04-19\ntype: \"tags\"\n---\n---\ntitle: ChatGPT\ndate: 2023-06-08\ntype: \"tags\"\n---\n---\ntitle: Blog\ndate: 2023-06-10\ntype: \"tags\"\n---","updated":"2023-07-19T09:23:44.802Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cllblkyrr0006m7ho089608xn","content":"<hr>\n<p>title: Android<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Java<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Kotlin<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Jetpack<br>date: 2023-05-12<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 面向对象编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 函数式编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 并发编程<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据结构与算法<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 动态规划<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数组<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 二叉树<br>date: 2023-04-11<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 链表<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 双指针<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 栈<br>date: 2023-04-28<br>type: “tags”</p>\n<hr>\n<p>title: 回溯<br>date: 2023-05-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 贪心<br>date: 2023-07-06<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: SQLite<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: ChatGPT<br>date: 2023-06-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Blog<br>date: 2023-06-10<br>type: “tags”</p>\n<hr>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover":false,"excerpt":"","more":"<hr>\n<p>title: Android<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Java<br>date: 2023-03-31<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Kotlin<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Jetpack<br>date: 2023-05-12<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 面向对象编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 函数式编程<br>date: 2023-04-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 并发编程<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据结构与算法<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 动态规划<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数组<br>date: 2023-04-01<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 二叉树<br>date: 2023-04-11<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 链表<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 双指针<br>date: 2023-04-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 栈<br>date: 2023-04-28<br>type: “tags”</p>\n<hr>\n<p>title: 回溯<br>date: 2023-05-10<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 贪心<br>date: 2023-07-06<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: 数据库<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: SQLite<br>date: 2023-04-19<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: ChatGPT<br>date: 2023-06-08<br>type: “tags”</p>\n<hr>\n<hr>\n<p>title: Blog<br>date: 2023-06-10<br>type: “tags”</p>\n<hr>\n"}],"Post":[{"title":"Java集合框架体系概述","date":"2023-07-03T00:00:00.000Z","description":"介绍 Java 编程语言中的集合框架，包括列表、集合、队列、映射等。","cover":"https://www.helloimg.com/images/2023/07/03/o42YST.webp","_content":"\n# 一、集合的概念及分类\n\n## 1.1 集合的概念\n\n- 在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。\n- 在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。\n\n## 1.2 集合的分类\n\n- 集合有多种分类方式，根据`是否有序`、`是否可变`、`是否线程安全`、`单列集合或者双列集合`、`实现的接口`等等，可以分出很多类别。\n- 一般来说，使用较多的分类方式是根据`实现的接口`进行分类：\n  1. List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。\n  2. Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。\n  3. Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。\n  4. Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。\n\n- `List`、`Set`、`Map`、`Queue`四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。\n\n# 二、List 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WOaM.png\">\n\n## 2.1 总述\n\n- **概念**：继承自 `Collection` 接口，主要用于存储和操作一组对象。\n- **特点**：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。\n- **常见实现类**：\n  1. ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。\n  2. LinkedList：基于链表实现，它支持高效的插入和删除操作。\n  3. Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。\n  4. Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。\n- **实现类特点**：\n  1. 有序\n  2. 线程安全/不安全都有\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 2.2 ArrayList\n\n- **概念**：基于动态数组实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。 \n  2. 线程安全：线程`不安全`。 \n  3. 可否为null：`允许存储null`元素。 \n  4. 可否元素重复：`允许重复`元素。 \n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`1.5倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到ArrayList的末尾。 \n  2. remove(Object element)：从ArrayList中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取ArrayList中元素的数量。 \n  6. isEmpty()：检查ArrayList是否为空。 \n  7. clear()：清空ArrayList中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 \n  10. contains(Object element)：判断ArrayList是否包含指定的元素。 \n  11. toArray()：将ArrayList转换为数组。\n\n## 2.3 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。\n  2. addFirst(E element)：将指定元素添加到链表的头部。\n  3. addLast(E element)：将指定元素添加到链表的末尾。\n  4. remove()：移除并返回链表的第一个元素。\n  5. removeFirst()：移除并返回链表的第一个元素。\n  6. removeLast()：移除并返回链表的最后一个元素。\n  7. get(int index)：返回链表指定位置处的元素。\n  8. getFirst()：返回链表的第一个元素，但不移除。\n  9. getLast()：返回链表的最后一个元素，但不移除。\n  10. size()：获取链表的大小（元素个数）。\n\n## 2.4 Vector\n\n- **概念**：基于动态数组实现的集合类，与ArrayList类似。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到Vector的末尾。 \n  2. remove(Object element)：从Vector中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取Vector中元素的数量。 \n  6. isEmpty()：检查Vector是否为空。 \n  7. clear()：清空Vector中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 \n  10. contains(Object element)：判断Vector是否包含指定的元素。 \n  11. iterator()：返回对Vector中元素进行迭代的迭代器。\n\n## 2.5 Stack\n\n- **概念**：基于Vector实现的后进先出（LIFO）的堆栈数据结构。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。\n  7. 应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。\n- **常用方法**：\n  1. push(E element)：将元素推入栈顶。 \n  2. pop()：弹出栈顶元素并返回该值。 \n  3. peek()：获取栈顶元素的值，但不从栈中移除它。 \n  4. empty()：检查栈是否为空。 \n  5. search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）\n\n# 三、Set 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WcbP.png\">\n\n## 3.1 总述\n\n- **概念**：继承自`Collection`接口，用于存储一组唯一的对象，不允许包含重复元素。\n- **特点**：每个元素都必须是唯一的。\n- **常见实现类**：\n  1. HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。\n  2. TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全\n  3. 可以存储 null 元素（但只能为一个）\n  4. 不允许重复元素\n\n## 3.2 HashSet\n\n- **概念**：基于哈希表实现的集合类，通过哈希算法存储和查找元素。\n- **特点**：\n  1. 是否有序：`无序`，不按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`哈希表`作为内部数据结构，通过哈希值实现快速查找。\n  7. 应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到HashSet中。 \n  2. remove(Object element)：从HashSet中移除指定的元素。 \n  3. contains(Object element)：判断HashSet是否包含指定的元素。 \n  4. size()：获取HashSet中元素的数量。 \n  5. isEmpty()：检查HashSet是否为空。 \n  6. clear()：清空HashSet中的所有元素。 \n  7. iterator()：返回对HashSet中元素进行迭代的迭代器。\n\n## 3.3 TreeSet\n\n- **概念**：基于红黑树实现的有序集合类，可以对元素进行排序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：红黑树结构`不需要扩容`。\n  6. 底层原理：使用`红黑树`作为内部数据结构，保持有序性。\n  7. 应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到TreeSet中。 \n  2. remove(Object element)：从TreeSet中移除指定的元素。 \n  3. contains(Object element)：判断TreeSet是否包含指定的元素。 \n  4. size()：获取TreeSet中元素的数量。 \n  5. isEmpty()：检查TreeSet是否为空。 \n  6. clear()：清空TreeSet中的所有元素。 \n  7. iterator()：返回对TreeSet中元素进行迭代的迭代器。 \n  8. first()：获取TreeSet中的第一个元素。 \n  9. last()：获取TreeSet中的最后一个元素。 \n  10. higher(E element)：获取严格大于指定元素的最小元素。 \n  11. lower(E element)：获取严格小于指定元素的最大元素。\n\n## 3.4 LinkedHashSet\n\n- **概念**：基于链表和哈希表实现的集合类，保留元素插入的顺序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`链表和哈希表组合实现`，通过哈希值和链表维护插入顺序与查找性能。\n  7. 应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到LinkedHashSet中。 \n  2. remove(Object element)：从LinkedHashSet中移除指定的元素。 \n  3. contains(Object element)：判断LinkedHashSet是否包含指定的元素。 \n  4. size()：获取LinkedHashSet中元素的数量。 \n  5. isEmpty()：检查LinkedHashSet是否为空。 \n  6. clear()：清空LinkedHashSet中的所有元素。 \n  7. iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 \n  8. forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。\n\n# 四、Map 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WdD6.png\">\n\n## 4.1 总述\n\n- **概念**：用于保存键值对的集合。\n- **特点**：每个键都必须是唯一的，但值可以重复。\n- **常见实现类**：\n  1. HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。\n  2. TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。\n  4. HashTable：基于哈希表实现，类似于HashMap，但线程安全。\n  5. Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全（可通过 Collections 提供的方法进行同步操作）\n  3. 允许键为null（但只能有一个），值可以为null\n  4. 键唯一，值可重复\n\n## 4.2 HashMap \n\n- **概念**：基于哈希表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，不保证元素的插入顺序和迭代顺序一致。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`允许存储null键和null值`（键只能储存一个）。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，但并非每次都会触发扩容操作（需要 HashMap 的大小 < 64，并且桶上的元素个数小于8）\n  6. 底层原理：使用`数组和链表`或`红黑树（JDK8+）`作为内部数据结构，通过哈希算法来存储和查找键值对。\n  7. 应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在HashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断HashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断HashMap是否包含指定的值。 \n  6. size()：获取HashMap中键值对的数量。 \n  7. isEmpty()：检查HashMap是否为空。 \n  8. keySet()：返回HashMap中所有键的Set集合。 \n  9. values()：返回HashMap中所有值的Collection集合。 \n  10. entrySet()：返回HashMap中所有键值对的Set集合。\n\n## 4.3 TreeMap\n\n- **概念**：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：没有固定的扩容机制。\n  6. 底层原理：使用`红黑树`作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。\n  7. 应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在TreeMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断TreeMap是否包含指定的键。 \n  5. containsValue(Object value)：判断TreeMap是否包含指定的值。 \n  6. size()：获取TreeMap中键值对的数量。 \n  7. isEmpty()：检查TreeMap是否为空。 \n  8. keySet()：返回TreeMap中所有键的Set集合。 \n  9. values()：返回TreeMap中所有值的Collection集合。 \n  10. entrySet()：返回TreeMap中所有键值对的Set集合。\n\n## 4.4 LinkedHashMap\n\n- **概念**：基于哈希表和双向链表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，并根据插入顺序或访问顺序进行调整。\n  6. 底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。\n  7. 应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 \n  6. size()：获取LinkedHashMap中键值对的数量。 \n  7. isEmpty()：检查LinkedHashMap是否为空。 \n  8. keySet()：返回LinkedHashMap中所有键的Set集合。 \n  9. values()：返回LinkedHashMap中所有值的Collection集合。 \n  10. entrySet()：返回LinkedHashMap中所有键值对的Set集合。\n\n## 4.5 HashTable\n\n- **概念**：基于哈希算法实现的数据结构，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`安全`。HashTable中的所有操作都是同步的（synchronized修饰）。\n  3. 可否为null：`不允许存储null键和null值`，如果存储会抛出NullPointerException。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在Hashtable中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断Hashtable是否包含指定的键。 \n  5. containsValue(Object value)：判断Hashtable是否包含指定的值。 \n  6. size()：获取Hashtable中键值对的数量。 \n  7. isEmpty()：检查Hashtable是否为空。 \n  8. keys()：返回包含所有键的枚举（Enumeration）对象。 \n  9. values()：返回包含所有值的Collection对象。 \n  10. clear()：清空Hashtable中的所有键值对。\n\n## 4.6 Properties\n\n- **概念**：继承自Hashtable类，用于处理属性文件（.properties）的操作。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程` 不安全`\n  3. 可否为null：`允许存储null键和null值`。\n  4. 可否元素重复：`允许重复`的键，值也可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。\n- **常用方法**：\n  1. setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 \n  2. getProperty(String key)：根据键获取属性的值。 \n  3. getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 \n  4. load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 \n  5. store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 \n  6. getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 \n  7. stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 \n  8. remove(Object key)：根据键移除属性。 \n  9. containsKey(Object key)：检查属性列表是否包含指定的键。 \n  10. containsValue(Object value)：检查属性列表是否包含指定的值。\n\n# 五、Queue 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4W0AR.png\">\n\n## 5.1 总述\n\n- **概念**：用于表示队列（先进先出）的接口，即保存元素的集合。\n- **特点**：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。\n- **常见实现类**：\n  1. LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。\n  2. ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。\n  3. PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。\n- **实现类特点**：\n  1. 有序\n  2. 线程不安全\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 5.2 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。 \n  2. addFirst(E element)：将指定元素添加到链表的头部。 \n  3. addLast(E element)：将指定元素添加到链表的末尾。 \n  4. remove()：移除并返回链表的第一个元素。 \n  5. removeFirst()：移除并返回链表的第一个元素。 \n  6. removeLast()：移除并返回链表的最后一个元素。 \n  7. get(int index)：返回链表指定位置处的元素。 \n  8. getFirst()：返回链表的第一个元素，但不移除。 \n  9. getLast()：返回链表的最后一个元素，但不移除。 \n  10. size()：获取链表的大小（元素个数）。\n\n## 5.3 ArrayDeque\n\n- **概念**：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的`2倍`。\n  6. 底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. addFirst(E element)：将指定元素插入到双端队列的头部。\n  2. addLast(E element)：将指定元素插入到双端队列的尾部。 \n  3. offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 \n  4. offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 \n  5. removeFirst()：移除并返回双端队列的头部元素。 \n  6. removeLast()：移除并返回双端队列的尾部元素。 \n  7. pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 \n  8. pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 \n  9. getFirst()：返回双端队列的头部元素，但不移除。 \n  10. getLast()：返回双端队列的尾部元素，但不移除。 \n  11. peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 \n  12. peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 \n  13. size()：获取双端队列的大小（元素个数）。 \n  14. isEmpty()：检查双端队列是否为空。\n\n## 5.4 PriorityQueue\n\n- **概念**：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。\n- **特点**：\n  1. 是否有序：`有序`，元素按照优先级进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会根据策略进行自动扩容。\n  6. 底层原理：通常使用`堆（Heap）`数据结构来实现，具体可以是`二叉堆`或`斐波那契堆`等。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. add(E element) / offer(E element)：将指定元素插入到队列中。 \n  2. remove() / poll()：移除并返回队列头部的元素。 \n  3. peek()：返回队列头部的元素，但不移除。 \n  4. size()：获取队列的大小（元素个数）。 \n  5. isEmpty()：检查队列是否为空。 \n  6. clear()：清空队列中的所有元素。 \n  7. iterator()：返回用于遍历队列的迭代器。\n\n# 六、总结\n\n- 当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。\n  1. `List接口`实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 \n  2. `Set接口`实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 \n  3. `Map接口`实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 \n  4. `Queue接口`实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。\n- Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。","source":"_posts/Java_01_Java集合框架体系概述.md","raw":"---\ntitle: 'Java集合框架体系概述'\ndate: '2023-07-03'\ndescription: '介绍 Java 编程语言中的集合框架，包括列表、集合、队列、映射等。'\ncover: 'https://www.helloimg.com/images/2023/07/03/o42YST.webp'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Java\n\n---\n\n# 一、集合的概念及分类\n\n## 1.1 集合的概念\n\n- 在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。\n- 在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。\n\n## 1.2 集合的分类\n\n- 集合有多种分类方式，根据`是否有序`、`是否可变`、`是否线程安全`、`单列集合或者双列集合`、`实现的接口`等等，可以分出很多类别。\n- 一般来说，使用较多的分类方式是根据`实现的接口`进行分类：\n  1. List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。\n  2. Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。\n  3. Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。\n  4. Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。\n\n- `List`、`Set`、`Map`、`Queue`四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。\n\n# 二、List 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WOaM.png\">\n\n## 2.1 总述\n\n- **概念**：继承自 `Collection` 接口，主要用于存储和操作一组对象。\n- **特点**：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。\n- **常见实现类**：\n  1. ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。\n  2. LinkedList：基于链表实现，它支持高效的插入和删除操作。\n  3. Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。\n  4. Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。\n- **实现类特点**：\n  1. 有序\n  2. 线程安全/不安全都有\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 2.2 ArrayList\n\n- **概念**：基于动态数组实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。 \n  2. 线程安全：线程`不安全`。 \n  3. 可否为null：`允许存储null`元素。 \n  4. 可否元素重复：`允许重复`元素。 \n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`1.5倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到ArrayList的末尾。 \n  2. remove(Object element)：从ArrayList中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取ArrayList中元素的数量。 \n  6. isEmpty()：检查ArrayList是否为空。 \n  7. clear()：清空ArrayList中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 \n  10. contains(Object element)：判断ArrayList是否包含指定的元素。 \n  11. toArray()：将ArrayList转换为数组。\n\n## 2.3 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。\n  2. addFirst(E element)：将指定元素添加到链表的头部。\n  3. addLast(E element)：将指定元素添加到链表的末尾。\n  4. remove()：移除并返回链表的第一个元素。\n  5. removeFirst()：移除并返回链表的第一个元素。\n  6. removeLast()：移除并返回链表的最后一个元素。\n  7. get(int index)：返回链表指定位置处的元素。\n  8. getFirst()：返回链表的第一个元素，但不移除。\n  9. getLast()：返回链表的最后一个元素，但不移除。\n  10. size()：获取链表的大小（元素个数）。\n\n## 2.4 Vector\n\n- **概念**：基于动态数组实现的集合类，与ArrayList类似。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。\n  7. 应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到Vector的末尾。 \n  2. remove(Object element)：从Vector中移除指定的元素。 \n  3. get(int index)：获取指定索引位置的元素。 \n  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 \n  5. size()：获取Vector中元素的数量。 \n  6. isEmpty()：检查Vector是否为空。 \n  7. clear()：清空Vector中的所有元素。 \n  8. indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 \n  9. lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 \n  10. contains(Object element)：判断Vector是否包含指定的元素。 \n  11. iterator()：返回对Vector中元素进行迭代的迭代器。\n\n## 2.5 Stack\n\n- **概念**：基于Vector实现的后进先出（LIFO）的堆栈数据结构。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`数组`作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。\n  7. 应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。\n- **常用方法**：\n  1. push(E element)：将元素推入栈顶。 \n  2. pop()：弹出栈顶元素并返回该值。 \n  3. peek()：获取栈顶元素的值，但不从栈中移除它。 \n  4. empty()：检查栈是否为空。 \n  5. search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）\n\n# 三、Set 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WcbP.png\">\n\n## 3.1 总述\n\n- **概念**：继承自`Collection`接口，用于存储一组唯一的对象，不允许包含重复元素。\n- **特点**：每个元素都必须是唯一的。\n- **常见实现类**：\n  1. HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。\n  2. TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全\n  3. 可以存储 null 元素（但只能为一个）\n  4. 不允许重复元素\n\n## 3.2 HashSet\n\n- **概念**：基于哈希表实现的集合类，通过哈希算法存储和查找元素。\n- **特点**：\n  1. 是否有序：`无序`，不按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`哈希表`作为内部数据结构，通过哈希值实现快速查找。\n  7. 应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到HashSet中。 \n  2. remove(Object element)：从HashSet中移除指定的元素。 \n  3. contains(Object element)：判断HashSet是否包含指定的元素。 \n  4. size()：获取HashSet中元素的数量。 \n  5. isEmpty()：检查HashSet是否为空。 \n  6. clear()：清空HashSet中的所有元素。 \n  7. iterator()：返回对HashSet中元素进行迭代的迭代器。\n\n## 3.3 TreeSet\n\n- **概念**：基于红黑树实现的有序集合类，可以对元素进行排序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：红黑树结构`不需要扩容`。\n  6. 底层原理：使用`红黑树`作为内部数据结构，保持有序性。\n  7. 应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到TreeSet中。 \n  2. remove(Object element)：从TreeSet中移除指定的元素。 \n  3. contains(Object element)：判断TreeSet是否包含指定的元素。 \n  4. size()：获取TreeSet中元素的数量。 \n  5. isEmpty()：检查TreeSet是否为空。 \n  6. clear()：清空TreeSet中的所有元素。 \n  7. iterator()：返回对TreeSet中元素进行迭代的迭代器。 \n  8. first()：获取TreeSet中的第一个元素。 \n  9. last()：获取TreeSet中的最后一个元素。 \n  10. higher(E element)：获取严格大于指定元素的最小元素。 \n  11. lower(E element)：获取严格小于指定元素的最大元素。\n\n## 3.4 LinkedHashSet\n\n- **概念**：基于链表和哈希表实现的集合类，保留元素插入的顺序。\n- **特点**：\n  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素（只能储存一个）。\n  4. 可否元素重复：`不允许重复`元素。\n  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。\n  6. 底层原理：使用`链表和哈希表组合实现`，通过哈希值和链表维护插入顺序与查找性能。\n  7. 应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。\n- **常用方法**：\n  1. add(E element)：将指定的元素添加到LinkedHashSet中。 \n  2. remove(Object element)：从LinkedHashSet中移除指定的元素。 \n  3. contains(Object element)：判断LinkedHashSet是否包含指定的元素。 \n  4. size()：获取LinkedHashSet中元素的数量。 \n  5. isEmpty()：检查LinkedHashSet是否为空。 \n  6. clear()：清空LinkedHashSet中的所有元素。 \n  7. iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 \n  8. forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。\n\n# 四、Map 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4WdD6.png\">\n\n## 4.1 总述\n\n- **概念**：用于保存键值对的集合。\n- **特点**：每个键都必须是唯一的，但值可以重复。\n- **常见实现类**：\n  1. HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。\n  2. TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。\n  3. LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。\n  4. HashTable：基于哈希表实现，类似于HashMap，但线程安全。\n  5. Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。\n- **实现类特点**：\n  1. 无/有序都有\n  2. 线程不安全（可通过 Collections 提供的方法进行同步操作）\n  3. 允许键为null（但只能有一个），值可以为null\n  4. 键唯一，值可重复\n\n## 4.2 HashMap \n\n- **概念**：基于哈希表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，不保证元素的插入顺序和迭代顺序一致。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`允许存储null键和null值`（键只能储存一个）。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，但并非每次都会触发扩容操作（需要 HashMap 的大小 < 64，并且桶上的元素个数小于8）\n  6. 底层原理：使用`数组和链表`或`红黑树（JDK8+）`作为内部数据结构，通过哈希算法来存储和查找键值对。\n  7. 应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在HashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断HashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断HashMap是否包含指定的值。 \n  6. size()：获取HashMap中键值对的数量。 \n  7. isEmpty()：检查HashMap是否为空。 \n  8. keySet()：返回HashMap中所有键的Set集合。 \n  9. values()：返回HashMap中所有值的Collection集合。 \n  10. entrySet()：返回HashMap中所有键值对的Set集合。\n\n## 4.3 TreeMap\n\n- **概念**：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：没有固定的扩容机制。\n  6. 底层原理：使用`红黑树`作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。\n  7. 应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在TreeMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断TreeMap是否包含指定的键。 \n  5. containsValue(Object value)：判断TreeMap是否包含指定的值。 \n  6. size()：获取TreeMap中键值对的数量。 \n  7. isEmpty()：检查TreeMap是否为空。 \n  8. keySet()：返回TreeMap中所有键的Set集合。 \n  9. values()：返回TreeMap中所有值的Collection集合。 \n  10. entrySet()：返回TreeMap中所有键值对的Set集合。\n\n## 4.4 LinkedHashMap\n\n- **概念**：基于哈希表和双向链表实现的集合类，用于存储键值对。\n- **特点**：\n  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。\n  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。\n  3. 可否为null：`不允许存储null键`，但`允许存储null值`。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，并根据插入顺序或访问顺序进行调整。\n  6. 底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。\n  7. 应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 \n  5. containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 \n  6. size()：获取LinkedHashMap中键值对的数量。 \n  7. isEmpty()：检查LinkedHashMap是否为空。 \n  8. keySet()：返回LinkedHashMap中所有键的Set集合。 \n  9. values()：返回LinkedHashMap中所有值的Collection集合。 \n  10. entrySet()：返回LinkedHashMap中所有键值对的Set集合。\n\n## 4.5 HashTable\n\n- **概念**：基于哈希算法实现的数据结构，用于存储键值对。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`安全`。HashTable中的所有操作都是同步的（synchronized修饰）。\n  3. 可否为null：`不允许存储null键和null值`，如果存储会抛出NullPointerException。\n  4. 可否元素重复：`不允许重复`的键，值可以重复。\n  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。\n- **常用方法**：\n  1. put(K key, V value)：将指定的键值对存储在Hashtable中。 \n  2. get(Object key)：根据键获取对应的值。 \n  3. remove(Object key)：根据键移除键值对。 \n  4. containsKey(Object key)：判断Hashtable是否包含指定的键。 \n  5. containsValue(Object value)：判断Hashtable是否包含指定的值。 \n  6. size()：获取Hashtable中键值对的数量。 \n  7. isEmpty()：检查Hashtable是否为空。 \n  8. keys()：返回包含所有键的枚举（Enumeration）对象。 \n  9. values()：返回包含所有值的Collection对象。 \n  10. clear()：清空Hashtable中的所有键值对。\n\n## 4.6 Properties\n\n- **概念**：继承自Hashtable类，用于处理属性文件（.properties）的操作。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程` 不安全`\n  3. 可否为null：`允许存储null键和null值`。\n  4. 可否元素重复：`允许重复`的键，值也可以重复。\n  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。\n  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。\n  7. 应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。\n- **常用方法**：\n  1. setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 \n  2. getProperty(String key)：根据键获取属性的值。 \n  3. getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 \n  4. load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 \n  5. store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 \n  6. getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 \n  7. stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 \n  8. remove(Object key)：根据键移除属性。 \n  9. containsKey(Object key)：检查属性列表是否包含指定的键。 \n  10. containsValue(Object value)：检查属性列表是否包含指定的值。\n\n# 五、Queue 接口\n\n<img src=\"https://www.helloimg.com/images/2023/07/03/o4W0AR.png\">\n\n## 5.1 总述\n\n- **概念**：用于表示队列（先进先出）的接口，即保存元素的集合。\n- **特点**：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。\n- **常见实现类**：\n  1. LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。\n  2. ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。\n  3. PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。\n- **实现类特点**：\n  1. 有序\n  2. 线程不安全\n  3. 可以存储 null 元素\n  4. 允许重复元素\n\n## 5.2 LinkedList\n\n- **概念**：基于链表实现的集合类。\n- **特点**：\n  1. 是否有序：`有序`，按照插入顺序存储元素。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。\n  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。\n  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。\n- **常用方法**：\n  1. add(E element)：将指定元素添加到链表的末尾。 \n  2. addFirst(E element)：将指定元素添加到链表的头部。 \n  3. addLast(E element)：将指定元素添加到链表的末尾。 \n  4. remove()：移除并返回链表的第一个元素。 \n  5. removeFirst()：移除并返回链表的第一个元素。 \n  6. removeLast()：移除并返回链表的最后一个元素。 \n  7. get(int index)：返回链表指定位置处的元素。 \n  8. getFirst()：返回链表的第一个元素，但不移除。 \n  9. getLast()：返回链表的最后一个元素，但不移除。 \n  10. size()：获取链表的大小（元素个数）。\n\n## 5.3 ArrayDeque\n\n- **概念**：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。\n- **特点**：\n  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的`2倍`。\n  6. 底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. addFirst(E element)：将指定元素插入到双端队列的头部。\n  2. addLast(E element)：将指定元素插入到双端队列的尾部。 \n  3. offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 \n  4. offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 \n  5. removeFirst()：移除并返回双端队列的头部元素。 \n  6. removeLast()：移除并返回双端队列的尾部元素。 \n  7. pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 \n  8. pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 \n  9. getFirst()：返回双端队列的头部元素，但不移除。 \n  10. getLast()：返回双端队列的尾部元素，但不移除。 \n  11. peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 \n  12. peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 \n  13. size()：获取双端队列的大小（元素个数）。 \n  14. isEmpty()：检查双端队列是否为空。\n\n## 5.4 PriorityQueue\n\n- **概念**：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。\n- **特点**：\n  1. 是否有序：`有序`，元素按照优先级进行排序。\n  2. 线程安全：线程`不安全`。\n  3. 可否为null：`不允许存储null`元素。\n  4. 可否元素重复：`允许重复`元素。\n  5. 扩容机制：在达到容量限制时，会根据策略进行自动扩容。\n  6. 底层原理：通常使用`堆（Heap）`数据结构来实现，具体可以是`二叉堆`或`斐波那契堆`等。\n  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。\n- **常用方法**：\n  1. add(E element) / offer(E element)：将指定元素插入到队列中。 \n  2. remove() / poll()：移除并返回队列头部的元素。 \n  3. peek()：返回队列头部的元素，但不移除。 \n  4. size()：获取队列的大小（元素个数）。 \n  5. isEmpty()：检查队列是否为空。 \n  6. clear()：清空队列中的所有元素。 \n  7. iterator()：返回用于遍历队列的迭代器。\n\n# 六、总结\n\n- 当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。\n  1. `List接口`实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 \n  2. `Set接口`实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 \n  3. `Map接口`实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 \n  4. `Queue接口`实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。\n- Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。","slug":"Java_01_Java集合框架体系概述","published":1,"updated":"2023-07-19T09:23:44.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyri0001m7ho7cpig417","content":"<h1 id=\"一、集合的概念及分类\"><a href=\"#一、集合的概念及分类\" class=\"headerlink\" title=\"一、集合的概念及分类\"></a>一、集合的概念及分类</h1><h2 id=\"1-1-集合的概念\"><a href=\"#1-1-集合的概念\" class=\"headerlink\" title=\"1.1 集合的概念\"></a>1.1 集合的概念</h2><ul>\n<li>在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。</li>\n<li>在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。</li>\n</ul>\n<h2 id=\"1-2-集合的分类\"><a href=\"#1-2-集合的分类\" class=\"headerlink\" title=\"1.2 集合的分类\"></a>1.2 集合的分类</h2><ul>\n<li><p>集合有多种分类方式，根据<code>是否有序</code>、<code>是否可变</code>、<code>是否线程安全</code>、<code>单列集合或者双列集合</code>、<code>实现的接口</code>等等，可以分出很多类别。</p>\n</li>\n<li><p>一般来说，使用较多的分类方式是根据<code>实现的接口</code>进行分类：</p>\n<ol>\n<li>List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。</li>\n<li>Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。</li>\n<li>Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。</li>\n<li>Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。</li>\n</ol>\n</li>\n<li><p><code>List</code>、<code>Set</code>、<code>Map</code>、<code>Queue</code>四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。</p>\n</li>\n</ul>\n<h1 id=\"二、List-接口\"><a href=\"#二、List-接口\" class=\"headerlink\" title=\"二、List 接口\"></a>二、List 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WOaM.png\">\n\n<h2 id=\"2-1-总述\"><a href=\"#2-1-总述\" class=\"headerlink\" title=\"2.1 总述\"></a>2.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自 <code>Collection</code> 接口，主要用于存储和操作一组对象。</li>\n<li><strong>特点</strong>：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。</li>\n<li>LinkedList：基于链表实现，它支持高效的插入和删除操作。</li>\n<li>Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。</li>\n<li>Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程安全/不安全都有</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-ArrayList\"><a href=\"#2-2-ArrayList\" class=\"headerlink\" title=\"2.2 ArrayList\"></a>2.2 ArrayList</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。 </li>\n<li>线程安全：线程<code>不安全</code>。 </li>\n<li>可否为null：<code>允许存储null</code>元素。 </li>\n<li>可否元素重复：<code>允许重复</code>元素。 </li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>1.5倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到ArrayList的末尾。 </li>\n<li>remove(Object element)：从ArrayList中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取ArrayList中元素的数量。 </li>\n<li>isEmpty()：检查ArrayList是否为空。 </li>\n<li>clear()：清空ArrayList中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 </li>\n<li>contains(Object element)：判断ArrayList是否包含指定的元素。 </li>\n<li>toArray()：将ArrayList转换为数组。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-LinkedList\"><a href=\"#2-3-LinkedList\" class=\"headerlink\" title=\"2.3 LinkedList\"></a>2.3 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。</li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。</li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。</li>\n<li>remove()：移除并返回链表的第一个元素。</li>\n<li>removeFirst()：移除并返回链表的第一个元素。</li>\n<li>removeLast()：移除并返回链表的最后一个元素。</li>\n<li>get(int index)：返回链表指定位置处的元素。</li>\n<li>getFirst()：返回链表的第一个元素，但不移除。</li>\n<li>getLast()：返回链表的最后一个元素，但不移除。</li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-Vector\"><a href=\"#2-4-Vector\" class=\"headerlink\" title=\"2.4 Vector\"></a>2.4 Vector</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类，与ArrayList类似。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到Vector的末尾。 </li>\n<li>remove(Object element)：从Vector中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取Vector中元素的数量。 </li>\n<li>isEmpty()：检查Vector是否为空。 </li>\n<li>clear()：清空Vector中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 </li>\n<li>contains(Object element)：判断Vector是否包含指定的元素。 </li>\n<li>iterator()：返回对Vector中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-Stack\"><a href=\"#2-5-Stack\" class=\"headerlink\" title=\"2.5 Stack\"></a>2.5 Stack</h2><ul>\n<li><strong>概念</strong>：基于Vector实现的后进先出（LIFO）的堆栈数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。</li>\n<li>应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>push(E element)：将元素推入栈顶。 </li>\n<li>pop()：弹出栈顶元素并返回该值。 </li>\n<li>peek()：获取栈顶元素的值，但不从栈中移除它。 </li>\n<li>empty()：检查栈是否为空。 </li>\n<li>search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、Set-接口\"><a href=\"#三、Set-接口\" class=\"headerlink\" title=\"三、Set 接口\"></a>三、Set 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WcbP.png\">\n\n<h2 id=\"3-1-总述\"><a href=\"#3-1-总述\" class=\"headerlink\" title=\"3.1 总述\"></a>3.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自<code>Collection</code>接口，用于存储一组唯一的对象，不允许包含重复元素。</li>\n<li><strong>特点</strong>：每个元素都必须是唯一的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。</li>\n<li>TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素（但只能为一个）</li>\n<li>不允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，通过哈希算法存储和查找元素。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>哈希表</code>作为内部数据结构，通过哈希值实现快速查找。</li>\n<li>应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到HashSet中。 </li>\n<li>remove(Object element)：从HashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断HashSet是否包含指定的元素。 </li>\n<li>size()：获取HashSet中元素的数量。 </li>\n<li>isEmpty()：检查HashSet是否为空。 </li>\n<li>clear()：清空HashSet中的所有元素。 </li>\n<li>iterator()：返回对HashSet中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-3-TreeSet\"><a href=\"#3-3-TreeSet\" class=\"headerlink\" title=\"3.3 TreeSet\"></a>3.3 TreeSet</h2><ul>\n<li><strong>概念</strong>：基于红黑树实现的有序集合类，可以对元素进行排序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：红黑树结构<code>不需要扩容</code>。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，保持有序性。</li>\n<li>应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到TreeSet中。 </li>\n<li>remove(Object element)：从TreeSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断TreeSet是否包含指定的元素。 </li>\n<li>size()：获取TreeSet中元素的数量。 </li>\n<li>isEmpty()：检查TreeSet是否为空。 </li>\n<li>clear()：清空TreeSet中的所有元素。 </li>\n<li>iterator()：返回对TreeSet中元素进行迭代的迭代器。 </li>\n<li>first()：获取TreeSet中的第一个元素。 </li>\n<li>last()：获取TreeSet中的最后一个元素。 </li>\n<li>higher(E element)：获取严格大于指定元素的最小元素。 </li>\n<li>lower(E element)：获取严格小于指定元素的最大元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-4-LinkedHashSet\"><a href=\"#3-4-LinkedHashSet\" class=\"headerlink\" title=\"3.4 LinkedHashSet\"></a>3.4 LinkedHashSet</h2><ul>\n<li><strong>概念</strong>：基于链表和哈希表实现的集合类，保留元素插入的顺序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>链表和哈希表组合实现</code>，通过哈希值和链表维护插入顺序与查找性能。</li>\n<li>应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到LinkedHashSet中。 </li>\n<li>remove(Object element)：从LinkedHashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断LinkedHashSet是否包含指定的元素。 </li>\n<li>size()：获取LinkedHashSet中元素的数量。 </li>\n<li>isEmpty()：检查LinkedHashSet是否为空。 </li>\n<li>clear()：清空LinkedHashSet中的所有元素。 </li>\n<li>iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 </li>\n<li>forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、Map-接口\"><a href=\"#四、Map-接口\" class=\"headerlink\" title=\"四、Map 接口\"></a>四、Map 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WdD6.png\">\n\n<h2 id=\"4-1-总述\"><a href=\"#4-1-总述\" class=\"headerlink\" title=\"4.1 总述\"></a>4.1 总述</h2><ul>\n<li><strong>概念</strong>：用于保存键值对的集合。</li>\n<li><strong>特点</strong>：每个键都必须是唯一的，但值可以重复。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。</li>\n<li>TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。</li>\n<li>HashTable：基于哈希表实现，类似于HashMap，但线程安全。</li>\n<li>Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全（可通过 Collections 提供的方法进行同步操作）</li>\n<li>允许键为null（但只能有一个），值可以为null</li>\n<li>键唯一，值可重复</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-2-HashMap\"><a href=\"#4-2-HashMap\" class=\"headerlink\" title=\"4.2 HashMap\"></a>4.2 HashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不保证元素的插入顺序和迭代顺序一致。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>允许存储null键和null值</code>（键只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，但并非每次都会触发扩容操作（需要 HashMap 的大小 &lt; 64，并且桶上的元素个数小于8）</li>\n<li>底层原理：使用<code>数组和链表</code>或<code>红黑树（JDK8+）</code>作为内部数据结构，通过哈希算法来存储和查找键值对。</li>\n<li>应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在HashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断HashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断HashMap是否包含指定的值。 </li>\n<li>size()：获取HashMap中键值对的数量。 </li>\n<li>isEmpty()：检查HashMap是否为空。 </li>\n<li>keySet()：返回HashMap中所有键的Set集合。 </li>\n<li>values()：返回HashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回HashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-3-TreeMap\"><a href=\"#4-3-TreeMap\" class=\"headerlink\" title=\"4.3 TreeMap\"></a>4.3 TreeMap</h2><ul>\n<li><strong>概念</strong>：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：没有固定的扩容机制。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。</li>\n<li>应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在TreeMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断TreeMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断TreeMap是否包含指定的值。 </li>\n<li>size()：获取TreeMap中键值对的数量。 </li>\n<li>isEmpty()：检查TreeMap是否为空。 </li>\n<li>keySet()：返回TreeMap中所有键的Set集合。 </li>\n<li>values()：返回TreeMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回TreeMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-4-LinkedHashMap\"><a href=\"#4-4-LinkedHashMap\" class=\"headerlink\" title=\"4.4 LinkedHashMap\"></a>4.4 LinkedHashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表和双向链表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，并根据插入顺序或访问顺序进行调整。</li>\n<li>底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。</li>\n<li>应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 </li>\n<li>size()：获取LinkedHashMap中键值对的数量。 </li>\n<li>isEmpty()：检查LinkedHashMap是否为空。 </li>\n<li>keySet()：返回LinkedHashMap中所有键的Set集合。 </li>\n<li>values()：返回LinkedHashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回LinkedHashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-5-HashTable\"><a href=\"#4-5-HashTable\" class=\"headerlink\" title=\"4.5 HashTable\"></a>4.5 HashTable</h2><ul>\n<li><strong>概念</strong>：基于哈希算法实现的数据结构，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>安全</code>。HashTable中的所有操作都是同步的（synchronized修饰）。</li>\n<li>可否为null：<code>不允许存储null键和null值</code>，如果存储会抛出NullPointerException。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在Hashtable中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断Hashtable是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断Hashtable是否包含指定的值。 </li>\n<li>size()：获取Hashtable中键值对的数量。 </li>\n<li>isEmpty()：检查Hashtable是否为空。 </li>\n<li>keys()：返回包含所有键的枚举（Enumeration）对象。 </li>\n<li>values()：返回包含所有值的Collection对象。 </li>\n<li>clear()：清空Hashtable中的所有键值对。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-6-Properties\"><a href=\"#4-6-Properties\" class=\"headerlink\" title=\"4.6 Properties\"></a>4.6 Properties</h2><ul>\n<li><strong>概念</strong>：继承自Hashtable类，用于处理属性文件（.properties）的操作。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code> 不安全</code></li>\n<li>可否为null：<code>允许存储null键和null值</code>。</li>\n<li>可否元素重复：<code>允许重复</code>的键，值也可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 </li>\n<li>getProperty(String key)：根据键获取属性的值。 </li>\n<li>getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 </li>\n<li>load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 </li>\n<li>store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 </li>\n<li>getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 </li>\n<li>stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 </li>\n<li>remove(Object key)：根据键移除属性。 </li>\n<li>containsKey(Object key)：检查属性列表是否包含指定的键。 </li>\n<li>containsValue(Object value)：检查属性列表是否包含指定的值。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"五、Queue-接口\"><a href=\"#五、Queue-接口\" class=\"headerlink\" title=\"五、Queue 接口\"></a>五、Queue 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4W0AR.png\">\n\n<h2 id=\"5-1-总述\"><a href=\"#5-1-总述\" class=\"headerlink\" title=\"5.1 总述\"></a>5.1 总述</h2><ul>\n<li><strong>概念</strong>：用于表示队列（先进先出）的接口，即保存元素的集合。</li>\n<li><strong>特点</strong>：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。</li>\n<li>ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。</li>\n<li>PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-LinkedList\"><a href=\"#5-2-LinkedList\" class=\"headerlink\" title=\"5.2 LinkedList\"></a>5.2 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。 </li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。 </li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。 </li>\n<li>remove()：移除并返回链表的第一个元素。 </li>\n<li>removeFirst()：移除并返回链表的第一个元素。 </li>\n<li>removeLast()：移除并返回链表的最后一个元素。 </li>\n<li>get(int index)：返回链表指定位置处的元素。 </li>\n<li>getFirst()：返回链表的第一个元素，但不移除。 </li>\n<li>getLast()：返回链表的最后一个元素，但不移除。 </li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-3-ArrayDeque\"><a href=\"#5-3-ArrayDeque\" class=\"headerlink\" title=\"5.3 ArrayDeque\"></a>5.3 ArrayDeque</h2><ul>\n<li><strong>概念</strong>：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的<code>2倍</code>。</li>\n<li>底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>addFirst(E element)：将指定元素插入到双端队列的头部。</li>\n<li>addLast(E element)：将指定元素插入到双端队列的尾部。 </li>\n<li>offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 </li>\n<li>offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 </li>\n<li>removeFirst()：移除并返回双端队列的头部元素。 </li>\n<li>removeLast()：移除并返回双端队列的尾部元素。 </li>\n<li>pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>getFirst()：返回双端队列的头部元素，但不移除。 </li>\n<li>getLast()：返回双端队列的尾部元素，但不移除。 </li>\n<li>peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>size()：获取双端队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查双端队列是否为空。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-4-PriorityQueue\"><a href=\"#5-4-PriorityQueue\" class=\"headerlink\" title=\"5.4 PriorityQueue\"></a>5.4 PriorityQueue</h2><ul>\n<li><strong>概念</strong>：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素按照优先级进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会根据策略进行自动扩容。</li>\n<li>底层原理：通常使用<code>堆（Heap）</code>数据结构来实现，具体可以是<code>二叉堆</code>或<code>斐波那契堆</code>等。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element) / offer(E element)：将指定元素插入到队列中。 </li>\n<li>remove() / poll()：移除并返回队列头部的元素。 </li>\n<li>peek()：返回队列头部的元素，但不移除。 </li>\n<li>size()：获取队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查队列是否为空。 </li>\n<li>clear()：清空队列中的所有元素。 </li>\n<li>iterator()：返回用于遍历队列的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h1><ul>\n<li>当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。<ol>\n<li><code>List接口</code>实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 </li>\n<li><code>Set接口</code>实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 </li>\n<li><code>Map接口</code>实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 </li>\n<li><code>Queue接口</code>实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。</li>\n</ol>\n</li>\n<li>Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、集合的概念及分类\"><a href=\"#一、集合的概念及分类\" class=\"headerlink\" title=\"一、集合的概念及分类\"></a>一、集合的概念及分类</h1><h2 id=\"1-1-集合的概念\"><a href=\"#1-1-集合的概念\" class=\"headerlink\" title=\"1.1 集合的概念\"></a>1.1 集合的概念</h2><ul>\n<li>在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。</li>\n<li>在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。</li>\n</ul>\n<h2 id=\"1-2-集合的分类\"><a href=\"#1-2-集合的分类\" class=\"headerlink\" title=\"1.2 集合的分类\"></a>1.2 集合的分类</h2><ul>\n<li><p>集合有多种分类方式，根据<code>是否有序</code>、<code>是否可变</code>、<code>是否线程安全</code>、<code>单列集合或者双列集合</code>、<code>实现的接口</code>等等，可以分出很多类别。</p>\n</li>\n<li><p>一般来说，使用较多的分类方式是根据<code>实现的接口</code>进行分类：</p>\n<ol>\n<li>List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。</li>\n<li>Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。</li>\n<li>Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。</li>\n<li>Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。</li>\n</ol>\n</li>\n<li><p><code>List</code>、<code>Set</code>、<code>Map</code>、<code>Queue</code>四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。</p>\n</li>\n</ul>\n<h1 id=\"二、List-接口\"><a href=\"#二、List-接口\" class=\"headerlink\" title=\"二、List 接口\"></a>二、List 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WOaM.png\">\n\n<h2 id=\"2-1-总述\"><a href=\"#2-1-总述\" class=\"headerlink\" title=\"2.1 总述\"></a>2.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自 <code>Collection</code> 接口，主要用于存储和操作一组对象。</li>\n<li><strong>特点</strong>：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。</li>\n<li>LinkedList：基于链表实现，它支持高效的插入和删除操作。</li>\n<li>Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。</li>\n<li>Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程安全/不安全都有</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-ArrayList\"><a href=\"#2-2-ArrayList\" class=\"headerlink\" title=\"2.2 ArrayList\"></a>2.2 ArrayList</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。 </li>\n<li>线程安全：线程<code>不安全</code>。 </li>\n<li>可否为null：<code>允许存储null</code>元素。 </li>\n<li>可否元素重复：<code>允许重复</code>元素。 </li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>1.5倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到ArrayList的末尾。 </li>\n<li>remove(Object element)：从ArrayList中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取ArrayList中元素的数量。 </li>\n<li>isEmpty()：检查ArrayList是否为空。 </li>\n<li>clear()：清空ArrayList中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 </li>\n<li>contains(Object element)：判断ArrayList是否包含指定的元素。 </li>\n<li>toArray()：将ArrayList转换为数组。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-LinkedList\"><a href=\"#2-3-LinkedList\" class=\"headerlink\" title=\"2.3 LinkedList\"></a>2.3 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。</li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。</li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。</li>\n<li>remove()：移除并返回链表的第一个元素。</li>\n<li>removeFirst()：移除并返回链表的第一个元素。</li>\n<li>removeLast()：移除并返回链表的最后一个元素。</li>\n<li>get(int index)：返回链表指定位置处的元素。</li>\n<li>getFirst()：返回链表的第一个元素，但不移除。</li>\n<li>getLast()：返回链表的最后一个元素，但不移除。</li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-Vector\"><a href=\"#2-4-Vector\" class=\"headerlink\" title=\"2.4 Vector\"></a>2.4 Vector</h2><ul>\n<li><strong>概念</strong>：基于动态数组实现的集合类，与ArrayList类似。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过索引实现快速随机访问。</li>\n<li>应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到Vector的末尾。 </li>\n<li>remove(Object element)：从Vector中移除指定的元素。 </li>\n<li>get(int index)：获取指定索引位置的元素。 </li>\n<li>set(int index, E element)：将指定索引位置的元素替换为新的元素。 </li>\n<li>size()：获取Vector中元素的数量。 </li>\n<li>isEmpty()：检查Vector是否为空。 </li>\n<li>clear()：清空Vector中的所有元素。 </li>\n<li>indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 </li>\n<li>lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 </li>\n<li>contains(Object element)：判断Vector是否包含指定的元素。 </li>\n<li>iterator()：返回对Vector中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-Stack\"><a href=\"#2-5-Stack\" class=\"headerlink\" title=\"2.5 Stack\"></a>2.5 Stack</h2><ul>\n<li><strong>概念</strong>：基于Vector实现的后进先出（LIFO）的堆栈数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>数组</code>作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。</li>\n<li>应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>push(E element)：将元素推入栈顶。 </li>\n<li>pop()：弹出栈顶元素并返回该值。 </li>\n<li>peek()：获取栈顶元素的值，但不从栈中移除它。 </li>\n<li>empty()：检查栈是否为空。 </li>\n<li>search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、Set-接口\"><a href=\"#三、Set-接口\" class=\"headerlink\" title=\"三、Set 接口\"></a>三、Set 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WcbP.png\">\n\n<h2 id=\"3-1-总述\"><a href=\"#3-1-总述\" class=\"headerlink\" title=\"3.1 总述\"></a>3.1 总述</h2><ul>\n<li><strong>概念</strong>：继承自<code>Collection</code>接口，用于存储一组唯一的对象，不允许包含重复元素。</li>\n<li><strong>特点</strong>：每个元素都必须是唯一的。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。</li>\n<li>TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素（但只能为一个）</li>\n<li>不允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，通过哈希算法存储和查找元素。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>哈希表</code>作为内部数据结构，通过哈希值实现快速查找。</li>\n<li>应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到HashSet中。 </li>\n<li>remove(Object element)：从HashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断HashSet是否包含指定的元素。 </li>\n<li>size()：获取HashSet中元素的数量。 </li>\n<li>isEmpty()：检查HashSet是否为空。 </li>\n<li>clear()：清空HashSet中的所有元素。 </li>\n<li>iterator()：返回对HashSet中元素进行迭代的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-3-TreeSet\"><a href=\"#3-3-TreeSet\" class=\"headerlink\" title=\"3.3 TreeSet\"></a>3.3 TreeSet</h2><ul>\n<li><strong>概念</strong>：基于红黑树实现的有序集合类，可以对元素进行排序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：红黑树结构<code>不需要扩容</code>。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，保持有序性。</li>\n<li>应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到TreeSet中。 </li>\n<li>remove(Object element)：从TreeSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断TreeSet是否包含指定的元素。 </li>\n<li>size()：获取TreeSet中元素的数量。 </li>\n<li>isEmpty()：检查TreeSet是否为空。 </li>\n<li>clear()：清空TreeSet中的所有元素。 </li>\n<li>iterator()：返回对TreeSet中元素进行迭代的迭代器。 </li>\n<li>first()：获取TreeSet中的第一个元素。 </li>\n<li>last()：获取TreeSet中的最后一个元素。 </li>\n<li>higher(E element)：获取严格大于指定元素的最小元素。 </li>\n<li>lower(E element)：获取严格小于指定元素的最大元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-4-LinkedHashSet\"><a href=\"#3-4-LinkedHashSet\" class=\"headerlink\" title=\"3.4 LinkedHashSet\"></a>3.4 LinkedHashSet</h2><ul>\n<li><strong>概念</strong>：基于链表和哈希表实现的集合类，保留元素插入的顺序。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，根据元素的自然顺序或者自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素（只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>元素。</li>\n<li>扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的<code>2倍</code>。</li>\n<li>底层原理：使用<code>链表和哈希表组合实现</code>，通过哈希值和链表维护插入顺序与查找性能。</li>\n<li>应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定的元素添加到LinkedHashSet中。 </li>\n<li>remove(Object element)：从LinkedHashSet中移除指定的元素。 </li>\n<li>contains(Object element)：判断LinkedHashSet是否包含指定的元素。 </li>\n<li>size()：获取LinkedHashSet中元素的数量。 </li>\n<li>isEmpty()：检查LinkedHashSet是否为空。 </li>\n<li>clear()：清空LinkedHashSet中的所有元素。 </li>\n<li>iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 </li>\n<li>forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、Map-接口\"><a href=\"#四、Map-接口\" class=\"headerlink\" title=\"四、Map 接口\"></a>四、Map 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4WdD6.png\">\n\n<h2 id=\"4-1-总述\"><a href=\"#4-1-总述\" class=\"headerlink\" title=\"4.1 总述\"></a>4.1 总述</h2><ul>\n<li><strong>概念</strong>：用于保存键值对的集合。</li>\n<li><strong>特点</strong>：每个键都必须是唯一的，但值可以重复。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。</li>\n<li>TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。</li>\n<li>LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。</li>\n<li>HashTable：基于哈希表实现，类似于HashMap，但线程安全。</li>\n<li>Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>无/有序都有</li>\n<li>线程不安全（可通过 Collections 提供的方法进行同步操作）</li>\n<li>允许键为null（但只能有一个），值可以为null</li>\n<li>键唯一，值可重复</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-2-HashMap\"><a href=\"#4-2-HashMap\" class=\"headerlink\" title=\"4.2 HashMap\"></a>4.2 HashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，不保证元素的插入顺序和迭代顺序一致。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>允许存储null键和null值</code>（键只能储存一个）。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，但并非每次都会触发扩容操作（需要 HashMap 的大小 &lt; 64，并且桶上的元素个数小于8）</li>\n<li>底层原理：使用<code>数组和链表</code>或<code>红黑树（JDK8+）</code>作为内部数据结构，通过哈希算法来存储和查找键值对。</li>\n<li>应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在HashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断HashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断HashMap是否包含指定的值。 </li>\n<li>size()：获取HashMap中键值对的数量。 </li>\n<li>isEmpty()：检查HashMap是否为空。 </li>\n<li>keySet()：返回HashMap中所有键的Set集合。 </li>\n<li>values()：返回HashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回HashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-3-TreeMap\"><a href=\"#4-3-TreeMap\" class=\"headerlink\" title=\"4.3 TreeMap\"></a>4.3 TreeMap</h2><ul>\n<li><strong>概念</strong>：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：没有固定的扩容机制。</li>\n<li>底层原理：使用<code>红黑树</code>作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。</li>\n<li>应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在TreeMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断TreeMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断TreeMap是否包含指定的值。 </li>\n<li>size()：获取TreeMap中键值对的数量。 </li>\n<li>isEmpty()：检查TreeMap是否为空。 </li>\n<li>keySet()：返回TreeMap中所有键的Set集合。 </li>\n<li>values()：返回TreeMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回TreeMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-4-LinkedHashMap\"><a href=\"#4-4-LinkedHashMap\" class=\"headerlink\" title=\"4.4 LinkedHashMap\"></a>4.4 LinkedHashMap</h2><ul>\n<li><strong>概念</strong>：基于哈希表和双向链表实现的集合类，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。可以使用 Collections.synchronizedMap() 方法进行同步。</li>\n<li>可否为null：<code>不允许存储null键</code>，但<code>允许存储null值</code>。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍</code>，并根据插入顺序或访问顺序进行调整。</li>\n<li>底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。</li>\n<li>应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 </li>\n<li>size()：获取LinkedHashMap中键值对的数量。 </li>\n<li>isEmpty()：检查LinkedHashMap是否为空。 </li>\n<li>keySet()：返回LinkedHashMap中所有键的Set集合。 </li>\n<li>values()：返回LinkedHashMap中所有值的Collection集合。 </li>\n<li>entrySet()：返回LinkedHashMap中所有键值对的Set集合。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-5-HashTable\"><a href=\"#4-5-HashTable\" class=\"headerlink\" title=\"4.5 HashTable\"></a>4.5 HashTable</h2><ul>\n<li><strong>概念</strong>：基于哈希算法实现的数据结构，用于存储键值对。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>安全</code>。HashTable中的所有操作都是同步的（synchronized修饰）。</li>\n<li>可否为null：<code>不允许存储null键和null值</code>，如果存储会抛出NullPointerException。</li>\n<li>可否元素重复：<code>不允许重复</code>的键，值可以重复。</li>\n<li>扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>put(K key, V value)：将指定的键值对存储在Hashtable中。 </li>\n<li>get(Object key)：根据键获取对应的值。 </li>\n<li>remove(Object key)：根据键移除键值对。 </li>\n<li>containsKey(Object key)：判断Hashtable是否包含指定的键。 </li>\n<li>containsValue(Object value)：判断Hashtable是否包含指定的值。 </li>\n<li>size()：获取Hashtable中键值对的数量。 </li>\n<li>isEmpty()：检查Hashtable是否为空。 </li>\n<li>keys()：返回包含所有键的枚举（Enumeration）对象。 </li>\n<li>values()：返回包含所有值的Collection对象。 </li>\n<li>clear()：清空Hashtable中的所有键值对。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"4-6-Properties\"><a href=\"#4-6-Properties\" class=\"headerlink\" title=\"4.6 Properties\"></a>4.6 Properties</h2><ul>\n<li><strong>概念</strong>：继承自Hashtable类，用于处理属性文件（.properties）的操作。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code> 不安全</code></li>\n<li>可否为null：<code>允许存储null键和null值</code>。</li>\n<li>可否元素重复：<code>允许重复</code>的键，值也可以重复。</li>\n<li>扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的<code>2倍+1</code>。</li>\n<li>底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。</li>\n<li>应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 </li>\n<li>getProperty(String key)：根据键获取属性的值。 </li>\n<li>getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 </li>\n<li>load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 </li>\n<li>store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 </li>\n<li>getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 </li>\n<li>stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 </li>\n<li>remove(Object key)：根据键移除属性。 </li>\n<li>containsKey(Object key)：检查属性列表是否包含指定的键。 </li>\n<li>containsValue(Object value)：检查属性列表是否包含指定的值。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"五、Queue-接口\"><a href=\"#五、Queue-接口\" class=\"headerlink\" title=\"五、Queue 接口\"></a>五、Queue 接口</h1><img src=\"https://www.helloimg.com/images/2023/07/03/o4W0AR.png\">\n\n<h2 id=\"5-1-总述\"><a href=\"#5-1-总述\" class=\"headerlink\" title=\"5.1 总述\"></a>5.1 总述</h2><ul>\n<li><strong>概念</strong>：用于表示队列（先进先出）的接口，即保存元素的集合。</li>\n<li><strong>特点</strong>：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。</li>\n<li><strong>常见实现类</strong>：<ol>\n<li>LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。</li>\n<li>ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。</li>\n<li>PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。</li>\n</ol>\n</li>\n<li><strong>实现类特点</strong>：<ol>\n<li>有序</li>\n<li>线程不安全</li>\n<li>可以存储 null 元素</li>\n<li>允许重复元素</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-LinkedList\"><a href=\"#5-2-LinkedList\" class=\"headerlink\" title=\"5.2 LinkedList\"></a>5.2 LinkedList</h2><ul>\n<li><strong>概念</strong>：基于链表实现的集合类。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，按照插入顺序存储元素。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：<code>不需要扩容</code>，根据需要动态创建新节点。</li>\n<li>底层原理：使用<code>双向链表</code>作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。</li>\n<li>应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element)：将指定元素添加到链表的末尾。 </li>\n<li>addFirst(E element)：将指定元素添加到链表的头部。 </li>\n<li>addLast(E element)：将指定元素添加到链表的末尾。 </li>\n<li>remove()：移除并返回链表的第一个元素。 </li>\n<li>removeFirst()：移除并返回链表的第一个元素。 </li>\n<li>removeLast()：移除并返回链表的最后一个元素。 </li>\n<li>get(int index)：返回链表指定位置处的元素。 </li>\n<li>getFirst()：返回链表的第一个元素，但不移除。 </li>\n<li>getLast()：返回链表的最后一个元素，但不移除。 </li>\n<li>size()：获取链表的大小（元素个数）。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-3-ArrayDeque\"><a href=\"#5-3-ArrayDeque\" class=\"headerlink\" title=\"5.3 ArrayDeque\"></a>5.3 ArrayDeque</h2><ul>\n<li><strong>概念</strong>：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>无序</code>，元素的插入顺序和迭代顺序无关。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的<code>2倍</code>。</li>\n<li>底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>addFirst(E element)：将指定元素插入到双端队列的头部。</li>\n<li>addLast(E element)：将指定元素插入到双端队列的尾部。 </li>\n<li>offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 </li>\n<li>offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 </li>\n<li>removeFirst()：移除并返回双端队列的头部元素。 </li>\n<li>removeLast()：移除并返回双端队列的尾部元素。 </li>\n<li>pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>getFirst()：返回双端队列的头部元素，但不移除。 </li>\n<li>getLast()：返回双端队列的尾部元素，但不移除。 </li>\n<li>peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 </li>\n<li>peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 </li>\n<li>size()：获取双端队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查双端队列是否为空。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-4-PriorityQueue\"><a href=\"#5-4-PriorityQueue\" class=\"headerlink\" title=\"5.4 PriorityQueue\"></a>5.4 PriorityQueue</h2><ul>\n<li><strong>概念</strong>：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。</li>\n<li><strong>特点</strong>：<ol>\n<li>是否有序：<code>有序</code>，元素按照优先级进行排序。</li>\n<li>线程安全：线程<code>不安全</code>。</li>\n<li>可否为null：<code>不允许存储null</code>元素。</li>\n<li>可否元素重复：<code>允许重复</code>元素。</li>\n<li>扩容机制：在达到容量限制时，会根据策略进行自动扩容。</li>\n<li>底层原理：通常使用<code>堆（Heap）</code>数据结构来实现，具体可以是<code>二叉堆</code>或<code>斐波那契堆</code>等。</li>\n<li>应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。</li>\n</ol>\n</li>\n<li><strong>常用方法</strong>：<ol>\n<li>add(E element) / offer(E element)：将指定元素插入到队列中。 </li>\n<li>remove() / poll()：移除并返回队列头部的元素。 </li>\n<li>peek()：返回队列头部的元素，但不移除。 </li>\n<li>size()：获取队列的大小（元素个数）。 </li>\n<li>isEmpty()：检查队列是否为空。 </li>\n<li>clear()：清空队列中的所有元素。 </li>\n<li>iterator()：返回用于遍历队列的迭代器。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h1><ul>\n<li>当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。<ol>\n<li><code>List接口</code>实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 </li>\n<li><code>Set接口</code>实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 </li>\n<li><code>Map接口</code>实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 </li>\n<li><code>Queue接口</code>实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。</li>\n</ol>\n</li>\n<li>Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。</li>\n</ul>\n"},{"title":"初识 Kotlin","date":"2023-04-08T00:00:00.000Z","description":"Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。","cover":"https://www.helloimg.com/images/2023/05/02/oqTWxn.jpg","_content":"\n> Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。由于其灵活性和可读性，Kotlin 迅速成为 Android 平台上最火热的编程语言之一，并得到越来越多开发者的青睐。\n\n# 一、为什么要学习Kotlin？\n\n## 1.1 更加简洁的语法\n\n- Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。\n\n1. **简化的字符串模版**\n   在 Kotlin 中，我们可以使用 \"$\" 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。\n   例如：\n\n```kotlin\nval name = \"Kotlin\"\nprintln(\"Hello, $name!\") // prints \"Hello, Kotlin!\"\n```\n\n2. **数据类**\n   在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和\n   hashCode() 等一些通用的方法，减少了我们写重复代码的机会。\n   例如：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\n3. **Lambda 表达式**\n   Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。\n   例如：\n\n```kotlin\nval fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\nfruits.filter { it.startsWith(\"a\") }\n    .sortedBy { it }\n    .map { it.toUpperCase() }\n    .forEach { println(it) }\n``` \n\n## 1.2 更好的安全性\n\n- Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。\n\n1. **空安全**\n\n- 在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 \"?\" 操作符来标识可空性。\n  例如，以下代码中的变量 maybeNull 就可以为空：\n\n```kotlin\nvar maybeNull: String? = null\n```\n\n- 如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用\"!!\" 操作符来进行转换。如下例：\n\n```kotlin\nvar notNullVar: String?\nnotNullVar = \"Hello World\" // 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）\nvar length = notNullVar!!.length // 使用 !! 操作符将 notNullVar 转换为非空类型\n```\n\n- 通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。\n\n2. **类型推断**\n\n- Kotlin 会自动推断变量的类型。\n  例如，以下代码中的变量 name 的类型是 String：\n\n```kotlin\nval name = \"Kotlin\"\n```\n\n- 这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。\n\n3. **严格的空安全检查**\n\n- Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。\n  如，以下代码会得到编译时错误：\n\n```kotlin\n// 可能为空的变量\nvar maybeNull: String?\n// 访问变量，需要进行非空检查\nprintln(maybeNull.length)\n```\n\n- 以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 \"?\" 来实现：\n\n```kotlin\nprintln(maybeNull?.length)\n```\n\n- 这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。\n\n## 1.3 更好的互操作性\n\n- Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。\n\n1. **兼容 Java 类库和框架**\n\n- Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java\n  应用程序一起部署和运行。\n\n2. **直接使用 Java 类和方法**\n\n- 在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：\n\n```kotlin\nval pi = Math.PI\n```\n\n3. **使用 JavaBean**\n\n- 在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：\n\n```kotlin\nclass Person {\n    var name: String? = null\n    var age: Int = 0\n}\n```\n\n- 由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。\n\n4. **Kotlin 和 Java 代码混合编写**\n\n- Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。\n\n## 1.4 更加良好的函数式编程体验\n\n- Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。\n\n1. **支持函数类型**\n\n- 在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：\n\n```kotlin\nval sum: (Int, Int) -> Int = { x, y -> x + y }\n```\n\n- 这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -> Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。\n\n2. **高阶函数**\n\n- Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：\n\n```kotlin\nfun <T> List<T>.filter(predicate: (T) -> Boolean): List<T> {\n    val result = mutableListOf<T>()\n    for (item in this) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n```\n\n- 该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。\n\n3. **Lambda 表达式**\n\n- Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval evenNumbers = numbers.filter { it % 2 == 0 }\n```\n\n- 以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。\n\n4. **常用函数式操作符**\n\n- Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n# 二、 Kotlin 的应用场景\n\n- 由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：\n\n## 2.1 Android 开发\n\n- Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda\n  表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。\n\n## 2.2 Web 开发\n\n- Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如\n  Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。\n\n## 2.3 数据分析\n\n- Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark\n  配合使用，可以实现高效的数据处理和可视化。\n\n## 2.4 游戏开发\n\n- Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin\n  作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin\n  进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。\n\n# 三、总结\n\n- 作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。\n- Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android\n  开发中，Kotlin 已经成为了一种备受热爱的编程语言。\n- 总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。\n- 即使是初学者，也可以通过阅读 [Kotlin 的官方文档和教程](https://www.kotlincn.net/docs/reference/)\n  来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。\n      ","source":"_posts/Kotlin_01_初识Kotlin.md","raw":"---\ntitle: '初识 Kotlin'\ndate: '2023-04-08'\ndescription: 'Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。'\ncover: 'https://www.helloimg.com/images/2023/05/02/oqTWxn.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n> Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。由于其灵活性和可读性，Kotlin 迅速成为 Android 平台上最火热的编程语言之一，并得到越来越多开发者的青睐。\n\n# 一、为什么要学习Kotlin？\n\n## 1.1 更加简洁的语法\n\n- Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。\n\n1. **简化的字符串模版**\n   在 Kotlin 中，我们可以使用 \"$\" 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。\n   例如：\n\n```kotlin\nval name = \"Kotlin\"\nprintln(\"Hello, $name!\") // prints \"Hello, Kotlin!\"\n```\n\n2. **数据类**\n   在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和\n   hashCode() 等一些通用的方法，减少了我们写重复代码的机会。\n   例如：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\n3. **Lambda 表达式**\n   Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。\n   例如：\n\n```kotlin\nval fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\nfruits.filter { it.startsWith(\"a\") }\n    .sortedBy { it }\n    .map { it.toUpperCase() }\n    .forEach { println(it) }\n``` \n\n## 1.2 更好的安全性\n\n- Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。\n\n1. **空安全**\n\n- 在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 \"?\" 操作符来标识可空性。\n  例如，以下代码中的变量 maybeNull 就可以为空：\n\n```kotlin\nvar maybeNull: String? = null\n```\n\n- 如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用\"!!\" 操作符来进行转换。如下例：\n\n```kotlin\nvar notNullVar: String?\nnotNullVar = \"Hello World\" // 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）\nvar length = notNullVar!!.length // 使用 !! 操作符将 notNullVar 转换为非空类型\n```\n\n- 通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。\n\n2. **类型推断**\n\n- Kotlin 会自动推断变量的类型。\n  例如，以下代码中的变量 name 的类型是 String：\n\n```kotlin\nval name = \"Kotlin\"\n```\n\n- 这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。\n\n3. **严格的空安全检查**\n\n- Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。\n  如，以下代码会得到编译时错误：\n\n```kotlin\n// 可能为空的变量\nvar maybeNull: String?\n// 访问变量，需要进行非空检查\nprintln(maybeNull.length)\n```\n\n- 以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 \"?\" 来实现：\n\n```kotlin\nprintln(maybeNull?.length)\n```\n\n- 这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。\n\n## 1.3 更好的互操作性\n\n- Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。\n\n1. **兼容 Java 类库和框架**\n\n- Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java\n  应用程序一起部署和运行。\n\n2. **直接使用 Java 类和方法**\n\n- 在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：\n\n```kotlin\nval pi = Math.PI\n```\n\n3. **使用 JavaBean**\n\n- 在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：\n\n```kotlin\nclass Person {\n    var name: String? = null\n    var age: Int = 0\n}\n```\n\n- 由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。\n\n4. **Kotlin 和 Java 代码混合编写**\n\n- Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。\n\n## 1.4 更加良好的函数式编程体验\n\n- Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。\n\n1. **支持函数类型**\n\n- 在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：\n\n```kotlin\nval sum: (Int, Int) -> Int = { x, y -> x + y }\n```\n\n- 这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -> Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。\n\n2. **高阶函数**\n\n- Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：\n\n```kotlin\nfun <T> List<T>.filter(predicate: (T) -> Boolean): List<T> {\n    val result = mutableListOf<T>()\n    for (item in this) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n```\n\n- 该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。\n\n3. **Lambda 表达式**\n\n- Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval evenNumbers = numbers.filter { it % 2 == 0 }\n```\n\n- 以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。\n\n4. **常用函数式操作符**\n\n- Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n# 二、 Kotlin 的应用场景\n\n- 由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：\n\n## 2.1 Android 开发\n\n- Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda\n  表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。\n\n## 2.2 Web 开发\n\n- Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如\n  Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。\n\n## 2.3 数据分析\n\n- Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark\n  配合使用，可以实现高效的数据处理和可视化。\n\n## 2.4 游戏开发\n\n- Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin\n  作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin\n  进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。\n\n# 三、总结\n\n- 作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。\n- Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android\n  开发中，Kotlin 已经成为了一种备受热爱的编程语言。\n- 总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。\n- 即使是初学者，也可以通过阅读 [Kotlin 的官方文档和教程](https://www.kotlincn.net/docs/reference/)\n  来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。\n      ","slug":"Kotlin_01_初识Kotlin","published":1,"updated":"2023-07-19T09:23:44.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyrm0003m7ho9db6fj8u","content":"<blockquote>\n<p>Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。由于其灵活性和可读性，Kotlin 迅速成为 Android 平台上最火热的编程语言之一，并得到越来越多开发者的青睐。</p>\n</blockquote>\n<h1 id=\"一、为什么要学习Kotlin？\"><a href=\"#一、为什么要学习Kotlin？\" class=\"headerlink\" title=\"一、为什么要学习Kotlin？\"></a>一、为什么要学习Kotlin？</h1><h2 id=\"1-1-更加简洁的语法\"><a href=\"#1-1-更加简洁的语法\" class=\"headerlink\" title=\"1.1 更加简洁的语法\"></a>1.1 更加简洁的语法</h2><ul>\n<li>Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。</li>\n</ul>\n<ol>\n<li><strong>简化的字符串模版</strong><br>在 Kotlin 中，我们可以使用 “$” 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br><span class=\"line\">println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>) <span class=\"comment\">// prints &quot;Hello, Kotlin!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>数据类</strong><br>在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和<br>hashCode() 等一些通用的方法，减少了我们写重复代码的机会。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong><br>Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fruits = listOf(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"string\">&quot;avocado&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;kiwifruit&quot;</span>)</span><br><span class=\"line\">fruits.filter &#123; it.startsWith(<span class=\"string\">&quot;a&quot;</span>) &#125;</span><br><span class=\"line\">    .sortedBy &#123; it &#125;</span><br><span class=\"line\">    .map &#123; it.toUpperCase() &#125;</span><br><span class=\"line\">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-更好的安全性\"><a href=\"#1-2-更好的安全性\" class=\"headerlink\" title=\"1.2 更好的安全性\"></a>1.2 更好的安全性</h2><ul>\n<li>Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。</li>\n</ul>\n<ol>\n<li><strong>空安全</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 “?” 操作符来标识可空性。<br>例如，以下代码中的变量 maybeNull 就可以为空：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String? = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用”!!” 操作符来进行转换。如下例：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> notNullVar: String?</span><br><span class=\"line\">notNullVar = <span class=\"string\">&quot;Hello World&quot;</span> <span class=\"comment\">// 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> length = notNullVar!!.length <span class=\"comment\">// 使用 !! 操作符将 notNullVar 转换为非空类型</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>类型推断</strong></li>\n</ol>\n<ul>\n<li>Kotlin 会自动推断变量的类型。<br>例如，以下代码中的变量 name 的类型是 String：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>严格的空安全检查</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。<br>如，以下代码会得到编译时错误：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可能为空的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String?</span><br><span class=\"line\"><span class=\"comment\">// 访问变量，需要进行非空检查</span></span><br><span class=\"line\">println(maybeNull.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 “?” 来实现：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(maybeNull?.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。</li>\n</ul>\n<h2 id=\"1-3-更好的互操作性\"><a href=\"#1-3-更好的互操作性\" class=\"headerlink\" title=\"1.3 更好的互操作性\"></a>1.3 更好的互操作性</h2><ul>\n<li>Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。</li>\n</ul>\n<ol>\n<li><strong>兼容 Java 类库和框架</strong></li>\n</ol>\n<ul>\n<li>Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java<br>应用程序一起部署和运行。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>直接使用 Java 类和方法</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pi = Math.PI</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>使用 JavaBean</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Kotlin 和 Java 代码混合编写</strong></li>\n</ol>\n<ul>\n<li>Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。</li>\n</ul>\n<h2 id=\"1-4-更加良好的函数式编程体验\"><a href=\"#1-4-更加良好的函数式编程体验\" class=\"headerlink\" title=\"1.4 更加良好的函数式编程体验\"></a>1.4 更加良好的函数式编程体验</h2><ul>\n<li>Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。</li>\n</ul>\n<ol>\n<li><strong>支持函数类型</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sum: (<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -&gt; Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>高阶函数</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">filter</span><span class=\"params\">(predicate: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = mutableListOf&lt;T&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            result.add(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> evenNumbers = numbers.filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用函数式操作符</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n<h1 id=\"二、-Kotlin-的应用场景\"><a href=\"#二、-Kotlin-的应用场景\" class=\"headerlink\" title=\"二、 Kotlin 的应用场景\"></a>二、 Kotlin 的应用场景</h1><ul>\n<li>由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：</li>\n</ul>\n<h2 id=\"2-1-Android-开发\"><a href=\"#2-1-Android-开发\" class=\"headerlink\" title=\"2.1 Android 开发\"></a>2.1 Android 开发</h2><ul>\n<li>Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda<br>表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。</li>\n</ul>\n<h2 id=\"2-2-Web-开发\"><a href=\"#2-2-Web-开发\" class=\"headerlink\" title=\"2.2 Web 开发\"></a>2.2 Web 开发</h2><ul>\n<li>Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如<br>Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。</li>\n</ul>\n<h2 id=\"2-3-数据分析\"><a href=\"#2-3-数据分析\" class=\"headerlink\" title=\"2.3 数据分析\"></a>2.3 数据分析</h2><ul>\n<li>Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark<br>配合使用，可以实现高效的数据处理和可视化。</li>\n</ul>\n<h2 id=\"2-4-游戏开发\"><a href=\"#2-4-游戏开发\" class=\"headerlink\" title=\"2.4 游戏开发\"></a>2.4 游戏开发</h2><ul>\n<li>Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin<br>作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin<br>进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。</li>\n<li>Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android<br>开发中，Kotlin 已经成为了一种备受热爱的编程语言。</li>\n<li>总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。</li>\n<li>即使是初学者，也可以通过阅读 <a href=\"https://www.kotlincn.net/docs/reference/\">Kotlin 的官方文档和教程</a><br>来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>Kotlin 是一门基于 Java 平台且运行于 JVM 上的现代化编程语言。它在保留 Java 语言优势的同时，借鉴了其他编程语言的特性，如 Swift、Scala 等，使得 Kotlin 具有更简洁、安全和高效的编程体验。由于其灵活性和可读性，Kotlin 迅速成为 Android 平台上最火热的编程语言之一，并得到越来越多开发者的青睐。</p>\n</blockquote>\n<h1 id=\"一、为什么要学习Kotlin？\"><a href=\"#一、为什么要学习Kotlin？\" class=\"headerlink\" title=\"一、为什么要学习Kotlin？\"></a>一、为什么要学习Kotlin？</h1><h2 id=\"1-1-更加简洁的语法\"><a href=\"#1-1-更加简洁的语法\" class=\"headerlink\" title=\"1.1 更加简洁的语法\"></a>1.1 更加简洁的语法</h2><ul>\n<li>Kotlin 的语法比 Java 更加简洁明了，代码行数相对较少，能够提高代码的可读性和可维护性。</li>\n</ul>\n<ol>\n<li><strong>简化的字符串模版</strong><br>在 Kotlin 中，我们可以使用 “$” 符号来表示字符串模版，将变量直接嵌入到字符串中，很方便。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br><span class=\"line\">println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>) <span class=\"comment\">// prints &quot;Hello, Kotlin!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>数据类</strong><br>在大多数情况下，用于存储数据的类仅需包含一些属性、构造函数及其 getter/setter 方法。在 Kotlin 中，我们可以通过定义一个数据类来实现这个目的。数据类自动生成 toString()、equals() 和<br>hashCode() 等一些通用的方法，减少了我们写重复代码的机会。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong><br>Lambda 表达式是一个非常强大的工具，可以让我们更简洁地定义函数，尤其是针对集合的操作。<br>例如：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fruits = listOf(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"string\">&quot;avocado&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;kiwifruit&quot;</span>)</span><br><span class=\"line\">fruits.filter &#123; it.startsWith(<span class=\"string\">&quot;a&quot;</span>) &#125;</span><br><span class=\"line\">    .sortedBy &#123; it &#125;</span><br><span class=\"line\">    .map &#123; it.toUpperCase() &#125;</span><br><span class=\"line\">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-更好的安全性\"><a href=\"#1-2-更好的安全性\" class=\"headerlink\" title=\"1.2 更好的安全性\"></a>1.2 更好的安全性</h2><ul>\n<li>Kotlin 提供了一些安全性的特性，如空指针安全、类型推断和严格的空安全检查等，可以避免一些常见的编程错误。</li>\n</ul>\n<ol>\n<li><strong>空安全</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，为了避免空指针异常，我们需要在变量声明的时候就确定变量是否可以为空，如果需要为空，则需要使用 “?” 操作符来标识可空性。<br>例如，以下代码中的变量 maybeNull 就可以为空：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String? = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果这个变量不可以为空，则不能赋值为 null。如果尝试将一个非 null 值赋值给可空变量，则需要使用”!!” 操作符来进行转换。如下例：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> notNullVar: String?</span><br><span class=\"line\">notNullVar = <span class=\"string\">&quot;Hello World&quot;</span> <span class=\"comment\">// 这里 notNullVar 能够被赋值为 null 吗？（答案是不能）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> length = notNullVar!!.length <span class=\"comment\">// 使用 !! 操作符将 notNullVar 转换为非空类型</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这种方式，Kotlin 可以更好地处理 null 值，减少了空指针异常的发生。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>类型推断</strong></li>\n</ol>\n<ul>\n<li>Kotlin 会自动推断变量的类型。<br>例如，以下代码中的变量 name 的类型是 String：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这种类型推断可以减少程序员的工作量，也有助于减少类型转换的错误。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>严格的空安全检查</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了严格的空安全检查，这意味着任何可能为空的变量都需要进行处理。例如，当我们尝试访问一个可能为空的变量时，Kotlin 会在编译时检查该变量是否为空，并提醒我们进行处理，以避免空指针异常。<br>如，以下代码会得到编译时错误：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可能为空的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maybeNull: String?</span><br><span class=\"line\"><span class=\"comment\">// 访问变量，需要进行非空检查</span></span><br><span class=\"line\">println(maybeNull.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，变量 maybeNull 可能为 null，因此需要进行判空处理。我们可以使用安全调用操作符 “?” 来实现：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(maybeNull?.length)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样，如果 maybeNull 为 null，则整个表达式返回 null，不会报 NullPointerException 异常。</li>\n</ul>\n<h2 id=\"1-3-更好的互操作性\"><a href=\"#1-3-更好的互操作性\" class=\"headerlink\" title=\"1.3 更好的互操作性\"></a>1.3 更好的互操作性</h2><ul>\n<li>Kotlin 可以无缝地与 Java 进行交互，同时还支持 JavaScript 等其他平台，可以轻松地与其他平台集成。</li>\n</ul>\n<ol>\n<li><strong>兼容 Java 类库和框架</strong></li>\n</ol>\n<ul>\n<li>Kotlin 可以像 Java 一样使用类库和框架，包括 Spring、Hibernate 等。Kotlin 的语言特性和 Java 完全兼容，因此 Kotlin 源码可以编译成与 Java 相同的字节码，并与 Java<br>应用程序一起部署和运行。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>直接使用 Java 类和方法</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，可以直接使用 Java 的类和方法，而不需要任何特殊处理。例如，以下代码中的 Math 类是 Java 类，但在 Kotlin 中可以直接使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pi = Math.PI</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>使用 JavaBean</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中可以使用 JavaBean，即符合 JavaBean 规范的类，这意味着可以使用 getter 和 setter 方法来访问和修改属性。例如，以下代码中的 Person 类就是一个 JavaBean：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于 Kotlin 的属性访问器会自动生成 getter 和 setter 方法，因此我们可以完全符合 JavaBean 规范地访问和修改属性。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Kotlin 和 Java 代码混合编写</strong></li>\n</ol>\n<ul>\n<li>Kotlin 代码可以和 Java 代码混合编写，相互调用。例如，Java 代码可以调用 Kotlin 代码中的函数和类，反之亦然。这样，Kotlin 可以逐步替代 Java，或者与 Java 共存，方便开发者平稳过渡。</li>\n</ul>\n<h2 id=\"1-4-更加良好的函数式编程体验\"><a href=\"#1-4-更加良好的函数式编程体验\" class=\"headerlink\" title=\"1.4 更加良好的函数式编程体验\"></a>1.4 更加良好的函数式编程体验</h2><ul>\n<li>Kotlin 支持很多函数式编程的特性，如 lambda 表达式、高阶函数、闭包等，使得函数式编程变得更加简单和优雅。</li>\n</ul>\n<ol>\n<li><strong>支持函数类型</strong></li>\n</ol>\n<ul>\n<li>在 Kotlin 中，函数是一等公民，函数类型可以像变量一样进行声明和使用。例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sum: (<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这表示定义了一个名为 sum 的变量，其类型为 (Int, Int) -&gt; Int，即函数类型，该函数接受两个 Int 类型的参数并返回一个 Int 类型的结果，lambda 表达式中实现了对应的逻辑。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>高阶函数</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持高阶函数，这意味着我们可以将函数作为参数或返回值传递给其他函数。例如，以下代码中的 filter 函数就是一个高阶函数：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">filter</span><span class=\"params\">(predicate: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = mutableListOf&lt;T&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            result.add(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该函数接受一个函数类型的参数 predicate，用于判断每个元素是否满足条件，并返回满足条件的元素列表。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Lambda 表达式</strong></li>\n</ol>\n<ul>\n<li>Kotlin 支持 Lambda 表达式，使得函数式编程更加自然。Lambda 表达式可以简化代码，增强可读性，例如：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> evenNumbers = numbers.filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上代码中，evenNumbers 变量包含了 numbers 列表中的所有偶数。Lambda 表达式中的 it 表示列表元素本身。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用函数式操作符</strong></li>\n</ol>\n<ul>\n<li>Kotlin 提供了一些常用的函数式操作符来简化代码，例如 map、reduce、fold 等。这些操作符可以帮助我们更加方便地对集合进行处理，提高开发效率。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n<h1 id=\"二、-Kotlin-的应用场景\"><a href=\"#二、-Kotlin-的应用场景\" class=\"headerlink\" title=\"二、 Kotlin 的应用场景\"></a>二、 Kotlin 的应用场景</h1><ul>\n<li>由于 Kotlin 兼具 Java 的互操作性和其他语言的现代化特性，在许多应用场景下都有着广泛的应用。以下是一些常见的使用场景：</li>\n</ul>\n<h2 id=\"2-1-Android-开发\"><a href=\"#2-1-Android-开发\" class=\"headerlink\" title=\"2.1 Android 开发\"></a>2.1 Android 开发</h2><ul>\n<li>Kotlin 在 Android 开发中的应用，其最大的优势在于提高开发效率和项目质量。相较于 Java 语言，Kotlin 的语法更加简洁，支持各种现代化的语言特性，如空安全、扩展函数、内联函数以及 lambda<br>表达式等，可以减少代码量并提供更加简洁的 API 调用方式。此外，Kotlin 还提供了一些有用的库，如 Anko 和 KTX，使得 Android 开发工作更加便捷和快速。</li>\n</ul>\n<h2 id=\"2-2-Web-开发\"><a href=\"#2-2-Web-开发\" class=\"headerlink\" title=\"2.2 Web 开发\"></a>2.2 Web 开发</h2><ul>\n<li>Kotlin 可以与 JavaScript 搭配使用，也就意味着可以进行 Web 开发，特别是后端服务器的开发。Kotlin 具有各种现代化的编程特性，支持异步编程、可扩展性、防止出错的机制，同时也有自己的多种构建工具，比如<br>Gradle 和 Maven 等。通过使用 Kotlin 进行 Web 开发，可以大大减少编写样板代码的时间，同时也有利于提高代码质量和代码的可维护性。</li>\n</ul>\n<h2 id=\"2-3-数据分析\"><a href=\"#2-3-数据分析\" class=\"headerlink\" title=\"2.3 数据分析\"></a>2.3 数据分析</h2><ul>\n<li>Kotlin 也被越来越多的数据科学家和分析师采用，适合处理大规模的数据量。通过 Kotlin 的强类型系统，程序员可以更好地管理和操作数据，并且确保代码的正确性和可靠性。在数据分析和处理领域，Kotlin 与 Apache Spark<br>配合使用，可以实现高效的数据处理和可视化。</li>\n</ul>\n<h2 id=\"2-4-游戏开发\"><a href=\"#2-4-游戏开发\" class=\"headerlink\" title=\"2.4 游戏开发\"></a>2.4 游戏开发</h2><ul>\n<li>Kotlin 可以作为 Unity 引擎中的一种脚本语言进行游戏开发，Unity 开发者可以直接使用 Kotlin 进行游戏逻辑开发、性能优化等。Kotlin<br>作为一种静态类型语言，有助于减少运行时错误，并提供了很多具有吸引力的特性，如扩展函数、类委托、lambda 表达式、协程等，这些特性可以使得代码更加简洁、易读、易维护，也有利于提高开发效率。通过使用 Kotlin<br>进行游戏开发，可以增加游戏逻辑的可读性，并且减少繁琐的代码编写工作，提高开发效率和质量。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>作为一个已经工作了大半年的安卓开发程序员，在已经有了一定的Java基础后，我觉得是时候开始着手Kotlin的学习了。</li>\n<li>Kotlin 是一个由 JetBrains 开发的静态类型编程语言，主要用于移动端开发、Web 开发、数据分析和游戏开发等领域。它是一种现代化的编程语言，可以在保证易读易写之间提供足够的类型检查和安全性。在 Android<br>开发中，Kotlin 已经成为了一种备受热爱的编程语言。</li>\n<li>总之，Kotlin 是一个非常有用的编程语言，它具有很强的兼容性、可扩展性和易读易写性，可以在各种应用场景下发挥作用。</li>\n<li>即使是初学者，也可以通过阅读 <a href=\"https://www.kotlincn.net/docs/reference/\">Kotlin 的官方文档和教程</a><br>来了解并掌握这个新语言的特点和优势，开始使用 Kotlin 进行程序开发。</li>\n</ul>\n"},{"title":"Kotlin 函数式编程思想概述","date":"2023-04-10T00:00:00.000Z","description":"函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。","cover":"https://www.helloimg.com/images/2023/05/13/oxuwrS.webp","_content":"\n> Kotlin是一种多范式、Java虚拟机上运行的编程语言，它有着现代化的语法和强大的函数式编程特性。函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。在现代软件开发中，函数式编程已经逐渐成为了一种趋势。\n\n# 一、函数式编程\n\n## 1.1 函数式编程的概念\n\n- 函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda\n  表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。\n- 与传统的命令式编程（Imperative\n  Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。\n- 在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation\n  的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。\n\n## 1.2 函数和方法的区别\n\n在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。\n\n- 函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。\n- 方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。\n\n在面向对象编程中，方法经常被用来执行某个特定对象的行为，也**经常涉及**到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，**通常不涉及**到类和对象的概念。\n**总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。**\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n## 1.3 面向对象编程和函数式编程的区别\n\n**面向对象编程**（Object-Oriented Programming，OOP）和**函数式编程**（Functional Programming，FP）是两种不同的编程范式。\n\n### 1.3.1 面向对象编程\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2mtE.webp\">\n\n面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：**请谈谈你对面向对象编程概念的理解。** 那么什么是对象？什么是面向对象编程呢？\n\n- Java中，\"万物皆对象\"。这样类似的说法有很多，比如 SQL 中：\"万物皆表\"，Git 中：\"万物皆版本\"等等...这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。\n- 那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。\n- \"万物皆对象\"这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。\n- 面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。\n\n### 1.3.2 函数式编程\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2svY.webp\">\n\n- 函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n- 在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n- \"函数即数据\"这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。\n- 函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。\n\n### 1.3.3 它们的不同之处\n\n1. 编程思想不同\n   面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n\n2. 松耦合度不同\n   面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。\n\n3. 副作用处理不同\n   副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n\n4. 可变性处理不同\n   面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。\n\n5. 代码风格不同\n   面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2tf9.jpg\"  width=\"30%\">\n\n### 1.3.4 两种编程范式的运用\n\n- 面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。\n- 函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。\n- 可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，**OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。**\n\n# 二、初步接触函数式编程\n\n## Kotlin中函数的众多写法\n\n- 在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：\n\n```java\nclass Fun_ {\n    public int addNumbers(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。\n\n- 接下来我们看一下 Kotlin 中函数的各种花式写法：\n\n1. 普通函数\n\n```kotlin\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n2. 省略返回类型的函数：\n\n```kotlin\nfun multiply(a: Int, b: Int) = a * b\n```\n\n3. 单表达式函数：\n\n```kotlin\nfun isEven(num: Int) = num % 2 == 0\n```\n\n4. 带默认参数的函数：\n\n```kotlin\nfun showMessage(message: String, times: Int = 1) {\n    repeat(times) {\n        println(message)\n    }\n}\n```\n\n5. 带具名参数调用的函数：\n\n```kotlin\nshowMessage(message = \"Hello\", times = 3)\n```\n\n6. 使用 lambda 表达式的函数：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEach { println(it) }\n```\n\n7. 带有高阶函数参数的函数：\n\n```kotlin\nfun processNumbers(numbers: List<Int>, action: (Int) -> Unit) {\n    for (number in numbers) {\n        action(number)\n    }\n}\n\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n8. 使用函数类型别名的函数：\n\n```kotlin\ntypealias Processor = (Int) -> Unit\n\nfun processNumbers(numbers: List<Int>, action: Processor) {\n    for (number in numbers) {\n        action(number)\n    }\n}\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2AqX.gif\">\n\n- 没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。\n- Kotlin 中的函数可以具有**默认参数、具名参数调用、扩展函数、局部函数**等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。\n- 见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。\n- 它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。\n\n# 三、总结\n\n- 在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。\n- 还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。\n- 你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！","source":"_posts/Kotlin_02_Kotlin函数式编程思想概述.md","raw":"---\ntitle: 'Kotlin 函数式编程思想概述'\ndate: '2023-04-10'\ndescription: '函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。'\ncover: 'https://www.helloimg.com/images/2023/05/13/oxuwrS.webp'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程 \n\n---\n\n> Kotlin是一种多范式、Java虚拟机上运行的编程语言，它有着现代化的语法和强大的函数式编程特性。函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。在现代软件开发中，函数式编程已经逐渐成为了一种趋势。\n\n# 一、函数式编程\n\n## 1.1 函数式编程的概念\n\n- 函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda\n  表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。\n- 与传统的命令式编程（Imperative\n  Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。\n- 在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation\n  的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。\n\n## 1.2 函数和方法的区别\n\n在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。\n\n- 函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。\n- 方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。\n\n在面向对象编程中，方法经常被用来执行某个特定对象的行为，也**经常涉及**到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，**通常不涉及**到类和对象的概念。\n**总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。**\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n## 1.3 面向对象编程和函数式编程的区别\n\n**面向对象编程**（Object-Oriented Programming，OOP）和**函数式编程**（Functional Programming，FP）是两种不同的编程范式。\n\n### 1.3.1 面向对象编程\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2mtE.webp\">\n\n面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：**请谈谈你对面向对象编程概念的理解。** 那么什么是对象？什么是面向对象编程呢？\n\n- Java中，\"万物皆对象\"。这样类似的说法有很多，比如 SQL 中：\"万物皆表\"，Git 中：\"万物皆版本\"等等...这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。\n- 那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。\n- \"万物皆对象\"这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。\n- 面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。\n\n### 1.3.2 函数式编程\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2svY.webp\">\n\n- 函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n- 在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n- \"函数即数据\"这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。\n- 函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。\n\n### 1.3.3 它们的不同之处\n\n1. 编程思想不同\n   面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。\n\n2. 松耦合度不同\n   面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。\n\n3. 副作用处理不同\n   副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。\n\n4. 可变性处理不同\n   面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。\n\n5. 代码风格不同\n   面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2tf9.jpg\"  width=\"30%\">\n\n### 1.3.4 两种编程范式的运用\n\n- 面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。\n- 函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。\n- 可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，**OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。**\n\n# 二、初步接触函数式编程\n\n## Kotlin中函数的众多写法\n\n- 在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：\n\n```java\nclass Fun_ {\n    public int addNumbers(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。\n\n- 接下来我们看一下 Kotlin 中函数的各种花式写法：\n\n1. 普通函数\n\n```kotlin\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n2. 省略返回类型的函数：\n\n```kotlin\nfun multiply(a: Int, b: Int) = a * b\n```\n\n3. 单表达式函数：\n\n```kotlin\nfun isEven(num: Int) = num % 2 == 0\n```\n\n4. 带默认参数的函数：\n\n```kotlin\nfun showMessage(message: String, times: Int = 1) {\n    repeat(times) {\n        println(message)\n    }\n}\n```\n\n5. 带具名参数调用的函数：\n\n```kotlin\nshowMessage(message = \"Hello\", times = 3)\n```\n\n6. 使用 lambda 表达式的函数：\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEach { println(it) }\n```\n\n7. 带有高阶函数参数的函数：\n\n```kotlin\nfun processNumbers(numbers: List<Int>, action: (Int) -> Unit) {\n    for (number in numbers) {\n        action(number)\n    }\n}\n\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n8. 使用函数类型别名的函数：\n\n```kotlin\ntypealias Processor = (Int) -> Unit\n\nfun processNumbers(numbers: List<Int>, action: Processor) {\n    for (number in numbers) {\n        action(number)\n    }\n}\nval numbers = listOf(1, 2, 3, 4, 5)\nprocessNumbers(numbers) { println(it) }\n```\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2AqX.gif\">\n\n- 没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。\n- Kotlin 中的函数可以具有**默认参数、具名参数调用、扩展函数、局部函数**等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。\n- 见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。\n- 它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。\n\n# 三、总结\n\n- 在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。\n- 还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。\n- 你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！","slug":"Kotlin_02_Kotlin函数式编程思想概述","published":1,"updated":"2023-07-20T01:13:40.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyrr0007m7ho4jwtc3m8","content":"<blockquote>\n<p>Kotlin是一种多范式、Java虚拟机上运行的编程语言，它有着现代化的语法和强大的函数式编程特性。函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。在现代软件开发中，函数式编程已经逐渐成为了一种趋势。</p>\n</blockquote>\n<h1 id=\"一、函数式编程\"><a href=\"#一、函数式编程\" class=\"headerlink\" title=\"一、函数式编程\"></a>一、函数式编程</h1><h2 id=\"1-1-函数式编程的概念\"><a href=\"#1-1-函数式编程的概念\" class=\"headerlink\" title=\"1.1 函数式编程的概念\"></a>1.1 函数式编程的概念</h2><ul>\n<li>函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda<br>表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。</li>\n<li>与传统的命令式编程（Imperative<br>Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。</li>\n<li>在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation<br>的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。</li>\n</ul>\n<h2 id=\"1-2-函数和方法的区别\"><a href=\"#1-2-函数和方法的区别\" class=\"headerlink\" title=\"1.2 函数和方法的区别\"></a>1.2 函数和方法的区别</h2><p>在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。</p>\n<ul>\n<li>函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。</li>\n<li>方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。</li>\n</ul>\n<p>在面向对象编程中，方法经常被用来执行某个特定对象的行为，也<strong>经常涉及</strong>到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，<strong>通常不涉及</strong>到类和对象的概念。<br><strong>总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。</strong></p>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n<h2 id=\"1-3-面向对象编程和函数式编程的区别\"><a href=\"#1-3-面向对象编程和函数式编程的区别\" class=\"headerlink\" title=\"1.3 面向对象编程和函数式编程的区别\"></a>1.3 面向对象编程和函数式编程的区别</h2><p><strong>面向对象编程</strong>（Object-Oriented Programming，OOP）和<strong>函数式编程</strong>（Functional Programming，FP）是两种不同的编程范式。</p>\n<h3 id=\"1-3-1-面向对象编程\"><a href=\"#1-3-1-面向对象编程\" class=\"headerlink\" title=\"1.3.1 面向对象编程\"></a>1.3.1 面向对象编程</h3><img src=\"https://www.helloimg.com/images/2023/07/19/oA2mtE.webp\">\n\n<p>面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：<strong>请谈谈你对面向对象编程概念的理解。</strong> 那么什么是对象？什么是面向对象编程呢？</p>\n<ul>\n<li>Java中，”万物皆对象”。这样类似的说法有很多，比如 SQL 中：”万物皆表”，Git 中：”万物皆版本”等等…这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。</li>\n<li>那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。</li>\n<li>“万物皆对象”这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。</li>\n<li>面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。</li>\n</ul>\n<h3 id=\"1-3-2-函数式编程\"><a href=\"#1-3-2-函数式编程\" class=\"headerlink\" title=\"1.3.2 函数式编程\"></a>1.3.2 函数式编程</h3><img src=\"https://www.helloimg.com/images/2023/07/19/oA2svY.webp\">\n\n<ul>\n<li>函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</li>\n<li>在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</li>\n<li>“函数即数据”这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。</li>\n<li>函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。</li>\n</ul>\n<h3 id=\"1-3-3-它们的不同之处\"><a href=\"#1-3-3-它们的不同之处\" class=\"headerlink\" title=\"1.3.3 它们的不同之处\"></a>1.3.3 它们的不同之处</h3><ol>\n<li><p>编程思想不同<br>面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</p>\n</li>\n<li><p>松耦合度不同<br>面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。</p>\n</li>\n<li><p>副作用处理不同<br>副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</p>\n</li>\n<li><p>可变性处理不同<br>面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。</p>\n</li>\n<li><p>代码风格不同<br>面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。</p>\n</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2tf9.jpg\"  width=\"30%\">\n\n<h3 id=\"1-3-4-两种编程范式的运用\"><a href=\"#1-3-4-两种编程范式的运用\" class=\"headerlink\" title=\"1.3.4 两种编程范式的运用\"></a>1.3.4 两种编程范式的运用</h3><ul>\n<li>面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。</li>\n<li>函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。</li>\n<li>可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，<strong>OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。</strong></li>\n</ul>\n<h1 id=\"二、初步接触函数式编程\"><a href=\"#二、初步接触函数式编程\" class=\"headerlink\" title=\"二、初步接触函数式编程\"></a>二、初步接触函数式编程</h1><h2 id=\"Kotlin中函数的众多写法\"><a href=\"#Kotlin中函数的众多写法\" class=\"headerlink\" title=\"Kotlin中函数的众多写法\"></a>Kotlin中函数的众多写法</h2><ul>\n<li>在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fun_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">addNumbers</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。</p>\n<ul>\n<li>接下来我们看一下 Kotlin 中函数的各种花式写法：</li>\n</ul>\n<ol>\n<li>普通函数</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>省略返回类型的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">multiply</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span> = a * b</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>单表达式函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isEven</span><span class=\"params\">(num: <span class=\"type\">Int</span>)</span></span> = num % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>带默认参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showMessage</span><span class=\"params\">(message: <span class=\"type\">String</span>, times: <span class=\"type\">Int</span> = <span class=\"number\">1</span>)</span></span> &#123;</span><br><span class=\"line\">    repeat(times) &#123;</span><br><span class=\"line\">        println(message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>带具名参数调用的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showMessage(message = <span class=\"string\">&quot;Hello&quot;</span>, times = <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>使用 lambda 表达式的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">numbers.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>带有高阶函数参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>使用函数类型别名的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Processor = (<span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: <span class=\"type\">Processor</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2AqX.gif\">\n\n<ul>\n<li>没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。</li>\n<li>Kotlin 中的函数可以具有<strong>默认参数、具名参数调用、扩展函数、局部函数</strong>等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。</li>\n<li>见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。</li>\n<li>它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。</li>\n<li>还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。</li>\n<li>你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>Kotlin是一种多范式、Java虚拟机上运行的编程语言，它有着现代化的语法和强大的函数式编程特性。函数式编程是一种以函数为基础、抽象和组合计算单元的编程范式。在现代软件开发中，函数式编程已经逐渐成为了一种趋势。</p>\n</blockquote>\n<h1 id=\"一、函数式编程\"><a href=\"#一、函数式编程\" class=\"headerlink\" title=\"一、函数式编程\"></a>一、函数式编程</h1><h2 id=\"1-1-函数式编程的概念\"><a href=\"#1-1-函数式编程的概念\" class=\"headerlink\" title=\"1.1 函数式编程的概念\"></a>1.1 函数式编程的概念</h2><ul>\n<li>函数式编程（Functional Programming）是一种编程范型，它将计算机程序视为函数的组合，强调使用纯函数（Pure Function）、高阶函数（Higher-order Function）、lambda<br>表达式（Lambda Expression）等来处理数据。函数式编程中的函数被视为数学上的函数，它不会修改自己的输入，也不会对程序外部环境产生影响，而只是根据输入返回一个新的值。</li>\n<li>与传统的命令式编程（Imperative<br>Programming）相比，函数式编程更加注重计算结果而非计算过程，使得代码更加简洁、可读性更强，适合处理大规模数据和并发处理等场景。同时，函数式编程也具有很好的可测试性、可维护性和可扩展性，能够更好地应对软件开发中的变化和需求。</li>\n<li>在函数式编程中，通常采用不可变数据（Immutable Data）的方式来避免状态变化带来的问题，并使用函数组合的方式来实现复杂的逻辑，以及利用 Lazy Evaluation<br>的惰性求值策略来提高程序的性能。这些特性都让函数式编程在处理数据和逻辑上具有独特的优势。</li>\n</ul>\n<h2 id=\"1-2-函数和方法的区别\"><a href=\"#1-2-函数和方法的区别\" class=\"headerlink\" title=\"1.2 函数和方法的区别\"></a>1.2 函数和方法的区别</h2><p>在Java中，我们有个很重要的概念：方法。它和函数的本质都是实现某种特定功能的代码块，因此可能乍一看感觉函数和方法是同一个意思，其实不然。</p>\n<ul>\n<li>函数（Function）是指独立于任何类或对象的代码块，它接收一些输入参数，对这些参数进行处理并返回值，不依赖外部状态，也不修改外部状态。函数可以被其他函数或方法调用，以实现更加复杂的功能。</li>\n<li>方法（Method）是指定义在一个类或对象中的函数，它与类或对象的状态和属性紧密相关联，可以访问和修改这些状态和属性。方法除了可以像函数一样被调用，还可以通过类或对象来调用，实现对内部状态和属性的操作。</li>\n</ul>\n<p>在面向对象编程中，方法经常被用来执行某个特定对象的行为，也<strong>经常涉及</strong>到继承、多态等概念。而在函数式编程中，函数更加强调纯函数和不可变数据的使用，<strong>通常不涉及</strong>到类和对象的概念。<br><strong>总的来说，函数和方法都是实现某种特定功能的代码块，但它们的使用方式和概念在不同的编程语言和编程范式中可能存在差异。</strong></p>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2JBv.jpg\">\n\n<h2 id=\"1-3-面向对象编程和函数式编程的区别\"><a href=\"#1-3-面向对象编程和函数式编程的区别\" class=\"headerlink\" title=\"1.3 面向对象编程和函数式编程的区别\"></a>1.3 面向对象编程和函数式编程的区别</h2><p><strong>面向对象编程</strong>（Object-Oriented Programming，OOP）和<strong>函数式编程</strong>（Functional Programming，FP）是两种不同的编程范式。</p>\n<h3 id=\"1-3-1-面向对象编程\"><a href=\"#1-3-1-面向对象编程\" class=\"headerlink\" title=\"1.3.1 面向对象编程\"></a>1.3.1 面向对象编程</h3><img src=\"https://www.helloimg.com/images/2023/07/19/oA2mtE.webp\">\n\n<p>面向对象编程相信有过Java基础的同学肯定不会陌生，面试也会经常出现一个送命题：<strong>请谈谈你对面向对象编程概念的理解。</strong> 那么什么是对象？什么是面向对象编程呢？</p>\n<ul>\n<li>Java中，”万物皆对象”。这样类似的说法有很多，比如 SQL 中：”万物皆表”，Git 中：”万物皆版本”等等…这些都反映了一种观念，即我们可以将所有的事物都抽象为同一种基本元素，从而简化和统一对待各种不同的物品或概念。</li>\n<li>那么什么是对象呢？它当然不是指现实生活中的男女朋友，在 Java 中，对象就是实体化的类，保存了类中定义的属性和方法。在 Java 中，几乎所有的数据类型和操作都可以看作是对象和方法的组合。</li>\n<li>“万物皆对象”这个理念认为，任何事物都可以抽象为一个对象，并通过对象之间的交互来实现各种功能。这种思想强调了代码的可重用性、可维护性和可扩展性。</li>\n<li>面向对象编程的含义是将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。面向对象编程强调了程序的模块化和组件化，使得程序更易于理解、修改和维护。</li>\n</ul>\n<h3 id=\"1-3-2-函数式编程\"><a href=\"#1-3-2-函数式编程\" class=\"headerlink\" title=\"1.3.2 函数式编程\"></a>1.3.2 函数式编程</h3><img src=\"https://www.helloimg.com/images/2023/07/19/oA2svY.webp\">\n\n<ul>\n<li>函数式编程（Functional Programming）是一种以函数为核心的编程范式，与传统的命令式编程不同，它强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</li>\n<li>在函数式编程中，函数被视为一等公民，可以像其他数据类型一样被传递、返回和组合。同时，函数式编程还强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</li>\n<li>“函数即数据”这个理念认为，函数和数据在函数式编程中是等价的，都可以被看作是一种数学上的值。函数式编程将复杂的问题分解为多个简单的函数，并通过函数的组合和变换来解决问题，使得程序更加清晰、简洁和易于理解。</li>\n<li>函数式编程强调无状态性和不可变性，即不改变原有的数据结构和状态。这种特性使得函数式编程更具有可重用性和可测试性，在并发编程中也有着特别的优势。</li>\n</ul>\n<h3 id=\"1-3-3-它们的不同之处\"><a href=\"#1-3-3-它们的不同之处\" class=\"headerlink\" title=\"1.3.3 它们的不同之处\"></a>1.3.3 它们的不同之处</h3><ol>\n<li><p>编程思想不同<br>面向对象编程强调将程序中的数据和操作封装在一起，形成一个个对象，并通过对象之间的协作和交互来实现程序的功能。而函数式编程则强调将计算过程尽量转换为若干个函数之间的组合和运算，而不是通过对程序状态进行赋值和修改来实现。</p>\n</li>\n<li><p>松耦合度不同<br>面向对象编程中，不同对象之间的协作和交互需要通过公共接口来实现，因此面向对象编程具有较强的耦合性，即类之间的关系比较紧密。而函数式编程中，函数之间的协作和交互通过参数和返回值来实现，因此函数式编程具有较弱的耦合性，即函数之间的关系比较松散。</p>\n</li>\n<li><p>副作用处理不同<br>副作用指对外部环境产生的影响，包括对变量值、I/O、数据库等的修改。面向对象编程通常通过封装保护数据，控制副作用的发生；而函数式编程则强调避免副作用，即尽可能地消除函数对外部环境的依赖，使得同样的输入能够得到同样的输出。</p>\n</li>\n<li><p>可变性处理不同<br>面向对象编程中，对象的状态可以被改变；而函数式编程强调不可变性，即一旦一个值被定义后，其值就不能被更改。</p>\n</li>\n<li><p>代码风格不同<br>面向对象编程中，常常会使用类、对象、继承等关键字和概念，代码的风格比较严谨、精确。而函数式编程则注重表达式的简洁和流畅，代码的风格比较自然和直观。</p>\n</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2tf9.jpg\"  width=\"30%\">\n\n<h3 id=\"1-3-4-两种编程范式的运用\"><a href=\"#1-3-4-两种编程范式的运用\" class=\"headerlink\" title=\"1.3.4 两种编程范式的运用\"></a>1.3.4 两种编程范式的运用</h3><ul>\n<li>面向对象编程是最早流行起来的编程范式之一，现在几乎所有主流的编程语言都支持面向对象编程。例如，Java、C++、Python、Ruby、Scala、Swift、Kotlin、JavaScript等。</li>\n<li>函数式编程在近年来逐渐流行起来，现在也有越来越多的编程语言开始支持函数式编程范式。例如，Haskell、Scala、Erlang、Swift、JavaScript、Python、Kotlin等。</li>\n<li>可以看出，很多编程语言都同时使用了这两种编程范式理念，总之，<strong>OOP 和 FP 都是有效的编程方法，各有优劣，可根据具体情况选择适合的编程范式。</strong></li>\n</ul>\n<h1 id=\"二、初步接触函数式编程\"><a href=\"#二、初步接触函数式编程\" class=\"headerlink\" title=\"二、初步接触函数式编程\"></a>二、初步接触函数式编程</h1><h2 id=\"Kotlin中函数的众多写法\"><a href=\"#Kotlin中函数的众多写法\" class=\"headerlink\" title=\"Kotlin中函数的众多写法\"></a>Kotlin中函数的众多写法</h2><ul>\n<li>在 Java 中，声明一个方法的写法比较单一，比如，这是一个计算两个值相加的方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fun_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">addNumbers</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，通过改变访问修饰符（public）、返回类型（int）、形参列表(int a, int b)等，可以实现方法的一些变化，但是总体来说结构是比较固定的。</p>\n<ul>\n<li>接下来我们看一下 Kotlin 中函数的各种花式写法：</li>\n</ul>\n<ol>\n<li>普通函数</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>省略返回类型的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">multiply</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span> = a * b</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>单表达式函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isEven</span><span class=\"params\">(num: <span class=\"type\">Int</span>)</span></span> = num % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>带默认参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showMessage</span><span class=\"params\">(message: <span class=\"type\">String</span>, times: <span class=\"type\">Int</span> = <span class=\"number\">1</span>)</span></span> &#123;</span><br><span class=\"line\">    repeat(times) &#123;</span><br><span class=\"line\">        println(message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>带具名参数调用的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showMessage(message = <span class=\"string\">&quot;Hello&quot;</span>, times = <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>使用 lambda 表达式的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">numbers.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>带有高阶函数参数的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>使用函数类型别名的函数：</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Processor = (<span class=\"built_in\">Int</span>) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">processNumbers</span><span class=\"params\">(numbers: <span class=\"type\">List</span>&lt;<span class=\"type\">Int</span>&gt;, action: <span class=\"type\">Processor</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (number <span class=\"keyword\">in</span> numbers) &#123;</span><br><span class=\"line\">        action(number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">processNumbers(numbers) &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2AqX.gif\">\n\n<ul>\n<li>没看错吧，这么多？！还真有这么多，而且还不止这么多，如果加上访问修饰符等等的变化，那可真是百花齐放了。</li>\n<li>Kotlin 中的函数可以具有<strong>默认参数、具名参数调用、扩展函数、局部函数</strong>等特性，这些特性使得 Kotlin 的函数非常灵活和易于使用。</li>\n<li>见识到函数式编程的威力了吗？首先在函数的申明和调用方面就如此的灵活多变，它可以让程序员更加关注解决问题应该实现什么逻辑，而不是如何实现。</li>\n<li>它通过将函数看作一等公民以及使用大量的高阶函数和 lambda 表达式等特性，使得代码更加简洁、易于理解和维护，同时也提高了代码的可复用性和可测试性。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在见识了 Kotlin 的函数世界后，我第一感觉是好像代码是变得简洁了，但是貌似可读性并没有增加，反而是更让人摸不着头脑。可能还需要熟练之后才能体会到其带来的优势。</li>\n<li>还有一个问题，我觉得如此众多的写法，而不同的程序员又有不同的编码习惯，这可能会导致不同的 Kotlin 程序员之间的代码互读性进一步变差。</li>\n<li>你是什么想法呢？可以在下方评论区进行讨论或者直接联系我！</li>\n</ul>\n"},{"title":"Kotlin 中的空安全设计详解","date":"2023-07-19T00:00:00.000Z","description":"之前对 Kotlin 的基本语法、变量声明、空安全设计和兼容性做了笼统的介绍，今天对其中的空安全设计做一个详细的剖析。","cover":"https://www.helloimg.com/images/2023/07/19/oAMLZr.jpg","_content":"\n# 一、变量\n\n- 在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中`变量声明和赋值`方面的异同。\n- 首先，在 Java 中，声明一个变量的格式是：`<数据类型> <变量名>;`缺一不可，比如：\n\n```java\nclass Sample {\n    int age; // 声明一个整型变量 age\n    String name; // 声明一个字符串型变量 name\n}\n```\n\n- 除了简单声明变量，还可以同时进行初始化，即：`<数据类型> <变量名> = <初始值>;`如：\n\n```java\nclass Sample {\n    int age = 25; // 声明一个整型变量 age，并初始化为 25\n    String name = \"John\"; // 声明一个字符串型变量 name，并初始化为 \"John\"\n}\n```\n\n- 然后，在 Kotlin 中，声明一个变量的格式是：`var <变量名>: <数据类型>`，像这样：\n\n```kotlin\n    var name: String\n```\n\n- 一眼看去和 Java 有几处不同：\n   1. 有一个`var`关键字\n   2. 类型和变量名位置互换了\n   3. 中间是用冒号分隔的\n   4. 结尾没有分号（Kotlin 里面不需要分号）\n\n- 虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：`Property must be initialized or be abstract`。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）\n- 彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oAMSST.gif\">\n\n- 不不不！其实是有原因的，在 Kotlin 中，变量是`没有默认值`的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：\n\n```java\nclass Sample {\n    String name; // 默认值是 null\n    int count; // 默认值是 0\n}\n```\n\n- 好吧，你没有默认值那我给你一个吧，我这样写：\n\n```kotlin\n    var name: String = null\n```\n\n- 哎呀又报错了，IDE 告诉你说：`Null can not be a value of a non-null type View`，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。\n\n# 二、空安全设计\n\n## 2.1 NullPointerException\n\n- 先介绍一个异常：`NullPointerException` - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str = null;\n        System.out.println(str.length()); // 触发 NullPointerException\n    }\n}\n```\n\n- 具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。\n\n## 2.2 空安全设计\n\n- 好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？\n- 简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而`避免 NullPointerException`。\n- 可别小看这一点，单单`避免 NullPointerException`这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。\n- 空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：\n\n```java\nclass Sample {\n    @NonNull\n    View view = null;//IDE 会发出警告：'null' is assigned to a variable that is annotated with @NotNull\n}\n```\n\n- 到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 `warning` 变成了 `error`（拒绝编译）：\n\n```kotlin\n    var view: View = null //IDE 会提示错误，Null can not be a value of a non-null type View\n```\n\n- `在 Kotlin 里面，所有的变量默认都是不允许为空的`，如果你给它赋值 null，就会报错，像上面那样。\n- Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。\n- 这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：\n\n```kotlin\nclass User {\n    var name: String = null // 这样写会报错，但该变量无法保证空与否\n}\n```\n\n- 这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：\n\n```kotlin\nclass User {\n    var name: String? = null\n}\n```\n\n- 加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。\n- 这种类型之后加 ? 的写法，在 Kotlin 里叫`可空类型`。不过，当我们使用了可空类型的变量后，会有新的问题：\n\n```kotlin\n    var view: View? = null\n    view.setBackgroundColor(Color.RED)\n    // 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?\n```\n\n- 对于我们定义的`可能为空`的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：\n\n```kotlin\n    if (view != null) {\n        view.setBackgroundColor(Color.RED)\n        // 这样写也会报错，Smart cast to 'View' is impossible, because 'view' is a mutable property that could have been changed by this time\n    } \n```\n\n- 这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在`多线程`情况下，其他线程可能把它再改成空的。\n- 那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是` . `而是` ?.`：\n\n```kotlin\n    view?.setBackgroundColor(Color.RED)\n```\n\n- 这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到`线程安全`，因此这种写法叫做`safe call`。\n- 另外还有一种双感叹号的用法：\n\n```kotlin\n    view!!.setBackgroundColor(Color.RED)\n```\n\n- 意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 `non-null asserted call`。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。\n- 其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：\n  1. 变量需要手动初始化，如果不初始化的话会报错； \n  2. 变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； \n  3. 变量用 ? 设置为可空的时候，使用的时候因为`可能为空`又报错。\n\n- 关于空安全，最重要的是记住一点：所谓`可空不可空`，关注的全都是`使用的时候`，即`这个变量在使用时是否可能为空`。\n\n- Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：\n\n```kotlin\n  expression ?: defaultValue\n```\n\n- 如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。\n- 一些注意事项：\n  1. defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。\n  2. defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。\n  3. Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c\n  4. Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue\n  5. Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。\n\n- 空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。\n- 但如果你在 MainActivity 里这么写：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    var view: View = findViewById(R.id.tvContent)\n}\n```\n\n- 编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。\n- 那怎么办呢？其实我们很想告诉编译器`我很确定我用的时候绝对不为空，但第一时间我没法给它赋值`。\n- Kotlin 给我们提供了一个选项：`延迟初始化`。\n\n## 2.3 延迟初始化\n\n- 为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：\n\n```kotlin\n    lateinit var view: View\n```\n\n- lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。\n- 它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。\n- 然后我们就可以在 onCreate 中进行初始化了：\n\n```kotlin\n  lateinit var view: View\n  override fun onCreate() {\n      //...\n      view = findViewById(R.id.tvContent)\n  }\n```\n\n- 延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。\n\n## 2.4 类型推断\n\n- 空安全设计到此其实已经差不多讲完了，再补充一点其他内容。\n- Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：\n\n```kotlin\n   var name: String = \"Mike\"//可以直接写成 var name = \"Mike\"\n```\n\n- 这个特性叫做`类型推断`，它跟`动态类型`是不一样的。\n  1. 类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。\n  2. 动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。\n\n## 2.5 val 和 var\n\n- 除了前面提到的 var，我们还可以使用 val 来声明变量：\n\n```kotlin\n    val age = 18\n```\n\n- val 是 Kotlin 在 Java 的`变量`类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。\n- val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。\n\n# 三、总结\n\n- Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。","source":"_posts/Kotlin_03_Kotlin中的空安全设计详解.md","raw":"---\ntitle: 'Kotlin 中的空安全设计详解'\ndate: '2023-07-19'\ndescription: '之前对 Kotlin 的基本语法、变量声明、空安全设计和兼容性做了笼统的介绍，今天对其中的空安全设计做一个详细的剖析。'\ncover: 'https://www.helloimg.com/images/2023/07/19/oAMLZr.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n# 一、变量\n\n- 在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中`变量声明和赋值`方面的异同。\n- 首先，在 Java 中，声明一个变量的格式是：`<数据类型> <变量名>;`缺一不可，比如：\n\n```java\nclass Sample {\n    int age; // 声明一个整型变量 age\n    String name; // 声明一个字符串型变量 name\n}\n```\n\n- 除了简单声明变量，还可以同时进行初始化，即：`<数据类型> <变量名> = <初始值>;`如：\n\n```java\nclass Sample {\n    int age = 25; // 声明一个整型变量 age，并初始化为 25\n    String name = \"John\"; // 声明一个字符串型变量 name，并初始化为 \"John\"\n}\n```\n\n- 然后，在 Kotlin 中，声明一个变量的格式是：`var <变量名>: <数据类型>`，像这样：\n\n```kotlin\n    var name: String\n```\n\n- 一眼看去和 Java 有几处不同：\n   1. 有一个`var`关键字\n   2. 类型和变量名位置互换了\n   3. 中间是用冒号分隔的\n   4. 结尾没有分号（Kotlin 里面不需要分号）\n\n- 虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：`Property must be initialized or be abstract`。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）\n- 彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oAMSST.gif\">\n\n- 不不不！其实是有原因的，在 Kotlin 中，变量是`没有默认值`的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：\n\n```java\nclass Sample {\n    String name; // 默认值是 null\n    int count; // 默认值是 0\n}\n```\n\n- 好吧，你没有默认值那我给你一个吧，我这样写：\n\n```kotlin\n    var name: String = null\n```\n\n- 哎呀又报错了，IDE 告诉你说：`Null can not be a value of a non-null type View`，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。\n\n# 二、空安全设计\n\n## 2.1 NullPointerException\n\n- 先介绍一个异常：`NullPointerException` - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str = null;\n        System.out.println(str.length()); // 触发 NullPointerException\n    }\n}\n```\n\n- 具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。\n\n## 2.2 空安全设计\n\n- 好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？\n- 简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而`避免 NullPointerException`。\n- 可别小看这一点，单单`避免 NullPointerException`这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。\n- 空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：\n\n```java\nclass Sample {\n    @NonNull\n    View view = null;//IDE 会发出警告：'null' is assigned to a variable that is annotated with @NotNull\n}\n```\n\n- 到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 `warning` 变成了 `error`（拒绝编译）：\n\n```kotlin\n    var view: View = null //IDE 会提示错误，Null can not be a value of a non-null type View\n```\n\n- `在 Kotlin 里面，所有的变量默认都是不允许为空的`，如果你给它赋值 null，就会报错，像上面那样。\n- Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。\n- 这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：\n\n```kotlin\nclass User {\n    var name: String = null // 这样写会报错，但该变量无法保证空与否\n}\n```\n\n- 这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：\n\n```kotlin\nclass User {\n    var name: String? = null\n}\n```\n\n- 加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。\n- 这种类型之后加 ? 的写法，在 Kotlin 里叫`可空类型`。不过，当我们使用了可空类型的变量后，会有新的问题：\n\n```kotlin\n    var view: View? = null\n    view.setBackgroundColor(Color.RED)\n    // 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?\n```\n\n- 对于我们定义的`可能为空`的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：\n\n```kotlin\n    if (view != null) {\n        view.setBackgroundColor(Color.RED)\n        // 这样写也会报错，Smart cast to 'View' is impossible, because 'view' is a mutable property that could have been changed by this time\n    } \n```\n\n- 这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在`多线程`情况下，其他线程可能把它再改成空的。\n- 那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是` . `而是` ?.`：\n\n```kotlin\n    view?.setBackgroundColor(Color.RED)\n```\n\n- 这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到`线程安全`，因此这种写法叫做`safe call`。\n- 另外还有一种双感叹号的用法：\n\n```kotlin\n    view!!.setBackgroundColor(Color.RED)\n```\n\n- 意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 `non-null asserted call`。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。\n- 其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：\n  1. 变量需要手动初始化，如果不初始化的话会报错； \n  2. 变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； \n  3. 变量用 ? 设置为可空的时候，使用的时候因为`可能为空`又报错。\n\n- 关于空安全，最重要的是记住一点：所谓`可空不可空`，关注的全都是`使用的时候`，即`这个变量在使用时是否可能为空`。\n\n- Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：\n\n```kotlin\n  expression ?: defaultValue\n```\n\n- 如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。\n- 一些注意事项：\n  1. defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。\n  2. defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。\n  3. Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c\n  4. Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue\n  5. Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。\n\n- 空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。\n- 但如果你在 MainActivity 里这么写：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    var view: View = findViewById(R.id.tvContent)\n}\n```\n\n- 编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。\n- 那怎么办呢？其实我们很想告诉编译器`我很确定我用的时候绝对不为空，但第一时间我没法给它赋值`。\n- Kotlin 给我们提供了一个选项：`延迟初始化`。\n\n## 2.3 延迟初始化\n\n- 为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：\n\n```kotlin\n    lateinit var view: View\n```\n\n- lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。\n- 它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。\n- 然后我们就可以在 onCreate 中进行初始化了：\n\n```kotlin\n  lateinit var view: View\n  override fun onCreate() {\n      //...\n      view = findViewById(R.id.tvContent)\n  }\n```\n\n- 延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。\n\n## 2.4 类型推断\n\n- 空安全设计到此其实已经差不多讲完了，再补充一点其他内容。\n- Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：\n\n```kotlin\n   var name: String = \"Mike\"//可以直接写成 var name = \"Mike\"\n```\n\n- 这个特性叫做`类型推断`，它跟`动态类型`是不一样的。\n  1. 类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。\n  2. 动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。\n\n## 2.5 val 和 var\n\n- 除了前面提到的 var，我们还可以使用 val 来声明变量：\n\n```kotlin\n    val age = 18\n```\n\n- val 是 Kotlin 在 Java 的`变量`类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。\n- val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。\n\n# 三、总结\n\n- Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。","slug":"Kotlin_03_Kotlin中的空安全设计详解","published":1,"updated":"2023-07-22T07:36:07.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyrt0008m7hodd3mdsca","content":"<h1 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h1><ul>\n<li>在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中<code>变量声明和赋值</code>方面的异同。</li>\n<li>首先，在 Java 中，声明一个变量的格式是：<code>&lt;数据类型&gt; &lt;变量名&gt;;</code>缺一不可，比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> age; <span class=\"comment\">// 声明一个整型变量 age</span></span><br><span class=\"line\">    String name; <span class=\"comment\">// 声明一个字符串型变量 name</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>除了简单声明变量，还可以同时进行初始化，即：<code>&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</code>如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">25</span>; <span class=\"comment\">// 声明一个整型变量 age，并初始化为 25</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span>; <span class=\"comment\">// 声明一个字符串型变量 name，并初始化为 &quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后，在 Kotlin 中，声明一个变量的格式是：<code>var &lt;变量名&gt;: &lt;数据类型&gt;</code>，像这样：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>一眼看去和 Java 有几处不同：</p>\n<ol>\n<li>有一个<code>var</code>关键字</li>\n<li>类型和变量名位置互换了</li>\n<li>中间是用冒号分隔的</li>\n<li>结尾没有分号（Kotlin 里面不需要分号）</li>\n</ol>\n</li>\n<li><p>虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：<code>Property must be initialized or be abstract</code>。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）</p>\n</li>\n<li><p>彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oAMSST.gif\">\n\n<ul>\n<li>不不不！其实是有原因的，在 Kotlin 中，变量是<code>没有默认值</code>的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    String name; <span class=\"comment\">// 默认值是 null</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">// 默认值是 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>好吧，你没有默认值那我给你一个吧，我这样写：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>哎呀又报错了，IDE 告诉你说：<code>Null can not be a value of a non-null type View</code>，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。</li>\n</ul>\n<h1 id=\"二、空安全设计\"><a href=\"#二、空安全设计\" class=\"headerlink\" title=\"二、空安全设计\"></a>二、空安全设计</h1><h2 id=\"2-1-NullPointerException\"><a href=\"#2-1-NullPointerException\" class=\"headerlink\" title=\"2.1 NullPointerException\"></a>2.1 NullPointerException</h2><ul>\n<li>先介绍一个异常：<code>NullPointerException</code> - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        System.out.println(str.length()); <span class=\"comment\">// 触发 NullPointerException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。</li>\n</ul>\n<h2 id=\"2-2-空安全设计\"><a href=\"#2-2-空安全设计\" class=\"headerlink\" title=\"2.2 空安全设计\"></a>2.2 空安全设计</h2><ul>\n<li>好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？</li>\n<li>简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而<code>避免 NullPointerException</code>。</li>\n<li>可别小看这一点，单单<code>避免 NullPointerException</code>这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。</li>\n<li>空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//IDE 会发出警告：&#x27;null&#x27; is assigned to a variable that is annotated with @NotNull</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 <code>warning</code> 变成了 <code>error</code>（拒绝编译）：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View = <span class=\"literal\">null</span> <span class=\"comment\">//IDE 会提示错误，Null can not be a value of a non-null type View</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>在 Kotlin 里面，所有的变量默认都是不允许为空的</code>，如果你给它赋值 null，就会报错，像上面那样。</li>\n<li>Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。</li>\n<li>这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span> <span class=\"comment\">// 这样写会报错，但该变量无法保证空与否</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。</li>\n<li>这种类型之后加 ? 的写法，在 Kotlin 里叫<code>可空类型</code>。不过，当我们使用了可空类型的变量后，会有新的问题：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View? = <span class=\"literal\">null</span></span><br><span class=\"line\">view.setBackgroundColor(Color.RED)</span><br><span class=\"line\"><span class=\"comment\">// 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于我们定义的<code>可能为空</code>的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (view != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    view.setBackgroundColor(Color.RED)</span><br><span class=\"line\">    <span class=\"comment\">// 这样写也会报错，Smart cast to &#x27;View&#x27; is impossible, because &#x27;view&#x27; is a mutable property that could have been changed by this time</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在<code>多线程</code>情况下，其他线程可能把它再改成空的。</li>\n<li>那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是<code>.</code>而是<code> ?.</code>：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view?.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到<code>线程安全</code>，因此这种写法叫做<code>safe call</code>。</li>\n<li>另外还有一种双感叹号的用法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view!!.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 <code>non-null asserted call</code>。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。</p>\n</li>\n<li><p>其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：</p>\n<ol>\n<li>变量需要手动初始化，如果不初始化的话会报错； </li>\n<li>变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； </li>\n<li>变量用 ? 设置为可空的时候，使用的时候因为<code>可能为空</code>又报错。</li>\n</ol>\n</li>\n<li><p>关于空安全，最重要的是记住一点：所谓<code>可空不可空</code>，关注的全都是<code>使用的时候</code>，即<code>这个变量在使用时是否可能为空</code>。</p>\n</li>\n<li><p>Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression ?: defaultValue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。</p>\n</li>\n<li><p>一些注意事项：</p>\n<ol>\n<li>defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。</li>\n<li>defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。</li>\n<li>Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c</li>\n<li>Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue</li>\n<li>Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。</li>\n</ol>\n</li>\n<li><p>空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。</p>\n</li>\n<li><p>但如果你在 MainActivity 里这么写：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: View = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。</li>\n<li>那怎么办呢？其实我们很想告诉编译器<code>我很确定我用的时候绝对不为空，但第一时间我没法给它赋值</code>。</li>\n<li>Kotlin 给我们提供了一个选项：<code>延迟初始化</code>。</li>\n</ul>\n<h2 id=\"2-3-延迟初始化\"><a href=\"#2-3-延迟初始化\" class=\"headerlink\" title=\"2.3 延迟初始化\"></a>2.3 延迟初始化</h2><ul>\n<li>为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。</li>\n<li>它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。</li>\n<li>然后我们就可以在 onCreate 中进行初始化了：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    view = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。</li>\n</ul>\n<h2 id=\"2-4-类型推断\"><a href=\"#2-4-类型推断\" class=\"headerlink\" title=\"2.4 类型推断\"></a>2.4 类型推断</h2><ul>\n<li>空安全设计到此其实已经差不多讲完了，再补充一点其他内容。</li>\n<li>Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;Mike&quot;</span><span class=\"comment\">//可以直接写成 var name = &quot;Mike&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个特性叫做<code>类型推断</code>，它跟<code>动态类型</code>是不一样的。<ol>\n<li>类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。</li>\n<li>动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-val-和-var\"><a href=\"#2-5-val-和-var\" class=\"headerlink\" title=\"2.5 val 和 var\"></a>2.5 val 和 var</h2><ul>\n<li>除了前面提到的 var，我们还可以使用 val 来声明变量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>val 是 Kotlin 在 Java 的<code>变量</code>类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。</li>\n<li>val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h1><ul>\n<li>在讲空安全设计之前，我们最好是回忆一下 Java 和 Kotlin 中<code>变量声明和赋值</code>方面的异同。</li>\n<li>首先，在 Java 中，声明一个变量的格式是：<code>&lt;数据类型&gt; &lt;变量名&gt;;</code>缺一不可，比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> age; <span class=\"comment\">// 声明一个整型变量 age</span></span><br><span class=\"line\">    String name; <span class=\"comment\">// 声明一个字符串型变量 name</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>除了简单声明变量，还可以同时进行初始化，即：<code>&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</code>如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">25</span>; <span class=\"comment\">// 声明一个整型变量 age，并初始化为 25</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span>; <span class=\"comment\">// 声明一个字符串型变量 name，并初始化为 &quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后，在 Kotlin 中，声明一个变量的格式是：<code>var &lt;变量名&gt;: &lt;数据类型&gt;</code>，像这样：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>一眼看去和 Java 有几处不同：</p>\n<ol>\n<li>有一个<code>var</code>关键字</li>\n<li>类型和变量名位置互换了</li>\n<li>中间是用冒号分隔的</li>\n<li>结尾没有分号（Kotlin 里面不需要分号）</li>\n</ol>\n</li>\n<li><p>虽然看上去只是语法格式有些不同，但如果真这么写，IDE 会报错：<code>Property must be initialized or be abstract</code>。什么意思呢，就是说属性需要在声明的同时初始化，除非你把它声明成抽象的。（没错，Kotlin 中属性也可以是抽象的，这点和 Java 也不相同，这里先不理会）</p>\n</li>\n<li><p>彳亍！那就初始化！欸等等，为什么一定先要初始化啊？Java 里面声明变量的时候都不需要初始化啊，是不是你 Kotlin 故意找茬啊？</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oAMSST.gif\">\n\n<ul>\n<li>不不不！其实是有原因的，在 Kotlin 中，变量是<code>没有默认值</code>的，这点不像 Java，Java 的 field 有默认值（局部变量没有），比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    String name; <span class=\"comment\">// 默认值是 null</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">// 默认值是 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>好吧，你没有默认值那我给你一个吧，我这样写：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>哎呀又报错了，IDE 告诉你说：<code>Null can not be a value of a non-null type View</code>，也就是说，需要赋一个非空的值给它才行。那怎么办？我们下一节说。</li>\n</ul>\n<h1 id=\"二、空安全设计\"><a href=\"#二、空安全设计\" class=\"headerlink\" title=\"二、空安全设计\"></a>二、空安全设计</h1><h2 id=\"2-1-NullPointerException\"><a href=\"#2-1-NullPointerException\" class=\"headerlink\" title=\"2.1 NullPointerException\"></a>2.1 NullPointerException</h2><ul>\n<li>先介绍一个异常：<code>NullPointerException</code> - 空指针异常，这个异常可谓是大家的老熟人了，只要干过开发的一定见过它。如果没见过也没关系，在 Java 中你可以通过下面几行代码轻易复现这个异常：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        System.out.println(str.length()); <span class=\"comment\">// 触发 NullPointerException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>具体来说，这里的 str 也就是 null 表示一个空引用，它并没有指向实际的对象，当我们试图在 str 上调用 length() 方法来获取字符串的长度时，没有实际的字符串对象可供调用方法，所以会抛出 NullPointerException。</li>\n</ul>\n<h2 id=\"2-2-空安全设计\"><a href=\"#2-2-空安全设计\" class=\"headerlink\" title=\"2.2 空安全设计\"></a>2.2 空安全设计</h2><ul>\n<li>好的，进入正题。什么是 Kotlin 的空安全设计？它的存在有什么意义？</li>\n<li>简单来说，空安全设计就是通过 IDE 的提示来避免调用 null 对象，从而<code>避免 NullPointerException</code>。</li>\n<li>可别小看这一点，单单<code>避免 NullPointerException</code>这一句话，就含金量十足，要知道 NullPointerException 这个异常不仅常见，并且是致命的，一旦出现并且没有捕获处理那么程序就会直接崩溃。</li>\n<li>空安全检测其实在 androidx 里就有支持的，用一个注解就可以标记变量是否可能为空，然后 IDE 会帮助检测和提示，我们来看下面这段 Java 代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//IDE 会发出警告：&#x27;null&#x27; is assigned to a variable that is annotated with @NotNull</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>到了 Kotlin 这里，就有了语言级别的默认支持，而且提示的级别从 <code>warning</code> 变成了 <code>error</code>（拒绝编译）：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View = <span class=\"literal\">null</span> <span class=\"comment\">//IDE 会提示错误，Null can not be a value of a non-null type View</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>在 Kotlin 里面，所有的变量默认都是不允许为空的</code>，如果你给它赋值 null，就会报错，像上面那样。</li>\n<li>Kotlin 这样做的目的其实是可以理解的，你声明了一个对象，不就是要使用它吗？既然要使用它，那它为空就没有意义了呀。Java 对这方面的限制很宽松，我们已经习惯，但是这并不代表 Java 这样做就是最合理的。</li>\n<li>这个时候就存在一个问题了，很多时候变量的值真的无法保证空与否，比如你要从服务器取一个 JSON 数据，并把它解析成一个 User 对象：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"literal\">null</span> <span class=\"comment\">// 这样写会报错，但该变量无法保证空与否</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个时候报错了，但是空值就是有意义的！对于这些可以为空值的变量，你可以在类型右边加一个 ? 号，解除它的非空限制：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>加了问号之后，一个 Kotlin 变量就像 Java 变量一样没有非空的限制，自由自在了。你除了在初始化的时候可以给它赋值为空值，在代码里的任何地方也都可以。</li>\n<li>这种类型之后加 ? 的写法，在 Kotlin 里叫<code>可空类型</code>。不过，当我们使用了可空类型的变量后，会有新的问题：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> view: View? = <span class=\"literal\">null</span></span><br><span class=\"line\">view.setBackgroundColor(Color.RED)</span><br><span class=\"line\"><span class=\"comment\">// 这样写会报错，Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type View?</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于我们定义的<code>可能为空</code>的变量，Kotlin 不允许我们用。那怎么办？我们尝试用之前检查一下，但似乎 IDE 不接受这种做法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (view != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    view.setBackgroundColor(Color.RED)</span><br><span class=\"line\">    <span class=\"comment\">// 这样写也会报错，Smart cast to &#x27;View&#x27; is impossible, because &#x27;view&#x27; is a mutable property that could have been changed by this time</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个报错的意思是即使你检查了非空也不能保证下面调用的时候就是非空，因为在<code>多线程</code>情况下，其他线程可能把它再改成空的。</li>\n<li>那怎么办？Kotlin 里是这么解决这个问题的呢？它用的不是<code>.</code>而是<code> ?.</code>：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view?.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个写法同样会对变量做一次非空确认之后再调用方法，这是 Kotlin 的写法，并且它可以做到<code>线程安全</code>，因此这种写法叫做<code>safe call</code>。</li>\n<li>另外还有一种双感叹号的用法：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view!!.setBackgroundColor(Color.RED)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>意思是告诉编译器，我保证这里的 view 一定是非空的，编译器你不要帮我做检查了，有什么后果我自己承担。这种「肯定不会为空」的断言式的调用叫做 <code>non-null asserted call</code>。一旦用了非空断言，实际上和 Java 就没什么两样了，但也就享受不到 Kotlin 的空安全设计带来的好处（在编译时做检查，而不是运行时抛异常）了。</p>\n</li>\n<li><p>其实上述内容就是 Kotlin 的空安全设计了，很多人在上手的时候都被变量声明搞懵，原因就是 Kotlin 的空安全设计所导致的这些报错：</p>\n<ol>\n<li>变量需要手动初始化，如果不初始化的话会报错； </li>\n<li>变量默认非空，所以初始化赋值 null 的话报错，之后再次赋值为 null 也会报错； </li>\n<li>变量用 ? 设置为可空的时候，使用的时候因为<code>可能为空</code>又报错。</li>\n</ol>\n</li>\n<li><p>关于空安全，最重要的是记住一点：所谓<code>可空不可空</code>，关注的全都是<code>使用的时候</code>，即<code>这个变量在使用时是否可能为空</code>。</p>\n</li>\n<li><p>Elvis 操作符，它是 Kotlin 中的一种特殊运算符，用于处理可能为空的表达式，并为其提供一个备选的非空值作为默认值。写法：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression ?: defaultValue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果 expression 不为 null，则 Elvis 操作符的结果为 expression 的值；如果 expression 为 null，则结果为 defaultValue 的值。</p>\n</li>\n<li><p>一些注意事项：</p>\n<ol>\n<li>defaultValue 必须与 expression 具有相同的类型或兼容的类型。否则，在编译时就会发生类型不匹配的错误。</li>\n<li>defaultValue 可以是一个表达式，可以是常量、变量、函数调用等。</li>\n<li>Elvis 操作符可以嵌套使用，形成链式调用。例如：a ?: b ?: c</li>\n<li>Elvis 操作符可以与安全调用运算符一起使用，以处理可能为空的对象的属性或方法。例如：object?.property ?: defaultValue</li>\n<li>Elvis 操作符是一种简洁的处理可为空变量的方式，但在使用时需要谨慎考虑默认值的选择，以确保逻辑正确性。</li>\n</ol>\n</li>\n<li><p>空安全讲了这么多，但是有些时候我们声明一个变量是不会让它为空的，比如 view，其实在实际场景中我们希望它一直是非空的，可空并没有业务上的实际意义，使用 ?. 影响代码可读性。</p>\n</li>\n<li><p>但如果你在 MainActivity 里这么写：</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: View = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器不会报错，但程序一旦运行起来就 crash 了，原因是 findViewById() 是在 onCreate 之后才能调用（或者说是在 setContentView() 调用后）。</li>\n<li>那怎么办呢？其实我们很想告诉编译器<code>我很确定我用的时候绝对不为空，但第一时间我没法给它赋值</code>。</li>\n<li>Kotlin 给我们提供了一个选项：<code>延迟初始化</code>。</li>\n</ul>\n<h2 id=\"2-3-延迟初始化\"><a href=\"#2-3-延迟初始化\" class=\"headerlink\" title=\"2.3 延迟初始化\"></a>2.3 延迟初始化</h2><ul>\n<li>为了能声明第一时间没法赋初始值的变量，Kotlin 给我们提供了延迟初始化方式声明变量，具体是这么写的：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>lateinit 的意思是：告诉编译器我没法第一时间就初始化，但我肯定会在使用它之前完成初始化的。</li>\n<li>它的作用就是让 IDE 不要对这个变量检查初始化和报错。换句话说，加了这个 lateinit 关键字，这个变量的初始化就全靠你自己了，编译器不帮你检查了。</li>\n<li>然后我们就可以在 onCreate 中进行初始化了：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> view: View</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    view = findViewById(R.id.tvContent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>延迟初始化对变量的赋值次数没有限制，你仍然可以在初始化之后再赋其他的值给 view。</li>\n</ul>\n<h2 id=\"2-4-类型推断\"><a href=\"#2-4-类型推断\" class=\"headerlink\" title=\"2.4 类型推断\"></a>2.4 类型推断</h2><ul>\n<li>空安全设计到此其实已经差不多讲完了，再补充一点其他内容。</li>\n<li>Kotlin 有个很方便的地方是，如果你在声明的时候就赋值，那不写变量类型也行：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;Mike&quot;</span><span class=\"comment\">//可以直接写成 var name = &quot;Mike&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个特性叫做<code>类型推断</code>，它跟<code>动态类型</code>是不一样的。<ol>\n<li>类型推断（Type Inference）：类型推断是指编译器或解释器能够根据上下文推断出表达式的类型，而无需显式地指定类型。这种推断可以减少冗余代码，提高编码效率。</li>\n<li>动态类型（Dynamic Typing）：动态类型是指在运行时确定变量的数据类型。在动态类型语言中，变量的类型是在运行时根据赋值语句来确定的，可以在程序中更改变量的类型。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-5-val-和-var\"><a href=\"#2-5-val-和-var\" class=\"headerlink\" title=\"2.5 val 和 var\"></a>2.5 val 和 var</h2><ul>\n<li>除了前面提到的 var，我们还可以使用 val 来声明变量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>val 是 Kotlin 在 Java 的<code>变量</code>类型之外，又增加的一种变量类型：只读变量。它只能赋值一次，不能修改。而 var 是一种可读可写变量。</li>\n<li>val 和 Java 中的 final 类似，不过其实它们还是有些不一样的，总之直接进行重新赋值是不行的。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>Kotlin 的空安全机制通过明确可为空和不可为空、编译时空值检查、安全调用运算符、Elvis 操作符和非空断言操作符等特点，提供了一套有效的工具来处理空指针异常，增加代码的稳定性和可靠性。</li>\n</ul>\n"},{"title":"认识二叉树","date":"2023-04-11T00:00:00.000Z","description":"回忆二叉树的概念，了解二叉树这个数据结构","cover":"https://www.helloimg.com/images/2023/07/19/oA2LTg.webp","_content":"\n# 一、什么是二叉树？\n\n## 1.1 认识二叉树\n\n- 二叉树是一种常用的树形结构，由节点和边组成，其中每个节点**最多**有两个子节点，分别称为左子节点和右子节点。\n- 下图就是一个简单的结构示例：\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2SUM.webp\">\n\n按照二叉树的严格定义，以下的基本条件必须满足：\n\n1. 每个节点最多只能有两个子节点。\n2. 每个节点的子节点可以为空，但不能超过两个。\n3. 一棵二叉树的根节点只能有一个，而且每个节点最多只能有一个父节点。\n4. 任意一个节点的左子树和右子树都是一棵二叉树，也就是说，每个子树本身也必须是一棵严格的二叉树。\n\n说明一下：\"**每个子树本身也是一棵严格的二叉树**\"和\"**一棵二叉树的根节点只能有一个**\"并不冲突，只要谈论的是**一颗**二叉树，那么他的根节点就只能有且只有一个！\n\n## 1.2 二叉树定义相关的名词解释\n\n1. **节点**：二叉树中的每个元素称为一个节点，它用来存储数据和指向其他节点的指针。\n2. **父节点**：一个节点所指向的直接上级节点被称为该节点的父节点，如果一个节点没有父节点，则该节点称为根节点。\n3. **子节点**：一个节点所指向的直接下级节点被称为该节点的子节点。\n4. **叶子节点**：没有子节点的节点被称为叶子节点，也称为终端节点或者外部节点。\n5. **内部节点**：除了叶子节点之外的所有节点都被称为内部节点，也称为非终端节点或者分支节点。\n6. **节点的度**：节点所拥有的子节点数目称为该节点的度，叶子节点的度为0。\n7. **深度**：从根节点到某个节点所经过的<font color=\"FF0000\">边的数目</font>称为该节点的深度，根节点的深度为0。\n8. **高度**：从某个节点到其最远叶子节点所经过的边的数目称为该节点的高度，叶子节点的高度为0。\n\n<font color=\"FF0000\">深度</font>的概念非常重要，使用得也最多，一定要充分理解！\n\n# 二、二叉树的分类\n\n为了更好的描述和使用二叉树，二叉树按照各自的特点和性质又被分为了几类。\n\n## 2.1 普通二叉树\n\n- 也就是最基本的二叉树结构，它简单、灵活，可以用来存储和处理各种类型的数据。但它的性能可能差于其他类型的二叉树，因为在普通二叉树中，某个节点的度可以为0、1或2，因此存在一些无用的节点，会严重影响搜索的效率。\n- 当然，所有的二叉树都是普通二叉树的一种，普通二叉树也被称为不完全二叉树或自由二叉树。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2nPP.gif\">\n\n## 2.2 满二叉树\n\n- 满二叉树的概念也比较好理解，顾名思义，满二叉树之所以称为满二叉树，原因就在于它的**所有分支节点都拥有左、右两个子节点**。\n- 作为一种特殊的二叉树，它们的节点个数和树的高度之间存在一定的关系，因此对一些算法和数据结构有特定的优化作用。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2b7n.webp\">\n\n## 2.3 完全二叉树\n\n- 在一棵二叉树中，如果除了最后一层以外，其他层都被完全**填满**，且<font color=\"FF0000\">最后一层从左到右填充</font>，则这棵二叉树称为完全二叉树。\n- 不难发现，满二叉树和完全二叉树有一定的联系：如果一棵二叉树是满二叉树，则它一定是完全二叉树；而如果一棵二叉树是完全二叉树，但不是满二叉树，则它最后一层的节点填充顺序不一定是从左到右的。\n- 由于结构的特殊性，它同样对一些算法和数据结构有特定的优化作用。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2MCR.webp\">\n\n## 2.4 二叉搜索树\n\n- 一种特殊的二叉树，它要求左子节点的值小于父节点的值，右子节点的值大于父节点的值。\n- 可以提高查找、插入、删除等操作的效率。二叉搜索树已经成为一种经典的数据结构，它是许多其他数据结构设计的基础。\n- 例如：下图中，如果我们要查找\"3\"节点，那么可以直接判断和根节点的大小，发现\"3\"肯定在左子树，之后再同理判断即可，很快就可以确定\"3\"的位置。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA22tz.webp\">\n\n# 三、相关计算\n\n## 3.1 高度和层数\n\n- 在学习公式之前，首先我们要弄清楚两个很容易混淆的概念：高度和层数\n- 在二叉树中，高度和层数是不同的概念。\n\n1. 高度\n   高度指的是从根节点到最远叶子节点的最长路径上经过的<font color=\"FF0000\">节点数</font>。例如，下图所示的二叉树的高度为3。\n\n```text\n       A\n     /   \\\n    B     C\n         / \\\n        D   E\n```\n\n2. 层数\n   层数表示的是节点在树中的层数，根节点的层数为1，它的子节点的层数为2，以此类推。例如，上图中，根节点A的层数为1，节点B和C的层数为2，节点D和E的层数为3。\n\n在二叉树的算法和数据结构中，计算二叉树高度时可能有两种不同的定义方式：\n\n- 一种是将根节点定义为第0层，从而高度为h的二叉树的最大层数为h；另一种是将根节点定义为第1层，从而高度为h的二叉树的最大层数为h+1。\n- 为了容易理解，并且和高度相匹配，在下面的公式中，我们选用将根节点定义为第1层这种方式。\n\n## 3.2 常用公式\n\n1. 最多节点总数\n   设二叉树的高度为h，那么它的最多节点数为：\n   2^h-1\n\n2. 第 k 层最多节点个数\n\n   对于任意正整数 k ，第 k 层的节点数最多为：\n   2^{k-1}\n\n3. 度为0（即叶子节点）的节点数（n0表示度为0的节点数（即叶子节点数），n2表示度为2的非叶子节点数。）：\n   n0=n2+1\n\n4. 度为2的非叶子节点数：\n   n2 = n0 - 1\n\n需要注意的是，以上公式都是建立在完全二叉树的基础上。对于普通的、不一定满足完全二叉树特征的二叉树，以上公式可能会有一定的变化或限制。\n\n# 四、总结\n\n- 二叉树是一种重要的数据结构，在各种算法和应用中都有广泛的应用。掌握二叉树相关的基本概念、操作和扩展，能够帮助我们更好地理解和设计相关算法，并实现高效、稳定的程序。\n- 我们需要明确二叉树的基本概念，例如根节点、子节点、叶子节点、深度、高度、度数等。通过熟练掌握这些概念，我们可以更好地理解和设计二叉树相关的算法。\n- 后续还会抽时间讲一讲二叉树相关的算法题目，还有二叉树的三种常见遍历方式。","source":"_posts/二叉树_01_认识二叉树.md","raw":"---\ntitle: '认识二叉树'\ndate: '2023-04-11'\ndescription: '回忆二叉树的概念，了解二叉树这个数据结构'\ncover: 'https://www.helloimg.com/images/2023/07/19/oA2LTg.webp'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 二叉树\n\n---\n\n# 一、什么是二叉树？\n\n## 1.1 认识二叉树\n\n- 二叉树是一种常用的树形结构，由节点和边组成，其中每个节点**最多**有两个子节点，分别称为左子节点和右子节点。\n- 下图就是一个简单的结构示例：\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2SUM.webp\">\n\n按照二叉树的严格定义，以下的基本条件必须满足：\n\n1. 每个节点最多只能有两个子节点。\n2. 每个节点的子节点可以为空，但不能超过两个。\n3. 一棵二叉树的根节点只能有一个，而且每个节点最多只能有一个父节点。\n4. 任意一个节点的左子树和右子树都是一棵二叉树，也就是说，每个子树本身也必须是一棵严格的二叉树。\n\n说明一下：\"**每个子树本身也是一棵严格的二叉树**\"和\"**一棵二叉树的根节点只能有一个**\"并不冲突，只要谈论的是**一颗**二叉树，那么他的根节点就只能有且只有一个！\n\n## 1.2 二叉树定义相关的名词解释\n\n1. **节点**：二叉树中的每个元素称为一个节点，它用来存储数据和指向其他节点的指针。\n2. **父节点**：一个节点所指向的直接上级节点被称为该节点的父节点，如果一个节点没有父节点，则该节点称为根节点。\n3. **子节点**：一个节点所指向的直接下级节点被称为该节点的子节点。\n4. **叶子节点**：没有子节点的节点被称为叶子节点，也称为终端节点或者外部节点。\n5. **内部节点**：除了叶子节点之外的所有节点都被称为内部节点，也称为非终端节点或者分支节点。\n6. **节点的度**：节点所拥有的子节点数目称为该节点的度，叶子节点的度为0。\n7. **深度**：从根节点到某个节点所经过的<font color=\"FF0000\">边的数目</font>称为该节点的深度，根节点的深度为0。\n8. **高度**：从某个节点到其最远叶子节点所经过的边的数目称为该节点的高度，叶子节点的高度为0。\n\n<font color=\"FF0000\">深度</font>的概念非常重要，使用得也最多，一定要充分理解！\n\n# 二、二叉树的分类\n\n为了更好的描述和使用二叉树，二叉树按照各自的特点和性质又被分为了几类。\n\n## 2.1 普通二叉树\n\n- 也就是最基本的二叉树结构，它简单、灵活，可以用来存储和处理各种类型的数据。但它的性能可能差于其他类型的二叉树，因为在普通二叉树中，某个节点的度可以为0、1或2，因此存在一些无用的节点，会严重影响搜索的效率。\n- 当然，所有的二叉树都是普通二叉树的一种，普通二叉树也被称为不完全二叉树或自由二叉树。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2nPP.gif\">\n\n## 2.2 满二叉树\n\n- 满二叉树的概念也比较好理解，顾名思义，满二叉树之所以称为满二叉树，原因就在于它的**所有分支节点都拥有左、右两个子节点**。\n- 作为一种特殊的二叉树，它们的节点个数和树的高度之间存在一定的关系，因此对一些算法和数据结构有特定的优化作用。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2b7n.webp\">\n\n## 2.3 完全二叉树\n\n- 在一棵二叉树中，如果除了最后一层以外，其他层都被完全**填满**，且<font color=\"FF0000\">最后一层从左到右填充</font>，则这棵二叉树称为完全二叉树。\n- 不难发现，满二叉树和完全二叉树有一定的联系：如果一棵二叉树是满二叉树，则它一定是完全二叉树；而如果一棵二叉树是完全二叉树，但不是满二叉树，则它最后一层的节点填充顺序不一定是从左到右的。\n- 由于结构的特殊性，它同样对一些算法和数据结构有特定的优化作用。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2MCR.webp\">\n\n## 2.4 二叉搜索树\n\n- 一种特殊的二叉树，它要求左子节点的值小于父节点的值，右子节点的值大于父节点的值。\n- 可以提高查找、插入、删除等操作的效率。二叉搜索树已经成为一种经典的数据结构，它是许多其他数据结构设计的基础。\n- 例如：下图中，如果我们要查找\"3\"节点，那么可以直接判断和根节点的大小，发现\"3\"肯定在左子树，之后再同理判断即可，很快就可以确定\"3\"的位置。\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA22tz.webp\">\n\n# 三、相关计算\n\n## 3.1 高度和层数\n\n- 在学习公式之前，首先我们要弄清楚两个很容易混淆的概念：高度和层数\n- 在二叉树中，高度和层数是不同的概念。\n\n1. 高度\n   高度指的是从根节点到最远叶子节点的最长路径上经过的<font color=\"FF0000\">节点数</font>。例如，下图所示的二叉树的高度为3。\n\n```text\n       A\n     /   \\\n    B     C\n         / \\\n        D   E\n```\n\n2. 层数\n   层数表示的是节点在树中的层数，根节点的层数为1，它的子节点的层数为2，以此类推。例如，上图中，根节点A的层数为1，节点B和C的层数为2，节点D和E的层数为3。\n\n在二叉树的算法和数据结构中，计算二叉树高度时可能有两种不同的定义方式：\n\n- 一种是将根节点定义为第0层，从而高度为h的二叉树的最大层数为h；另一种是将根节点定义为第1层，从而高度为h的二叉树的最大层数为h+1。\n- 为了容易理解，并且和高度相匹配，在下面的公式中，我们选用将根节点定义为第1层这种方式。\n\n## 3.2 常用公式\n\n1. 最多节点总数\n   设二叉树的高度为h，那么它的最多节点数为：\n   2^h-1\n\n2. 第 k 层最多节点个数\n\n   对于任意正整数 k ，第 k 层的节点数最多为：\n   2^{k-1}\n\n3. 度为0（即叶子节点）的节点数（n0表示度为0的节点数（即叶子节点数），n2表示度为2的非叶子节点数。）：\n   n0=n2+1\n\n4. 度为2的非叶子节点数：\n   n2 = n0 - 1\n\n需要注意的是，以上公式都是建立在完全二叉树的基础上。对于普通的、不一定满足完全二叉树特征的二叉树，以上公式可能会有一定的变化或限制。\n\n# 四、总结\n\n- 二叉树是一种重要的数据结构，在各种算法和应用中都有广泛的应用。掌握二叉树相关的基本概念、操作和扩展，能够帮助我们更好地理解和设计相关算法，并实现高效、稳定的程序。\n- 我们需要明确二叉树的基本概念，例如根节点、子节点、叶子节点、深度、高度、度数等。通过熟练掌握这些概念，我们可以更好地理解和设计二叉树相关的算法。\n- 后续还会抽时间讲一讲二叉树相关的算法题目，还有二叉树的三种常见遍历方式。","slug":"二叉树_01_认识二叉树","published":1,"updated":"2023-07-19T09:23:44.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyrv0009m7ho6uz26t7y","content":"<h1 id=\"一、什么是二叉树？\"><a href=\"#一、什么是二叉树？\" class=\"headerlink\" title=\"一、什么是二叉树？\"></a>一、什么是二叉树？</h1><h2 id=\"1-1-认识二叉树\"><a href=\"#1-1-认识二叉树\" class=\"headerlink\" title=\"1.1 认识二叉树\"></a>1.1 认识二叉树</h2><ul>\n<li>二叉树是一种常用的树形结构，由节点和边组成，其中每个节点<strong>最多</strong>有两个子节点，分别称为左子节点和右子节点。</li>\n<li>下图就是一个简单的结构示例：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2SUM.webp\">\n\n<p>按照二叉树的严格定义，以下的基本条件必须满足：</p>\n<ol>\n<li>每个节点最多只能有两个子节点。</li>\n<li>每个节点的子节点可以为空，但不能超过两个。</li>\n<li>一棵二叉树的根节点只能有一个，而且每个节点最多只能有一个父节点。</li>\n<li>任意一个节点的左子树和右子树都是一棵二叉树，也就是说，每个子树本身也必须是一棵严格的二叉树。</li>\n</ol>\n<p>说明一下：”<strong>每个子树本身也是一棵严格的二叉树</strong>“和”<strong>一棵二叉树的根节点只能有一个</strong>“并不冲突，只要谈论的是<strong>一颗</strong>二叉树，那么他的根节点就只能有且只有一个！</p>\n<h2 id=\"1-2-二叉树定义相关的名词解释\"><a href=\"#1-2-二叉树定义相关的名词解释\" class=\"headerlink\" title=\"1.2 二叉树定义相关的名词解释\"></a>1.2 二叉树定义相关的名词解释</h2><ol>\n<li><strong>节点</strong>：二叉树中的每个元素称为一个节点，它用来存储数据和指向其他节点的指针。</li>\n<li><strong>父节点</strong>：一个节点所指向的直接上级节点被称为该节点的父节点，如果一个节点没有父节点，则该节点称为根节点。</li>\n<li><strong>子节点</strong>：一个节点所指向的直接下级节点被称为该节点的子节点。</li>\n<li><strong>叶子节点</strong>：没有子节点的节点被称为叶子节点，也称为终端节点或者外部节点。</li>\n<li><strong>内部节点</strong>：除了叶子节点之外的所有节点都被称为内部节点，也称为非终端节点或者分支节点。</li>\n<li><strong>节点的度</strong>：节点所拥有的子节点数目称为该节点的度，叶子节点的度为0。</li>\n<li><strong>深度</strong>：从根节点到某个节点所经过的<font color=\"FF0000\">边的数目</font>称为该节点的深度，根节点的深度为0。</li>\n<li><strong>高度</strong>：从某个节点到其最远叶子节点所经过的边的数目称为该节点的高度，叶子节点的高度为0。</li>\n</ol>\n<p><font color=\"FF0000\">深度</font>的概念非常重要，使用得也最多，一定要充分理解！</p>\n<h1 id=\"二、二叉树的分类\"><a href=\"#二、二叉树的分类\" class=\"headerlink\" title=\"二、二叉树的分类\"></a>二、二叉树的分类</h1><p>为了更好的描述和使用二叉树，二叉树按照各自的特点和性质又被分为了几类。</p>\n<h2 id=\"2-1-普通二叉树\"><a href=\"#2-1-普通二叉树\" class=\"headerlink\" title=\"2.1 普通二叉树\"></a>2.1 普通二叉树</h2><ul>\n<li>也就是最基本的二叉树结构，它简单、灵活，可以用来存储和处理各种类型的数据。但它的性能可能差于其他类型的二叉树，因为在普通二叉树中，某个节点的度可以为0、1或2，因此存在一些无用的节点，会严重影响搜索的效率。</li>\n<li>当然，所有的二叉树都是普通二叉树的一种，普通二叉树也被称为不完全二叉树或自由二叉树。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2nPP.gif\">\n\n<h2 id=\"2-2-满二叉树\"><a href=\"#2-2-满二叉树\" class=\"headerlink\" title=\"2.2 满二叉树\"></a>2.2 满二叉树</h2><ul>\n<li>满二叉树的概念也比较好理解，顾名思义，满二叉树之所以称为满二叉树，原因就在于它的<strong>所有分支节点都拥有左、右两个子节点</strong>。</li>\n<li>作为一种特殊的二叉树，它们的节点个数和树的高度之间存在一定的关系，因此对一些算法和数据结构有特定的优化作用。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2b7n.webp\">\n\n<h2 id=\"2-3-完全二叉树\"><a href=\"#2-3-完全二叉树\" class=\"headerlink\" title=\"2.3 完全二叉树\"></a>2.3 完全二叉树</h2><ul>\n<li>在一棵二叉树中，如果除了最后一层以外，其他层都被完全<strong>填满</strong>，且<font color=\"FF0000\">最后一层从左到右填充</font>，则这棵二叉树称为完全二叉树。</li>\n<li>不难发现，满二叉树和完全二叉树有一定的联系：如果一棵二叉树是满二叉树，则它一定是完全二叉树；而如果一棵二叉树是完全二叉树，但不是满二叉树，则它最后一层的节点填充顺序不一定是从左到右的。</li>\n<li>由于结构的特殊性，它同样对一些算法和数据结构有特定的优化作用。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2MCR.webp\">\n\n<h2 id=\"2-4-二叉搜索树\"><a href=\"#2-4-二叉搜索树\" class=\"headerlink\" title=\"2.4 二叉搜索树\"></a>2.4 二叉搜索树</h2><ul>\n<li>一种特殊的二叉树，它要求左子节点的值小于父节点的值，右子节点的值大于父节点的值。</li>\n<li>可以提高查找、插入、删除等操作的效率。二叉搜索树已经成为一种经典的数据结构，它是许多其他数据结构设计的基础。</li>\n<li>例如：下图中，如果我们要查找”3”节点，那么可以直接判断和根节点的大小，发现”3”肯定在左子树，之后再同理判断即可，很快就可以确定”3”的位置。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA22tz.webp\">\n\n<h1 id=\"三、相关计算\"><a href=\"#三、相关计算\" class=\"headerlink\" title=\"三、相关计算\"></a>三、相关计算</h1><h2 id=\"3-1-高度和层数\"><a href=\"#3-1-高度和层数\" class=\"headerlink\" title=\"3.1 高度和层数\"></a>3.1 高度和层数</h2><ul>\n<li>在学习公式之前，首先我们要弄清楚两个很容易混淆的概念：高度和层数</li>\n<li>在二叉树中，高度和层数是不同的概念。</li>\n</ul>\n<ol>\n<li>高度<br>高度指的是从根节点到最远叶子节点的最长路径上经过的<font color=\"FF0000\">节点数</font>。例如，下图所示的二叉树的高度为3。</li>\n</ol>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B     C</span><br><span class=\"line\">     / \\</span><br><span class=\"line\">    D   E</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>层数<br>层数表示的是节点在树中的层数，根节点的层数为1，它的子节点的层数为2，以此类推。例如，上图中，根节点A的层数为1，节点B和C的层数为2，节点D和E的层数为3。</li>\n</ol>\n<p>在二叉树的算法和数据结构中，计算二叉树高度时可能有两种不同的定义方式：</p>\n<ul>\n<li>一种是将根节点定义为第0层，从而高度为h的二叉树的最大层数为h；另一种是将根节点定义为第1层，从而高度为h的二叉树的最大层数为h+1。</li>\n<li>为了容易理解，并且和高度相匹配，在下面的公式中，我们选用将根节点定义为第1层这种方式。</li>\n</ul>\n<h2 id=\"3-2-常用公式\"><a href=\"#3-2-常用公式\" class=\"headerlink\" title=\"3.2 常用公式\"></a>3.2 常用公式</h2><ol>\n<li><p>最多节点总数<br>设二叉树的高度为h，那么它的最多节点数为：<br>2^h-1</p>\n</li>\n<li><p>第 k 层最多节点个数</p>\n<p>对于任意正整数 k ，第 k 层的节点数最多为：<br>2^{k-1}</p>\n</li>\n<li><p>度为0（即叶子节点）的节点数（n0表示度为0的节点数（即叶子节点数），n2表示度为2的非叶子节点数。）：<br>n0=n2+1</p>\n</li>\n<li><p>度为2的非叶子节点数：<br>n2 = n0 - 1</p>\n</li>\n</ol>\n<p>需要注意的是，以上公式都是建立在完全二叉树的基础上。对于普通的、不一定满足完全二叉树特征的二叉树，以上公式可能会有一定的变化或限制。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>二叉树是一种重要的数据结构，在各种算法和应用中都有广泛的应用。掌握二叉树相关的基本概念、操作和扩展，能够帮助我们更好地理解和设计相关算法，并实现高效、稳定的程序。</li>\n<li>我们需要明确二叉树的基本概念，例如根节点、子节点、叶子节点、深度、高度、度数等。通过熟练掌握这些概念，我们可以更好地理解和设计二叉树相关的算法。</li>\n<li>后续还会抽时间讲一讲二叉树相关的算法题目，还有二叉树的三种常见遍历方式。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、什么是二叉树？\"><a href=\"#一、什么是二叉树？\" class=\"headerlink\" title=\"一、什么是二叉树？\"></a>一、什么是二叉树？</h1><h2 id=\"1-1-认识二叉树\"><a href=\"#1-1-认识二叉树\" class=\"headerlink\" title=\"1.1 认识二叉树\"></a>1.1 认识二叉树</h2><ul>\n<li>二叉树是一种常用的树形结构，由节点和边组成，其中每个节点<strong>最多</strong>有两个子节点，分别称为左子节点和右子节点。</li>\n<li>下图就是一个简单的结构示例：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2SUM.webp\">\n\n<p>按照二叉树的严格定义，以下的基本条件必须满足：</p>\n<ol>\n<li>每个节点最多只能有两个子节点。</li>\n<li>每个节点的子节点可以为空，但不能超过两个。</li>\n<li>一棵二叉树的根节点只能有一个，而且每个节点最多只能有一个父节点。</li>\n<li>任意一个节点的左子树和右子树都是一棵二叉树，也就是说，每个子树本身也必须是一棵严格的二叉树。</li>\n</ol>\n<p>说明一下：”<strong>每个子树本身也是一棵严格的二叉树</strong>“和”<strong>一棵二叉树的根节点只能有一个</strong>“并不冲突，只要谈论的是<strong>一颗</strong>二叉树，那么他的根节点就只能有且只有一个！</p>\n<h2 id=\"1-2-二叉树定义相关的名词解释\"><a href=\"#1-2-二叉树定义相关的名词解释\" class=\"headerlink\" title=\"1.2 二叉树定义相关的名词解释\"></a>1.2 二叉树定义相关的名词解释</h2><ol>\n<li><strong>节点</strong>：二叉树中的每个元素称为一个节点，它用来存储数据和指向其他节点的指针。</li>\n<li><strong>父节点</strong>：一个节点所指向的直接上级节点被称为该节点的父节点，如果一个节点没有父节点，则该节点称为根节点。</li>\n<li><strong>子节点</strong>：一个节点所指向的直接下级节点被称为该节点的子节点。</li>\n<li><strong>叶子节点</strong>：没有子节点的节点被称为叶子节点，也称为终端节点或者外部节点。</li>\n<li><strong>内部节点</strong>：除了叶子节点之外的所有节点都被称为内部节点，也称为非终端节点或者分支节点。</li>\n<li><strong>节点的度</strong>：节点所拥有的子节点数目称为该节点的度，叶子节点的度为0。</li>\n<li><strong>深度</strong>：从根节点到某个节点所经过的<font color=\"FF0000\">边的数目</font>称为该节点的深度，根节点的深度为0。</li>\n<li><strong>高度</strong>：从某个节点到其最远叶子节点所经过的边的数目称为该节点的高度，叶子节点的高度为0。</li>\n</ol>\n<p><font color=\"FF0000\">深度</font>的概念非常重要，使用得也最多，一定要充分理解！</p>\n<h1 id=\"二、二叉树的分类\"><a href=\"#二、二叉树的分类\" class=\"headerlink\" title=\"二、二叉树的分类\"></a>二、二叉树的分类</h1><p>为了更好的描述和使用二叉树，二叉树按照各自的特点和性质又被分为了几类。</p>\n<h2 id=\"2-1-普通二叉树\"><a href=\"#2-1-普通二叉树\" class=\"headerlink\" title=\"2.1 普通二叉树\"></a>2.1 普通二叉树</h2><ul>\n<li>也就是最基本的二叉树结构，它简单、灵活，可以用来存储和处理各种类型的数据。但它的性能可能差于其他类型的二叉树，因为在普通二叉树中，某个节点的度可以为0、1或2，因此存在一些无用的节点，会严重影响搜索的效率。</li>\n<li>当然，所有的二叉树都是普通二叉树的一种，普通二叉树也被称为不完全二叉树或自由二叉树。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2nPP.gif\">\n\n<h2 id=\"2-2-满二叉树\"><a href=\"#2-2-满二叉树\" class=\"headerlink\" title=\"2.2 满二叉树\"></a>2.2 满二叉树</h2><ul>\n<li>满二叉树的概念也比较好理解，顾名思义，满二叉树之所以称为满二叉树，原因就在于它的<strong>所有分支节点都拥有左、右两个子节点</strong>。</li>\n<li>作为一种特殊的二叉树，它们的节点个数和树的高度之间存在一定的关系，因此对一些算法和数据结构有特定的优化作用。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2b7n.webp\">\n\n<h2 id=\"2-3-完全二叉树\"><a href=\"#2-3-完全二叉树\" class=\"headerlink\" title=\"2.3 完全二叉树\"></a>2.3 完全二叉树</h2><ul>\n<li>在一棵二叉树中，如果除了最后一层以外，其他层都被完全<strong>填满</strong>，且<font color=\"FF0000\">最后一层从左到右填充</font>，则这棵二叉树称为完全二叉树。</li>\n<li>不难发现，满二叉树和完全二叉树有一定的联系：如果一棵二叉树是满二叉树，则它一定是完全二叉树；而如果一棵二叉树是完全二叉树，但不是满二叉树，则它最后一层的节点填充顺序不一定是从左到右的。</li>\n<li>由于结构的特殊性，它同样对一些算法和数据结构有特定的优化作用。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2MCR.webp\">\n\n<h2 id=\"2-4-二叉搜索树\"><a href=\"#2-4-二叉搜索树\" class=\"headerlink\" title=\"2.4 二叉搜索树\"></a>2.4 二叉搜索树</h2><ul>\n<li>一种特殊的二叉树，它要求左子节点的值小于父节点的值，右子节点的值大于父节点的值。</li>\n<li>可以提高查找、插入、删除等操作的效率。二叉搜索树已经成为一种经典的数据结构，它是许多其他数据结构设计的基础。</li>\n<li>例如：下图中，如果我们要查找”3”节点，那么可以直接判断和根节点的大小，发现”3”肯定在左子树，之后再同理判断即可，很快就可以确定”3”的位置。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA22tz.webp\">\n\n<h1 id=\"三、相关计算\"><a href=\"#三、相关计算\" class=\"headerlink\" title=\"三、相关计算\"></a>三、相关计算</h1><h2 id=\"3-1-高度和层数\"><a href=\"#3-1-高度和层数\" class=\"headerlink\" title=\"3.1 高度和层数\"></a>3.1 高度和层数</h2><ul>\n<li>在学习公式之前，首先我们要弄清楚两个很容易混淆的概念：高度和层数</li>\n<li>在二叉树中，高度和层数是不同的概念。</li>\n</ul>\n<ol>\n<li>高度<br>高度指的是从根节点到最远叶子节点的最长路径上经过的<font color=\"FF0000\">节点数</font>。例如，下图所示的二叉树的高度为3。</li>\n</ol>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B     C</span><br><span class=\"line\">     / \\</span><br><span class=\"line\">    D   E</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>层数<br>层数表示的是节点在树中的层数，根节点的层数为1，它的子节点的层数为2，以此类推。例如，上图中，根节点A的层数为1，节点B和C的层数为2，节点D和E的层数为3。</li>\n</ol>\n<p>在二叉树的算法和数据结构中，计算二叉树高度时可能有两种不同的定义方式：</p>\n<ul>\n<li>一种是将根节点定义为第0层，从而高度为h的二叉树的最大层数为h；另一种是将根节点定义为第1层，从而高度为h的二叉树的最大层数为h+1。</li>\n<li>为了容易理解，并且和高度相匹配，在下面的公式中，我们选用将根节点定义为第1层这种方式。</li>\n</ul>\n<h2 id=\"3-2-常用公式\"><a href=\"#3-2-常用公式\" class=\"headerlink\" title=\"3.2 常用公式\"></a>3.2 常用公式</h2><ol>\n<li><p>最多节点总数<br>设二叉树的高度为h，那么它的最多节点数为：<br>2^h-1</p>\n</li>\n<li><p>第 k 层最多节点个数</p>\n<p>对于任意正整数 k ，第 k 层的节点数最多为：<br>2^{k-1}</p>\n</li>\n<li><p>度为0（即叶子节点）的节点数（n0表示度为0的节点数（即叶子节点数），n2表示度为2的非叶子节点数。）：<br>n0=n2+1</p>\n</li>\n<li><p>度为2的非叶子节点数：<br>n2 = n0 - 1</p>\n</li>\n</ol>\n<p>需要注意的是，以上公式都是建立在完全二叉树的基础上。对于普通的、不一定满足完全二叉树特征的二叉树，以上公式可能会有一定的变化或限制。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>二叉树是一种重要的数据结构，在各种算法和应用中都有广泛的应用。掌握二叉树相关的基本概念、操作和扩展，能够帮助我们更好地理解和设计相关算法，并实现高效、稳定的程序。</li>\n<li>我们需要明确二叉树的基本概念，例如根节点、子节点、叶子节点、深度、高度、度数等。通过熟练掌握这些概念，我们可以更好地理解和设计二叉树相关的算法。</li>\n<li>后续还会抽时间讲一讲二叉树相关的算法题目，还有二叉树的三种常见遍历方式。</li>\n</ul>\n"},{"title":"爬楼梯","date":"2023-04-01T00:00:00.000Z","description":"动态规划入门题目 - 爬楼梯","cover":"https://www.helloimg.com/images/2023/07/19/oA2TwA.webp","_content":"\n# 一、定义和举例\n\n## 1.1 定义\n\n- 什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。\n\n- 很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：\n\n- `动态规划就是从下往上(从前向后)阶梯型求解数值`。还是不明白？\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Wh5.gif\">\n\n## 1.2 举个栗子\n\n**爬楼梯**\n\n大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？\n现在我们来分析一下这个场景，并加一点限制：\n\n- 张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？\n  聪明的你看都看出来了，这还不简单？\n\n1. 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶\n3. 走两阶 -> 走一阶\n   <br/>\n\nOK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。\n那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：\n\n1. 走一阶 -> 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶 -> 走一阶\n3. 走一阶 -> 走一阶 -> 走两阶\n4. 走两阶 -> 走一阶 -> 走一阶\n5. 走两阶 -> 走两阶\n   \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Oq0.gif\">\n\n好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。\n以下就是动态规划的核心思想了：\n\n    张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n\n欸！对哎，可是那又怎么样呢？那可太重要了！\n我们可以得出一个**很重要的结论**：\n\n- 张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。\n  再扩展一下\n- 张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。\n- ... 第五层 ... 是 ... 第四层 ... 加上 ... 第三层 ...。\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n\n发现规律了吗？没错，一句话**总结**就是：\n\n    张三后续做的决策都会受到前面所做决策的影响！\n\n## 1.3 小结一下\n\n可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。\n这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。\n更通俗一点的说：\n\n- 递归是先解决大问题，再解决小问题\n- 动态规划是先解决小问题，再解决大问题\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2cWm.webp\">\n\n- 下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下\n\n```Java\n//递归\nclass Ra {\n    int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);   // 从最大的数字开始考虑\n    }\n}\n```\n\n```Java\n//动态规划\nclass Dp {\n    int factorial(int n) {\n        int dp = new int[100];// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘\n        dp[0] = 1;\n        if (n == 0) {\n            return dp[0];\n        }\n        for (\n                int i = 1;\n                i <= n; i++) // 从最小的数字开始考虑，将所有的结果放在数组中\n        {\n            dp[i] = i * dp[i - 1];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 二、解决问题\n\n## 2.1 定义数组元素含义\n\n- 首先我们重新梳理一下问题：\n  **假设张三正在爬楼梯，需要 n 阶才能到达楼顶。\n  每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？**\n\n- 有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。\n  我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。\n\n```java\nclass Solution {\n    /*  省略  */\n    int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n    /*  省略  */\n}\n```\n\n## 2.2 找出数组元素之间的关系式（状态转移方程）\n\n- 这是最难的一步，好在前面我们已经分析出来了，还记得吗？\n\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n  所以我们得出了状态转移方程：\n- **dp[n] = dp[n - 1] + dp[n - 2];**\n\n## 2.3 找出初始值\n\n- 有的同学已经发现，上面的方程可能出现数组越界的问题。\n  没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；\n  因此，我们第三步要做的就是找出这些初始值。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n        /*  省略  */\n        //找出初始值\n        dp[1] = 1;\n        dp[2] = 2;\n        /*  省略  */\n    }\n}\n```\n\n**好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：**\n\n```Java\nclass Solution {\n    public int climbStairs(int n) {\n        //分析\n        //爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n\n        //假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];\n        //dp[3]=dp[1]+dp[2];\n        //dp[1]和dp[2]是初始值，无法通过公式计算\n\n        //创建一个数组来保存历史数据\n        int[] dp = new int[n + 1];\n        //排除两种初始情况\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 三、总结\n\n- 以上就是最经典的动态规划入门题目：[《爬楼梯》](https://leetcode.cn/problems/climbing-stairs/)的一个简单分析和对应的解法。\n  当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。","source":"_posts/动态规划_01_爬楼梯.md","raw":"---\ntitle: '爬楼梯'\ndate: '2023-04-01'\ndescription: '动态规划入门题目 - 爬楼梯'\ncover: 'https://www.helloimg.com/images/2023/07/19/oA2TwA.webp'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 动态规划\n\n---\n\n# 一、定义和举例\n\n## 1.1 定义\n\n- 什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。\n\n- 很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：\n\n- `动态规划就是从下往上(从前向后)阶梯型求解数值`。还是不明白？\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Wh5.gif\">\n\n## 1.2 举个栗子\n\n**爬楼梯**\n\n大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？\n现在我们来分析一下这个场景，并加一点限制：\n\n- 张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？\n  聪明的你看都看出来了，这还不简单？\n\n1. 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶\n3. 走两阶 -> 走一阶\n   <br/>\n\nOK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。\n那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：\n\n1. 走一阶 -> 走一阶 -> 走一阶 -> 走一阶\n2. 走一阶 -> 走两阶 -> 走一阶\n3. 走一阶 -> 走一阶 -> 走两阶\n4. 走两阶 -> 走一阶 -> 走一阶\n5. 走两阶 -> 走两阶\n   \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Oq0.gif\">\n\n好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。\n以下就是动态规划的核心思想了：\n\n    张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n\n欸！对哎，可是那又怎么样呢？那可太重要了！\n我们可以得出一个**很重要的结论**：\n\n- 张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。\n  再扩展一下\n- 张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。\n- ... 第五层 ... 是 ... 第四层 ... 加上 ... 第三层 ...。\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n\n发现规律了吗？没错，一句话**总结**就是：\n\n    张三后续做的决策都会受到前面所做决策的影响！\n\n## 1.3 小结一下\n\n可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。\n这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。\n更通俗一点的说：\n\n- 递归是先解决大问题，再解决小问题\n- 动态规划是先解决小问题，再解决大问题\n  \n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2cWm.webp\">\n\n- 下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下\n\n```Java\n//递归\nclass Ra {\n    int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);   // 从最大的数字开始考虑\n    }\n}\n```\n\n```Java\n//动态规划\nclass Dp {\n    int factorial(int n) {\n        int dp = new int[100];// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘\n        dp[0] = 1;\n        if (n == 0) {\n            return dp[0];\n        }\n        for (\n                int i = 1;\n                i <= n; i++) // 从最小的数字开始考虑，将所有的结果放在数组中\n        {\n            dp[i] = i * dp[i - 1];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 二、解决问题\n\n## 2.1 定义数组元素含义\n\n- 首先我们重新梳理一下问题：\n  **假设张三正在爬楼梯，需要 n 阶才能到达楼顶。\n  每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？**\n\n- 有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。\n  我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。\n\n```java\nclass Solution {\n    /*  省略  */\n    int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n    /*  省略  */\n}\n```\n\n## 2.2 找出数组元素之间的关系式（状态转移方程）\n\n- 这是最难的一步，好在前面我们已经分析出来了，还记得吗？\n\n- ... 第n层 ... 是 ... 第n-1层 ... 加上 ... 第n-2层 ...。\n  所以我们得出了状态转移方程：\n- **dp[n] = dp[n - 1] + dp[n - 2];**\n\n## 2.3 找出初始值\n\n- 有的同学已经发现，上面的方程可能出现数组越界的问题。\n  没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；\n  因此，我们第三步要做的就是找出这些初始值。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        int[] dp = new int[n + 1];//dp[n]即为我们想要的结果\n        /*  省略  */\n        //找出初始值\n        dp[1] = 1;\n        dp[2] = 2;\n        /*  省略  */\n    }\n}\n```\n\n**好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：**\n\n```Java\nclass Solution {\n    public int climbStairs(int n) {\n        //分析\n        //爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n\n        //假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];\n        //dp[3]=dp[1]+dp[2];\n        //dp[1]和dp[2]是初始值，无法通过公式计算\n\n        //创建一个数组来保存历史数据\n        int[] dp = new int[n + 1];\n        //排除两种初始情况\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n# 三、总结\n\n- 以上就是最经典的动态规划入门题目：[《爬楼梯》](https://leetcode.cn/problems/climbing-stairs/)的一个简单分析和对应的解法。\n  当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。","slug":"动态规划_01_爬楼梯","published":1,"updated":"2023-07-19T09:23:44.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyti000dm7ho0yxldi9e","content":"<h1 id=\"一、定义和举例\"><a href=\"#一、定义和举例\" class=\"headerlink\" title=\"一、定义和举例\"></a>一、定义和举例</h1><h2 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h2><ul>\n<li><p>什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>\n</li>\n<li><p>很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：</p>\n</li>\n<li><p><code>动态规划就是从下往上(从前向后)阶梯型求解数值</code>。还是不明白？</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Wh5.gif\">\n\n<h2 id=\"1-2-举个栗子\"><a href=\"#1-2-举个栗子\" class=\"headerlink\" title=\"1.2 举个栗子\"></a>1.2 举个栗子</h2><p><strong>爬楼梯</strong></p>\n<p>大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？<br>现在我们来分析一下这个场景，并加一点限制：</p>\n<ul>\n<li>张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？<br>聪明的你看都看出来了，这还不简单？</li>\n</ul>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶<br/></li>\n</ol>\n<p>OK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。<br>那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：</p>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走两阶 -&gt; 走两阶</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Oq0.gif\">\n\n<p>好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。<br>以下就是动态规划的核心思想了：</p>\n<pre><code>张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n</code></pre>\n<p>欸！对哎，可是那又怎么样呢？那可太重要了！<br>我们可以得出一个<strong>很重要的结论</strong>：</p>\n<ul>\n<li>张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。<br>再扩展一下</li>\n<li>张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。</li>\n<li>… 第五层 … 是 … 第四层 … 加上 … 第三层 …。</li>\n<li>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。</li>\n</ul>\n<p>发现规律了吗？没错，一句话<strong>总结</strong>就是：</p>\n<pre><code>张三后续做的决策都会受到前面所做决策的影响！\n</code></pre>\n<h2 id=\"1-3-小结一下\"><a href=\"#1-3-小结一下\" class=\"headerlink\" title=\"1.3 小结一下\"></a>1.3 小结一下</h2><p>可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。<br>这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。<br>更通俗一点的说：</p>\n<ul>\n<li>递归是先解决大问题，再解决小问题</li>\n<li>动态规划是先解决小问题，再解决大问题</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2cWm.webp\">\n\n<ul>\n<li>下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ra</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);   <span class=\"comment\">// 从最大的数字开始考虑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dp</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                i &lt;= n; i++) <span class=\"comment\">// 从最小的数字开始考虑，将所有的结果放在数组中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[i] = i * dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、解决问题\"><a href=\"#二、解决问题\" class=\"headerlink\" title=\"二、解决问题\"></a>二、解决问题</h1><h2 id=\"2-1-定义数组元素含义\"><a href=\"#2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.1 定义数组元素含义\"></a>2.1 定义数组元素含义</h2><ul>\n<li><p>首先我们重新梳理一下问题：<br><strong>假设张三正在爬楼梯，需要 n 阶才能到达楼顶。<br>每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？</strong></p>\n</li>\n<li><p>有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。<br>我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2 找出数组元素之间的关系式（状态转移方程）</h2><ul>\n<li><p>这是最难的一步，好在前面我们已经分析出来了，还记得吗？</p>\n</li>\n<li><p>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。<br>所以我们得出了状态转移方程：</p>\n</li>\n<li><p><strong>dp[n] = dp[n - 1] + dp[n - 2];</strong></p>\n</li>\n</ul>\n<h2 id=\"2-3-找出初始值\"><a href=\"#2-3-找出初始值\" class=\"headerlink\" title=\"2.3 找出初始值\"></a>2.3 找出初始值</h2><ul>\n<li>有的同学已经发现，上面的方程可能出现数组越界的问题。<br>没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；<br>因此，我们第三步要做的就是找出这些初始值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"comment\">//找出初始值</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//分析</span></span><br><span class=\"line\">        <span class=\"comment\">//爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n</span></span><br><span class=\"line\">        <span class=\"comment\">//假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[3]=dp[1]+dp[2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[1]和dp[2]是初始值，无法通过公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个数组来保存历史数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//排除两种初始情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>以上就是最经典的动态规划入门题目：<a href=\"https://leetcode.cn/problems/climbing-stairs/\">《爬楼梯》</a>的一个简单分析和对应的解法。<br>当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、定义和举例\"><a href=\"#一、定义和举例\" class=\"headerlink\" title=\"一、定义和举例\"></a>一、定义和举例</h1><h2 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h2><ul>\n<li><p>什么是动态规划？百度是这么说的：动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>\n</li>\n<li><p>很好，说了等于没说。当然了，这只是最粗略的概括，再深入探究的话，涉及到的内容我也搞不清楚（读大学时有修过运筹学这门学科，但是忘得差不多了）。 这里不深入讨论数学方面的知识，那么动态规划到底是什么意思呢？通俗一点的说：</p>\n</li>\n<li><p><code>动态规划就是从下往上(从前向后)阶梯型求解数值</code>。还是不明白？</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Wh5.gif\">\n\n<h2 id=\"1-2-举个栗子\"><a href=\"#1-2-举个栗子\" class=\"headerlink\" title=\"1.2 举个栗子\"></a>1.2 举个栗子</h2><p><strong>爬楼梯</strong></p>\n<p>大家都有过爬楼梯的经历，你是会一次上一个台阶还是一次上两个台阶呢？或者挑战一下自己，跨三阶甚至四阶？<br>现在我们来分析一下这个场景，并加一点限制：</p>\n<ul>\n<li>张三现在来爬楼梯了，他腿比较短，一次只能上一个或者两个台阶，不过还好，他要上的楼梯只有三阶，那他会有几种走法？<br>聪明的你看都看出来了，这还不简单？</li>\n</ul>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶<br/></li>\n</ol>\n<p>OK！爬上去了，这种楼层很低的情况确实很简单。那换种情况，很不幸，张三今天要去爬峨眉山，峨眉山从五显岗到金顶大概有22000多层阶梯，你还能看出来张三共有多少种走法吗？当然不行。<br>那我们先从简单的开始，张三假如再往上多爬一层，爬到第四层阶梯有几种爬法？这时候心算能力差一点的同学可能需要用小本本来计算一下所有情况了，我们列举一下：</p>\n<ol>\n<li>走一阶 -&gt; 走一阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走两阶 -&gt; 走一阶</li>\n<li>走一阶 -&gt; 走一阶 -&gt; 走两阶</li>\n<li>走两阶 -&gt; 走一阶 -&gt; 走一阶</li>\n<li>走两阶 -&gt; 走两阶</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2Oq0.gif\">\n\n<p>好！停，可以预见的是，阶数如果再加大，枚举将变得不现实，数量太多不仅容易重复记录还容易漏数。所以我们现在只能换个思路。<br>以下就是动态规划的核心思想了：</p>\n<pre><code>张三如果要走到四层，他必须干什么？没错，他必须先走到第三层或者先到第二层。\n</code></pre>\n<p>欸！对哎，可是那又怎么样呢？那可太重要了！<br>我们可以得出一个<strong>很重要的结论</strong>：</p>\n<ul>\n<li>张三走到第四层的所有方法是走到第三层的所有方法加上走到第二层的所有方法。<br>再扩展一下</li>\n<li>张三走到第三层的所有方法是走到第二层的所有方法加上走到第一层的所有方法。</li>\n<li>… 第五层 … 是 … 第四层 … 加上 … 第三层 …。</li>\n<li>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。</li>\n</ul>\n<p>发现规律了吗？没错，一句话<strong>总结</strong>就是：</p>\n<pre><code>张三后续做的决策都会受到前面所做决策的影响！\n</code></pre>\n<h2 id=\"1-3-小结一下\"><a href=\"#1-3-小结一下\" class=\"headerlink\" title=\"1.3 小结一下\"></a>1.3 小结一下</h2><p>可能有过算法基础的同学觉得这个上面的分析好像有点似曾相识啊，有点像那个什么斐波那契数列，还有点像递归思想。<br>这里就不讨论递归是什么了，但是需要知道，递归不等于动态规划，他们的思想刚好相反，前面说过，动态规划是从下往上(从前向后)阶梯型求解数值。而递归是从上往下(从后向前)阶梯型求解数值。<br>更通俗一点的说：</p>\n<ul>\n<li>递归是先解决大问题，再解决小问题</li>\n<li>动态规划是先解决小问题，再解决大问题</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2cWm.webp\">\n\n<ul>\n<li>下面是递归和动态规划的代码示例，有兴趣的同学可以琢磨一下</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ra</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);   <span class=\"comment\">// 从最大的数字开始考虑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dp</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 动态数组的含义：里面放着从 1-n 每一个数字的阶乘</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                i &lt;= n; i++) <span class=\"comment\">// 从最小的数字开始考虑，将所有的结果放在数组中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[i] = i * dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、解决问题\"><a href=\"#二、解决问题\" class=\"headerlink\" title=\"二、解决问题\"></a>二、解决问题</h1><h2 id=\"2-1-定义数组元素含义\"><a href=\"#2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.1 定义数组元素含义\"></a>2.1 定义数组元素含义</h2><ul>\n<li><p>首先我们重新梳理一下问题：<br><strong>假设张三正在爬楼梯，需要 n 阶才能到达楼顶。<br>每次可以爬 1 或 2 个台阶。他会有多少种不同的方法可以爬到楼顶呢？</strong></p>\n</li>\n<li><p>有了明确的问题，再加上前面的分析之后，我们进行第一步：定义数组元素含义。<br>我们先来定义一个数组dp[n]，他代表爬到第n阶楼梯所用的方法数，也就是我们要求的结果。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2 找出数组元素之间的关系式（状态转移方程）</h2><ul>\n<li><p>这是最难的一步，好在前面我们已经分析出来了，还记得吗？</p>\n</li>\n<li><p>… 第n层 … 是 … 第n-1层 … 加上 … 第n-2层 …。<br>所以我们得出了状态转移方程：</p>\n</li>\n<li><p><strong>dp[n] = dp[n - 1] + dp[n - 2];</strong></p>\n</li>\n</ul>\n<h2 id=\"2-3-找出初始值\"><a href=\"#2-3-找出初始值\" class=\"headerlink\" title=\"2.3 找出初始值\"></a>2.3 找出初始值</h2><ul>\n<li>有的同学已经发现，上面的方程可能出现数组越界的问题。<br>没错，动态规划都会存在初始值，不需要或者不能用状态转移方程得出；<br>因此，我们第三步要做的就是找出这些初始值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//dp[n]即为我们想要的结果</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"comment\">//找出初始值</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>好！准备工作已经完成，我们现在可以写出最后的算法了，相关的注释我会写在代码中：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//分析</span></span><br><span class=\"line\">        <span class=\"comment\">//爬到n层可以爬到第n-1层再爬一步到n，或者爬到n-2再一次爬两步到n</span></span><br><span class=\"line\">        <span class=\"comment\">//假设dp[n]代表爬到第n层可以用的方法数，那么dp[n]=dp[n-1]+dp[n-2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[3]=dp[1]+dp[2];</span></span><br><span class=\"line\">        <span class=\"comment\">//dp[1]和dp[2]是初始值，无法通过公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个数组来保存历史数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//排除两种初始情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>以上就是最经典的动态规划入门题目：<a href=\"https://leetcode.cn/problems/climbing-stairs/\">《爬楼梯》</a>的一个简单分析和对应的解法。<br>当然了，解法不止这一种，就动态规划入门而言，我觉得这种解法相对容易理解一些。</li>\n</ul>\n"},{"title":"Kotlin 中那些和 Java 不一样的写法","date":"2023-07-24T00:00:00.000Z","description":"总结一下 Kotlin 和 Java 在语法、集合数组、流程控制等方面的差异。","cover":"https://www.helloimg.com/images/2023/07/24/oA6jWM.png","_content":"\n# 一、语法和类型系统\n\n## 1.1 可空性\n\n- Kotlin 引入了可空性的概念，通过在类型后面添加`?`来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。\n\n```kotlin\n    var name: String? = null // 可空的字符串\n```\n\n- Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。\n\n```java\n    String name = null; // 普通字符串，可能为 null\n```\n\n## 1.2 函数声明\n\n- Kotlin 使用`fun`关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。\n\n```kotlin\nfun greet(name: String) {\n    println(\"Hello, $name!\")\n}\n```\n\n- Java 中的函数声明方式：\n\n```java\nvoid greet(String name) {\n    System.out.println(\"Hello, \" + name + \"!\");\n}\n```\n\n## 1.3 数据类\n\n-  Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\n## 1.4 字符串插值\n\n- Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。\n\n```kotlin\nkotlin\nval name = \"Alice\"\nval message = \"Hello, $name!\"\n```\n\n## 1.5 Lambda 表达式\n\n- Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval squared = numbers.map { it * it }\n```\n\n- Java 中函数式编程需要通过匿名内部类来实现。\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nList<Integer> squared = numbers.stream().map(x -> x * x).collect(Collectors.toList());\n```\n\n## 1.6 类型推断\n\n- Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。\n\n```kotlin\nval number = 42 // 推断为 Int 类型\nval doubleNumber = 3.14 // 推断为 Double 类型\n```\n\n## 1.7 构造器\n\n- Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。\n\n```kotlin\nclass User {\n    val id: Int\n    val name: String\n    \n    constructor(id: Int, name: String) {\n        this.id = id\n        this.name = name\n    }\n}\n```\n\n```java\npublic class User {\n    int id;\n    String name;\n    \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n- 还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。\n\n## 1.8 init 代码块 \n\n- Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。\n\n```kotlin\nclass User {\n    \n    init {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    constructor() {\n    }\n}\n```\n\n```java\npublic class User {\n   \n    {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    public User() {\n    }\n}\n```\n\n## 1.9 final 和 val\n\n- 大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。\n\n```kotlin\nval size: Int\n    get() { // 每次获取 size 值时都会执行 items.size\n        return items.size\n    }\n```\n\n## 1.10 static 和 companion object\n\n- kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是`伴生对象（Companion Object）`，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。\n\n```kotlin\nclass Sample {\n    companion object {\n        //str 可以直接通过类名进行访问\n        val str = \"Hello word\"\n    }\n}\n```\n\n- 静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：\n\n```kotlin\nclass Sample {\n       \n    companion object {\n         \n        init {\n            //初始化工作\n        }\n    }\n}\n```\n\n## 1.11 Object 和 Any\n\n- 在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了`Any`，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。\n\n```kotlin\nclass MyClass {\n    // ...\n}\n\nval myObj = MyClass()\nif (myObj is Any) {\n    println(\"myObj is an instance of Any\")\n}\n\nval hashCode = myObj.hashCode() // 调用 Any 类的方法\n\n```\n\n- object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于`class`，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。\n\n```kotlin\nobject Singleton {\n    val name = \"Singleton\"\n    fun greet() {\n        println(\"Hello, $name!\")\n    }\n}\n\nval singletonName = Singleton.name // 访问对象的属性\nSingleton.greet() // 调用对象的方法\n\n```\n\n- 所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：\n\n```java\npublic class A {\n    private static A sInstance;\n    \n    public static A getInstance() {\n        if (sInstance == null) {\n            sInstance = new A();\n        }\n        return sInstance;\n    }\n}\n```\n\n- 上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：\n\n```kotlin\nobject A {\n    val number: Int = 1\n    fun method() {\n        println(\"A.method()\")\n    }\n}   \n```\n\n- 另外，通过 object 实现的单例是一个`饿汉式`的单例，并且实现了`线程安全`。\n- 单例对象说完了，还有个匿名类写法差异：\n\n```java\nViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {\n    @Override \n    public void onPageSelected(int position) {\n        // override\n    }\n};\n```\n\n- Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：\n\n```kotlin\nval listener = object: ViewPager.SimpleOnPageChangeListener() {\n    override fun onPageSelected(position: Int) {\n        // override\n    }\n}   \n```\n\n## 1.12 常量\n\n- 在 Java 中，一般这样声明一个常量：\n\n```java\npublic class Sample {\n    public static final int CONST_NUMBER = 1;\n}\n```\n\n- 可以注意到使用了`static final`进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在`companion object`伴生类中才能实现这个功能：\n\n```kotlin\nclass Sample {\n    companion object {\n        const val CONST_NUMBER = 1\n    }\n}\n\n```\n\n- 可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：`top-level 顶层`，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。\n- 例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：\n\n```kotlin\nconst val CONST_NUMBER = 1\n\nfun main() {\n    println(CONST_NUMBER)\n}\n```\n\n- 在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。\n- 学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：\n    1. #define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。\n    2. 在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。\n\n## 1.13 可见性修饰符\n\n- Java 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。\n  2. protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。\n  3. default（默认修饰符）：默认的，作用范围是同一包内。`如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。`\n  4. private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。\n\n- kotlin 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个模块（module）。`默认情况下，所有声明都具有public可见性，可以被任何代码访问`。\n  2. internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。\n  3. protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。\n  4. private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。\n\n- 可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。\n- 特别的，需要说明一下两者 private 修饰符的区别：\n  1. Java 中的 private 表示`类中可见`，作为内部类时对外部类`可见`。\n  2. Kotlin 中的 private 表示`类中或所在文件内可见`，作为内部类时对外部类`不可见`。\n\n# 二、数组和集合\n\n## 2.1 数组\n\n- 在 Java 中声明一个 String 数组：\n\n```java\n    String[] strs = {\"a\", \"b\", \"c\"};\n```\n\n- Kotlin 中声明一个 String 数组：\n\n```kotlin\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：\n    1. get() / set()  获取/修改指定索引位置上的元素值。\n    2. contains()  检查数组中是否包含指定元素。\n    3. first()  获取数组的第一个元素。\n    4. find()  根据给定的条件查找数组中的第一个匹配元素。\n\n## 2.2 集合\n\n- Java 中创建一个列表集合，需要一个个的添加元素：\n\n```java\n  List<String> strList = new ArrayList<>();\n  strList.add(\"a\");\n  strList.add(\"b\");\n  strList.add(\"c\");\n```\n\n- Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：\n\n```kotlin\n    val strList = listOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中创建相同的 Set：\n\n```java\n  Set<String> strSet = new HashSet<>();\n  strSet.add(\"a\");\n  strSet.add(\"b\");\n  strSet.add(\"c\");\n```\n\n- Kotlin 中创建相同的 Set 集合：\n\n```kotlin\nval strSet = setOf(\"a\", \"b\", \"c\")\n```\n\n- Java 中创建一个 Map 集合：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"key1\", 1);\n  map.put(\"key2\", 2);\n  map.put(\"key3\", 3);\n  map.put(\"key4\", 3);\n```\n\n- Kotlin 中创建一个同样的 Map 集合：\n\n```kotlin\nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n```\n\n- 简洁、优雅。\n\n# 三、流程控制\n\n## 3.1 if else\n\n- 就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。\n- 但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：\n\n```kotlin\n  val a = 5\n  val b = if (a > 0) {\n      10\n  } else {\n      -10\n  }\n```\n\n## 3.2 for 循环\n\n- Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。\n\n```kotlin\nfor (i in 1..5) {\n    println(i)\n}\n```\n- 同样的功能在 Java 中需要这么写：\n\n```java\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n```\n\n- 特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n      System.out.println(entry.getKey() + \": \" + entry.getValue());\n  }\n```\n\n- 而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：\n\n```kotlin\n  val map = mapOf(\"A\" to 1, \"B\" to 2)\n  for ((key, value) in map) {\n      println(\"$key: $value\")\n  }\n```\n\n## 3.3 switch case\n\n- Java 中，switch case 需要使用关键字 switch、case、break 和 default：\n\n```java\nint day = 3;\n        String dayName;\n        switch (day) {\n        case 1:\n        dayName = \"Monday\";\n        break;\n        case 2:\n        dayName = \"Tuesday\";\n        break;\n        case 3:\n        dayName = \"Wednesday\";\n        break;\n        default:\n        dayName = \"Invalid day\";\n        }\n        System.out.println(dayName);\n```\n\n- 而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（->）将条件和结果连接起来，并且不需要显式的 break 语句：\n\n```kotlin\nval day = 3\nval dayName = when (day) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    else -> \"Invalid day\"\n}\nprintln(dayName)\n```\n\n- 还是那么的简洁、优雅。\n\n<img src=\"https://www.helloimg.com/images/2023/07/24/oA8SkC.jpg\" width=\"30%\">\n\n# 四、总结\n\n- 上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。\n- 反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。","source":"_posts/Kotlin_04_Kotlin中那些和Java不一样的写法.md","raw":"---\ntitle: 'Kotlin 中那些和 Java 不一样的写法'\ndate: '2023-07-24'\ndescription: '总结一下 Kotlin 和 Java 在语法、集合数组、流程控制等方面的差异。'\ncover: 'https://www.helloimg.com/images/2023/07/24/oA6jWM.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- 面向对象编程\n- 函数式编程\n\n---\n\n# 一、语法和类型系统\n\n## 1.1 可空性\n\n- Kotlin 引入了可空性的概念，通过在类型后面添加`?`来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。\n\n```kotlin\n    var name: String? = null // 可空的字符串\n```\n\n- Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。\n\n```java\n    String name = null; // 普通字符串，可能为 null\n```\n\n## 1.2 函数声明\n\n- Kotlin 使用`fun`关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。\n\n```kotlin\nfun greet(name: String) {\n    println(\"Hello, $name!\")\n}\n```\n\n- Java 中的函数声明方式：\n\n```java\nvoid greet(String name) {\n    System.out.println(\"Hello, \" + name + \"!\");\n}\n```\n\n## 1.3 数据类\n\n-  Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\n## 1.4 字符串插值\n\n- Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。\n\n```kotlin\nkotlin\nval name = \"Alice\"\nval message = \"Hello, $name!\"\n```\n\n## 1.5 Lambda 表达式\n\n- Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval squared = numbers.map { it * it }\n```\n\n- Java 中函数式编程需要通过匿名内部类来实现。\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nList<Integer> squared = numbers.stream().map(x -> x * x).collect(Collectors.toList());\n```\n\n## 1.6 类型推断\n\n- Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。\n\n```kotlin\nval number = 42 // 推断为 Int 类型\nval doubleNumber = 3.14 // 推断为 Double 类型\n```\n\n## 1.7 构造器\n\n- Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。\n\n```kotlin\nclass User {\n    val id: Int\n    val name: String\n    \n    constructor(id: Int, name: String) {\n        this.id = id\n        this.name = name\n    }\n}\n```\n\n```java\npublic class User {\n    int id;\n    String name;\n    \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n- 还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。\n\n## 1.8 init 代码块 \n\n- Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。\n\n```kotlin\nclass User {\n    \n    init {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    constructor() {\n    }\n}\n```\n\n```java\npublic class User {\n   \n    {\n        // 初始化代码块，先于构造器执行\n    }\n    \n    public User() {\n    }\n}\n```\n\n## 1.9 final 和 val\n\n- 大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。\n\n```kotlin\nval size: Int\n    get() { // 每次获取 size 值时都会执行 items.size\n        return items.size\n    }\n```\n\n## 1.10 static 和 companion object\n\n- kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是`伴生对象（Companion Object）`，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。\n\n```kotlin\nclass Sample {\n    companion object {\n        //str 可以直接通过类名进行访问\n        val str = \"Hello word\"\n    }\n}\n```\n\n- 静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：\n\n```kotlin\nclass Sample {\n       \n    companion object {\n         \n        init {\n            //初始化工作\n        }\n    }\n}\n```\n\n## 1.11 Object 和 Any\n\n- 在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了`Any`，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。\n\n```kotlin\nclass MyClass {\n    // ...\n}\n\nval myObj = MyClass()\nif (myObj is Any) {\n    println(\"myObj is an instance of Any\")\n}\n\nval hashCode = myObj.hashCode() // 调用 Any 类的方法\n\n```\n\n- object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于`class`，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。\n\n```kotlin\nobject Singleton {\n    val name = \"Singleton\"\n    fun greet() {\n        println(\"Hello, $name!\")\n    }\n}\n\nval singletonName = Singleton.name // 访问对象的属性\nSingleton.greet() // 调用对象的方法\n\n```\n\n- 所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：\n\n```java\npublic class A {\n    private static A sInstance;\n    \n    public static A getInstance() {\n        if (sInstance == null) {\n            sInstance = new A();\n        }\n        return sInstance;\n    }\n}\n```\n\n- 上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：\n\n```kotlin\nobject A {\n    val number: Int = 1\n    fun method() {\n        println(\"A.method()\")\n    }\n}   \n```\n\n- 另外，通过 object 实现的单例是一个`饿汉式`的单例，并且实现了`线程安全`。\n- 单例对象说完了，还有个匿名类写法差异：\n\n```java\nViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {\n    @Override \n    public void onPageSelected(int position) {\n        // override\n    }\n};\n```\n\n- Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：\n\n```kotlin\nval listener = object: ViewPager.SimpleOnPageChangeListener() {\n    override fun onPageSelected(position: Int) {\n        // override\n    }\n}   \n```\n\n## 1.12 常量\n\n- 在 Java 中，一般这样声明一个常量：\n\n```java\npublic class Sample {\n    public static final int CONST_NUMBER = 1;\n}\n```\n\n- 可以注意到使用了`static final`进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在`companion object`伴生类中才能实现这个功能：\n\n```kotlin\nclass Sample {\n    companion object {\n        const val CONST_NUMBER = 1\n    }\n}\n\n```\n\n- 可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：`top-level 顶层`，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。\n- 例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：\n\n```kotlin\nconst val CONST_NUMBER = 1\n\nfun main() {\n    println(CONST_NUMBER)\n}\n```\n\n- 在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。\n- 学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：\n    1. #define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。\n    2. 在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。\n\n## 1.13 可见性修饰符\n\n- Java 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。\n  2. protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。\n  3. default（默认修饰符）：默认的，作用范围是同一包内。`如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。`\n  4. private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。\n\n- kotlin 中的可见性修饰符有：\n  1. public：公共的，作用范围是整个模块（module）。`默认情况下，所有声明都具有public可见性，可以被任何代码访问`。\n  2. internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。\n  3. protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。\n  4. private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。\n\n- 可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。\n- 特别的，需要说明一下两者 private 修饰符的区别：\n  1. Java 中的 private 表示`类中可见`，作为内部类时对外部类`可见`。\n  2. Kotlin 中的 private 表示`类中或所在文件内可见`，作为内部类时对外部类`不可见`。\n\n# 二、数组和集合\n\n## 2.1 数组\n\n- 在 Java 中声明一个 String 数组：\n\n```java\n    String[] strs = {\"a\", \"b\", \"c\"};\n```\n\n- Kotlin 中声明一个 String 数组：\n\n```kotlin\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：\n    1. get() / set()  获取/修改指定索引位置上的元素值。\n    2. contains()  检查数组中是否包含指定元素。\n    3. first()  获取数组的第一个元素。\n    4. find()  根据给定的条件查找数组中的第一个匹配元素。\n\n## 2.2 集合\n\n- Java 中创建一个列表集合，需要一个个的添加元素：\n\n```java\n  List<String> strList = new ArrayList<>();\n  strList.add(\"a\");\n  strList.add(\"b\");\n  strList.add(\"c\");\n```\n\n- Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：\n\n```kotlin\n    val strList = listOf(\"a\", \"b\", \"c\")\n```\n\n- Kotlin 中创建相同的 Set：\n\n```java\n  Set<String> strSet = new HashSet<>();\n  strSet.add(\"a\");\n  strSet.add(\"b\");\n  strSet.add(\"c\");\n```\n\n- Kotlin 中创建相同的 Set 集合：\n\n```kotlin\nval strSet = setOf(\"a\", \"b\", \"c\")\n```\n\n- Java 中创建一个 Map 集合：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"key1\", 1);\n  map.put(\"key2\", 2);\n  map.put(\"key3\", 3);\n  map.put(\"key4\", 3);\n```\n\n- Kotlin 中创建一个同样的 Map 集合：\n\n```kotlin\nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n```\n\n- 简洁、优雅。\n\n# 三、流程控制\n\n## 3.1 if else\n\n- 就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。\n- 但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：\n\n```kotlin\n  val a = 5\n  val b = if (a > 0) {\n      10\n  } else {\n      -10\n  }\n```\n\n## 3.2 for 循环\n\n- Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。\n\n```kotlin\nfor (i in 1..5) {\n    println(i)\n}\n```\n- 同样的功能在 Java 中需要这么写：\n\n```java\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n```\n\n- 特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：\n\n```java\n  Map<String, Integer> map = new HashMap<>();\n  map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n      System.out.println(entry.getKey() + \": \" + entry.getValue());\n  }\n```\n\n- 而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：\n\n```kotlin\n  val map = mapOf(\"A\" to 1, \"B\" to 2)\n  for ((key, value) in map) {\n      println(\"$key: $value\")\n  }\n```\n\n## 3.3 switch case\n\n- Java 中，switch case 需要使用关键字 switch、case、break 和 default：\n\n```java\nint day = 3;\n        String dayName;\n        switch (day) {\n        case 1:\n        dayName = \"Monday\";\n        break;\n        case 2:\n        dayName = \"Tuesday\";\n        break;\n        case 3:\n        dayName = \"Wednesday\";\n        break;\n        default:\n        dayName = \"Invalid day\";\n        }\n        System.out.println(dayName);\n```\n\n- 而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（->）将条件和结果连接起来，并且不需要显式的 break 语句：\n\n```kotlin\nval day = 3\nval dayName = when (day) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    else -> \"Invalid day\"\n}\nprintln(dayName)\n```\n\n- 还是那么的简洁、优雅。\n\n<img src=\"https://www.helloimg.com/images/2023/07/24/oA8SkC.jpg\" width=\"30%\">\n\n# 四、总结\n\n- 上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。\n- 反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。","slug":"Kotlin_04_Kotlin中那些和Java不一样的写法","published":1,"updated":"2023-07-24T07:38:37.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkytj000em7hob5otar2w","content":"<h1 id=\"一、语法和类型系统\"><a href=\"#一、语法和类型系统\" class=\"headerlink\" title=\"一、语法和类型系统\"></a>一、语法和类型系统</h1><h2 id=\"1-1-可空性\"><a href=\"#1-1-可空性\" class=\"headerlink\" title=\"1.1 可空性\"></a>1.1 可空性</h2><ul>\n<li>Kotlin 引入了可空性的概念，通过在类型后面添加<code>?</code>来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span> <span class=\"comment\">// 可空的字符串</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 普通字符串，可能为 null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-函数声明\"><a href=\"#1-2-函数声明\" class=\"headerlink\" title=\"1.2 函数声明\"></a>1.2 函数声明</h2><ul>\n<li>Kotlin 使用<code>fun</code>关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中的函数声明方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">greet</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-数据类\"><a href=\"#1-3-数据类\" class=\"headerlink\" title=\"1.3 数据类\"></a>1.3 数据类</h2><ul>\n<li> Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-字符串插值\"><a href=\"#1-4-字符串插值\" class=\"headerlink\" title=\"1.4 字符串插值\"></a>1.4 字符串插值</h2><ul>\n<li>Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin</span><br><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> message = <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-Lambda-表达式\"><a href=\"#1-5-Lambda-表达式\" class=\"headerlink\" title=\"1.5 Lambda 表达式\"></a>1.5 Lambda 表达式</h2><ul>\n<li>Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> squared = numbers.map &#123; it * it &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中函数式编程需要通过匿名内部类来实现。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squared = numbers.stream().map(x -&gt; x * x).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-类型推断\"><a href=\"#1-6-类型推断\" class=\"headerlink\" title=\"1.6 类型推断\"></a>1.6 类型推断</h2><ul>\n<li>Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"number\">42</span> <span class=\"comment\">// 推断为 Int 类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> doubleNumber = <span class=\"number\">3.14</span> <span class=\"comment\">// 推断为 Double 类型</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-构造器\"><a href=\"#1-7-构造器\" class=\"headerlink\" title=\"1.7 构造器\"></a>1.7 构造器</h2><ul>\n<li>Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(id: <span class=\"built_in\">Int</span>, name: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。</li>\n</ul>\n<h2 id=\"1-8-init-代码块\"><a href=\"#1-8-init-代码块\" class=\"headerlink\" title=\"1.8 init 代码块\"></a>1.8 init 代码块</h2><ul>\n<li>Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-final-和-val\"><a href=\"#1-9-final-和-val\" class=\"headerlink\" title=\"1.9 final 和 val\"></a>1.9 final 和 val</h2><ul>\n<li>大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123; <span class=\"comment\">// 每次获取 size 值时都会执行 items.size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.size</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-10-static-和-companion-object\"><a href=\"#1-10-static-和-companion-object\" class=\"headerlink\" title=\"1.10 static 和 companion object\"></a>1.10 static 和 companion object</h2><ul>\n<li>kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是<code>伴生对象（Companion Object）</code>，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//str 可以直接通过类名进行访问</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> str = <span class=\"string\">&quot;Hello word&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化工作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-11-Object-和-Any\"><a href=\"#1-11-Object-和-Any\" class=\"headerlink\" title=\"1.11 Object 和 Any\"></a>1.11 Object 和 Any</h2><ul>\n<li>在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了<code>Any</code>，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> myObj = MyClass()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (myObj <span class=\"keyword\">is</span> Any) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;myObj is an instance of Any&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> hashCode = myObj.hashCode() <span class=\"comment\">// 调用 Any 类的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于<code>class</code>，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> Singleton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Singleton&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> singletonName = Singleton.name <span class=\"comment\">// 访问对象的属性</span></span><br><span class=\"line\">Singleton.greet() <span class=\"comment\">// 调用对象的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A sInstance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;A.method()&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另外，通过 object 实现的单例是一个<code>饿汉式</code>的单例，并且实现了<code>线程安全</code>。</li>\n<li>单例对象说完了，还有个匿名类写法差异：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewPager.<span class=\"type\">SimpleOnPageChangeListener</span> <span class=\"variable\">listener</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewPager</span>.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPageSelected</span><span class=\"params\">(<span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> listener = <span class=\"keyword\">object</span>: ViewPager.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-常量\"><a href=\"#1-12-常量\" class=\"headerlink\" title=\"1.12 常量\"></a>1.12 常量</h2><ul>\n<li>在 Java 中，一般这样声明一个常量：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CONST_NUMBER</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以注意到使用了<code>static final</code>进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在<code>companion object</code>伴生类中才能实现这个功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：<code>top-level 顶层</code>，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。</li>\n<li>例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(CONST_NUMBER)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。</li>\n<li>学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：<ol>\n<li>#define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。</li>\n<li>在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-13-可见性修饰符\"><a href=\"#1-13-可见性修饰符\" class=\"headerlink\" title=\"1.13 可见性修饰符\"></a>1.13 可见性修饰符</h2><ul>\n<li><p>Java 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。</li>\n<li>protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。</li>\n<li>default（默认修饰符）：默认的，作用范围是同一包内。<code>如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。</code></li>\n<li>private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。</li>\n</ol>\n</li>\n<li><p>kotlin 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个模块（module）。<code>默认情况下，所有声明都具有public可见性，可以被任何代码访问</code>。</li>\n<li>internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。</li>\n<li>protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。</li>\n<li>private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。</li>\n</ol>\n</li>\n<li><p>可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。</p>\n</li>\n<li><p>特别的，需要说明一下两者 private 修饰符的区别：</p>\n<ol>\n<li>Java 中的 private 表示<code>类中可见</code>，作为内部类时对外部类<code>可见</code>。</li>\n<li>Kotlin 中的 private 表示<code>类中或所在文件内可见</code>，作为内部类时对外部类<code>不可见</code>。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、数组和集合\"><a href=\"#二、数组和集合\" class=\"headerlink\" title=\"二、数组和集合\"></a>二、数组和集合</h1><h2 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h2><ul>\n<li>在 Java 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] strs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strs: Array&lt;String&gt; = arrayOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：<ol>\n<li>get() / set()  获取/修改指定索引位置上的元素值。</li>\n<li>contains()  检查数组中是否包含指定元素。</li>\n<li>first()  获取数组的第一个元素。</li>\n<li>find()  根据给定的条件查找数组中的第一个匹配元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-集合\"><a href=\"#2-2-集合\" class=\"headerlink\" title=\"2.2 集合\"></a>2.2 集合</h2><ul>\n<li>Java 中创建一个列表集合，需要一个个的添加元素：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strList = listOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; strSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strSet = setOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中创建一个 Map 集合：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个同样的 Map 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;key1&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;key2&quot;</span> to <span class=\"number\">2</span>, <span class=\"string\">&quot;key3&quot;</span> to <span class=\"number\">3</span>, <span class=\"string\">&quot;key4&quot;</span> to <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁、优雅。</li>\n</ul>\n<h1 id=\"三、流程控制\"><a href=\"#三、流程控制\" class=\"headerlink\" title=\"三、流程控制\"></a>三、流程控制</h1><h2 id=\"3-1-if-else\"><a href=\"#3-1-if-else\" class=\"headerlink\" title=\"3.1 if else\"></a>3.1 if else</h2><ul>\n<li>就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。</li>\n<li>但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">10</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    -<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for-循环\"><a href=\"#3-2-for-循环\" class=\"headerlink\" title=\"3.2 for 循环\"></a>3.2 for 循环</h2><ul>\n<li>Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1.</span><span class=\"number\">.5</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样的功能在 Java 中需要这么写：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;: &quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;A&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;B&quot;</span> to <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((key, value) <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$key</span>: <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-switch-case\"><a href=\"#3-3-switch-case\" class=\"headerlink\" title=\"3.3 switch case\"></a>3.3 switch case</h2><ul>\n<li>Java 中，switch case 需要使用关键字 switch、case、break 和 default：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        String dayName;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Monday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Tuesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Wednesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Invalid day&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dayName);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（-&gt;）将条件和结果连接起来，并且不需要显式的 break 语句：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> day = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> dayName = <span class=\"keyword\">when</span> (day) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; <span class=\"string\">&quot;Monday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; <span class=\"string\">&quot;Tuesday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; <span class=\"string\">&quot;Wednesday&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; <span class=\"string\">&quot;Invalid day&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(dayName)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还是那么的简洁、优雅。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/24/oA8SkC.jpg\" width=\"30%\">\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。</li>\n<li>反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、语法和类型系统\"><a href=\"#一、语法和类型系统\" class=\"headerlink\" title=\"一、语法和类型系统\"></a>一、语法和类型系统</h1><h2 id=\"1-1-可空性\"><a href=\"#1-1-可空性\" class=\"headerlink\" title=\"1.1 可空性\"></a>1.1 可空性</h2><ul>\n<li>Kotlin 引入了可空性的概念，通过在类型后面添加<code>?</code>来表示一个可空的引用类型，使得编译器能够在编译时检查空指针异常。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String? = <span class=\"literal\">null</span> <span class=\"comment\">// 可空的字符串</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中没有默认的机制来处理空引用，因此更容易出现空指针异常。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 普通字符串，可能为 null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-函数声明\"><a href=\"#1-2-函数声明\" class=\"headerlink\" title=\"1.2 函数声明\"></a>1.2 函数声明</h2><ul>\n<li>Kotlin 使用<code>fun</code>关键字来声明函数，将函数参数的类型放在参数名称后面，而不是像 Java 那样将类型放在参数列表前面。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中的函数声明方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">greet</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-数据类\"><a href=\"#1-3-数据类\" class=\"headerlink\" title=\"1.3 数据类\"></a>1.3 数据类</h2><ul>\n<li> Kotlin 提供了数据类的概念，通过简单地声明一个类为 data class，编译器会自动生成一些标准方法，如 equals()、hashCode()、toString() 等。在 Java 中，需要手动实现这些方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-字符串插值\"><a href=\"#1-4-字符串插值\" class=\"headerlink\" title=\"1.4 字符串插值\"></a>1.4 字符串插值</h2><ul>\n<li>Kotlin 使用 $ 加变量名的方式进行字符串插值，而不是 Java 中的字符串拼接或者使用 String.format()。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin</span><br><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> message = <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-Lambda-表达式\"><a href=\"#1-5-Lambda-表达式\" class=\"headerlink\" title=\"1.5 Lambda 表达式\"></a>1.5 Lambda 表达式</h2><ul>\n<li>Kotlin 提供了更简洁的语法来定义 Lambda 表达式，使得函数式编程更加方便。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numbers = listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> squared = numbers.map &#123; it * it &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中函数式编程需要通过匿名内部类来实现。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squared = numbers.stream().map(x -&gt; x * x).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-类型推断\"><a href=\"#1-6-类型推断\" class=\"headerlink\" title=\"1.6 类型推断\"></a>1.6 类型推断</h2><ul>\n<li>Kotlin 具有更强大的类型推断能力，可以根据上下文自动推断变量的类型，减少了代码中的类型声明。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"number\">42</span> <span class=\"comment\">// 推断为 Int 类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> doubleNumber = <span class=\"number\">3.14</span> <span class=\"comment\">// 推断为 Double 类型</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-构造器\"><a href=\"#1-7-构造器\" class=\"headerlink\" title=\"1.7 构造器\"></a>1.7 构造器</h2><ul>\n<li>Kotlin 中构造器统一使用 constructor 进行声明，而 Java 中构造器和类同名。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(id: <span class=\"built_in\">Int</span>, name: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以注意到：Kotlin 中构造器没有 public 修饰，因为默认可见性就是 public。</li>\n</ul>\n<h2 id=\"1-8-init-代码块\"><a href=\"#1-8-init-代码块\" class=\"headerlink\" title=\"1.8 init 代码块\"></a>1.8 init 代码块</h2><ul>\n<li>Kotlin 中的 init 代码块必须加上 init 关键字修饰，Java 中不需要加。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码块，先于构造器执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-final-和-val\"><a href=\"#1-9-final-和-val\" class=\"headerlink\" title=\"1.9 final 和 val\"></a>1.9 final 和 val</h2><ul>\n<li>大多数情况下，Kotlin 中的 val 可以直接看做 Java 中的final，都表示变量是不可修改的。Kotlin 中 val 有一种比较特殊的用法是可以通过自定义 getter 让变量每次被访问时，返回动态获取的值。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123; <span class=\"comment\">// 每次获取 size 值时都会执行 items.size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.size</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-10-static-和-companion-object\"><a href=\"#1-10-static-和-companion-object\" class=\"headerlink\" title=\"1.10 static 和 companion object\"></a>1.10 static 和 companion object</h2><ul>\n<li>kotlin 中将静态变量和静态方法这两个概念完全去除了，取而代之的是<code>伴生对象（Companion Object）</code>，在 Kotlin 中，每个类都可以有一个伴生对象，通过 companion object 关键字声明。伴生对象中的属性和函数可以被视为类的静态属性和静态方法，可以通过类名直接访问。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//str 可以直接通过类名进行访问</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> str = <span class=\"string\">&quot;Hello word&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态初始化。由于 Java 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化工作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-11-Object-和-Any\"><a href=\"#1-11-Object-和-Any\" class=\"headerlink\" title=\"1.11 Object 和 Any\"></a>1.11 Object 和 Any</h2><ul>\n<li>在 Java 中，我们都知道 Object 类是所有类的超类，即所有类都继承自 Object，而在 Kotlin 中，这个类变为了<code>Any</code>，它定义了一些通用的方法，例如 equals()、hashCode() 和 toString() 等。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> myObj = MyClass()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (myObj <span class=\"keyword\">is</span> Any) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;myObj is an instance of Any&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> hashCode = myObj.hashCode() <span class=\"comment\">// 调用 Any 类的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>object（首字母小写）在 Kotlin 中变为了一个关键字，功能类似于<code>class</code>，用于声明一个匿名对象或单例对象。使用 object 关键字创建的对象是唯一的，可以直接访问该对象中定义的属性和方法。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> Singleton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;Singleton&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">greet</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> singletonName = Singleton.name <span class=\"comment\">// 访问对象的属性</span></span><br><span class=\"line\">Singleton.greet() <span class=\"comment\">// 调用对象的方法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。举个例子：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A sInstance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上面是 Java 实现一个单例类的方法（非线程安全），而在 Kotlin 中，只需要将 class 替换为 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;A.method()&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另外，通过 object 实现的单例是一个<code>饿汉式</code>的单例，并且实现了<code>线程安全</code>。</li>\n<li>单例对象说完了，还有个匿名类写法差异：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewPager.<span class=\"type\">SimpleOnPageChangeListener</span> <span class=\"variable\">listener</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewPager</span>.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPageSelected</span><span class=\"params\">(<span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> listener = <span class=\"keyword\">object</span>: ViewPager.SimpleOnPageChangeListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPageSelected</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// override</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-常量\"><a href=\"#1-12-常量\" class=\"headerlink\" title=\"1.12 常量\"></a>1.12 常量</h2><ul>\n<li>在 Java 中，一般这样声明一个常量：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CONST_NUMBER</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以注意到使用了<code>static final</code>进行修饰，主要目的是确保常量的唯一性、不可修改性和全局访问性。而在 Kotlin 中，自然应该写在<code>companion object</code>伴生类中才能实现这个功能：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以看出，Kotlin 还新增了修饰常量的 const 关键字。其实除此之外， Kotlin 还有个特殊机制：<code>top-level 顶层</code>，指的是不属于任何类或对象的代码块或声明。它是指在文件级别上直接编写的代码，而不是嵌套在类、函数或对象内部。</li>\n<li>例如，以下代码片段中的 CONST_NUMBER 常量就是一个在顶层声明的常量：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">val</span> CONST_NUMBER = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(CONST_NUMBER)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在这个示例中，CONST_NUMBER 常量被声明在 main() 函数之外的顶层位置，所以它是一个顶层常量。它可以在该文件的任何地方被访问和使用，包括 main() 函数内部。</li>\n<li>学过 C++ 的同学可能觉得这个和 C++ 中的 #define 有一点类似，但是其实他们是有很大区别的：<ol>\n<li>#define 是一个预处理指令，用于定义常量或宏。它是在编译之前进行文本替换的，将标识符替换为预定义的文本。这种方式并不会创建一个真正的符号，而只是简单的文本替换。</li>\n<li>在 Kotlin 中，「top-level 顶层」是一种语言特性，用于在文件级别上直接声明常量、函数和其他类型的声明。这些声明在编译时会被编译器解析，并生成相应的符号。它们是真正的语言成分，可以在整个文件范围内被访问和使用。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-13-可见性修饰符\"><a href=\"#1-13-可见性修饰符\" class=\"headerlink\" title=\"1.13 可见性修饰符\"></a>1.13 可见性修饰符</h2><ul>\n<li><p>Java 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个项目。被public修饰的类、方法、属性可以被任何代码访问。</li>\n<li>protected：受保护的，作用范围是同一包内以及该类的子类。被protected修饰的方法和属性可以在同一包内的其他类中访问，也可以在该类的子类中访问。</li>\n<li>default（默认修饰符）：默认的，作用范围是同一包内。<code>如果没有明确指定访问修饰符，即采用默认修饰符，则只能在同一包内访问。</code></li>\n<li>private：私有的，作用范围是仅限于该类内部。被private修饰的方法和属性只能在该类内部访问。</li>\n</ol>\n</li>\n<li><p>kotlin 中的可见性修饰符有：</p>\n<ol>\n<li>public：公共的，作用范围是整个模块（module）。<code>默认情况下，所有声明都具有public可见性，可以被任何代码访问</code>。</li>\n<li>internal：内部的，作用范围是同一模块内。被internal修饰的声明可以在同一模块内的任何位置被访问。</li>\n<li>protected：受保护的，作用范围是同一类内或者子类。在Kotlin中，protected仅适用于类成员，不适用于顶级声明。</li>\n<li>private：私有的，作用范围是仅限于该类或文件内部。被private修饰的声明只能在声明它的类或文件内部访问。</li>\n</ol>\n</li>\n<li><p>可以看出，Kotlin 相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。</p>\n</li>\n<li><p>特别的，需要说明一下两者 private 修饰符的区别：</p>\n<ol>\n<li>Java 中的 private 表示<code>类中可见</code>，作为内部类时对外部类<code>可见</code>。</li>\n<li>Kotlin 中的 private 表示<code>类中或所在文件内可见</code>，作为内部类时对外部类<code>不可见</code>。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、数组和集合\"><a href=\"#二、数组和集合\" class=\"headerlink\" title=\"二、数组和集合\"></a>二、数组和集合</h1><h2 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h2><ul>\n<li>在 Java 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] strs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中声明一个 String 数组：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strs: Array&lt;String&gt; = arrayOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。将数组进行泛型化有什么好处？他可以让对数组的操作像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：<ol>\n<li>get() / set()  获取/修改指定索引位置上的元素值。</li>\n<li>contains()  检查数组中是否包含指定元素。</li>\n<li>first()  获取数组的第一个元素。</li>\n<li>find()  根据给定的条件查找数组中的第一个匹配元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-集合\"><a href=\"#2-2-集合\" class=\"headerlink\" title=\"2.2 集合\"></a>2.2 集合</h2><ul>\n<li>Java 中创建一个列表集合，需要一个个的添加元素：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个列表集合有点像创建一个数组，代码非常简单：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strList = listOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; strSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">strSet.add(<span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建相同的 Set 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> strSet = setOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java 中创建一个 Map 集合：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kotlin 中创建一个同样的 Map 集合：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;key1&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;key2&quot;</span> to <span class=\"number\">2</span>, <span class=\"string\">&quot;key3&quot;</span> to <span class=\"number\">3</span>, <span class=\"string\">&quot;key4&quot;</span> to <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁、优雅。</li>\n</ul>\n<h1 id=\"三、流程控制\"><a href=\"#三、流程控制\" class=\"headerlink\" title=\"三、流程控制\"></a>三、流程控制</h1><h2 id=\"3-1-if-else\"><a href=\"#3-1-if-else\" class=\"headerlink\" title=\"3.1 if else\"></a>3.1 if else</h2><ul>\n<li>就 if 语句来说，Java 和 Kotlin 的用法非常相似，都是使用关键字 if、else if 和 else 来进行条件判断。</li>\n<li>但是，在 kotlin 中，if 语句还能是一个表达式，也就是说它可以返回一个值，Java 中的 if 语句就只是语句，不能作为表达式使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">10</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    -<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for-循环\"><a href=\"#3-2-for-循环\" class=\"headerlink\" title=\"3.2 for 循环\"></a>3.2 for 循环</h2><ul>\n<li>Kotlin引入了区间迭代的概念。我们可以使用..操作符定义一个范围，并在for循环中使用这个范围进行迭代。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1.</span><span class=\"number\">.5</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样的功能在 Java 中需要这么写：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特别的，我们说一下遍历 Map 的操作，在 Java 中，遍历 Map 一般会使用 entrySet() 方法获取键值对的集合，然后使用 for-each 循环进行迭代：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;: &quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，可以直接使用for循环来遍历Map，无需额外的方法调用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = mapOf(<span class=\"string\">&quot;A&quot;</span> to <span class=\"number\">1</span>, <span class=\"string\">&quot;B&quot;</span> to <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((key, value) <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$key</span>: <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-switch-case\"><a href=\"#3-3-switch-case\" class=\"headerlink\" title=\"3.3 switch case\"></a>3.3 switch case</h2><ul>\n<li>Java 中，switch case 需要使用关键字 switch、case、break 和 default：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        String dayName;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Monday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Tuesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Wednesday&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        dayName = <span class=\"string\">&quot;Invalid day&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dayName);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在 Kotlin 中，则使用了 when else 关键字，使用箭头操作符（-&gt;）将条件和结果连接起来，并且不需要显式的 break 语句：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> day = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> dayName = <span class=\"keyword\">when</span> (day) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; <span class=\"string\">&quot;Monday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; <span class=\"string\">&quot;Tuesday&quot;</span></span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; <span class=\"string\">&quot;Wednesday&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; <span class=\"string\">&quot;Invalid day&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(dayName)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还是那么的简洁、优雅。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/24/oA8SkC.jpg\" width=\"30%\">\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>上面举出的只是一些 Java 和 Kotlin 常见的不同之处，实际的差异不是短短一篇文章能说完的。</li>\n<li>反正总的来说，kotlin 相比 Java 语法更简洁，减少了很多样板代码，提供了更简单的语法糖和函数式编程特性，使代码更易读、更易写。</li>\n</ul>\n"},{"title":"不同路径","date":"2023-04-03T00:00:00.000Z","description":"介绍一个经典的动态规划问题 - 不同路径","cover":"https://www.helloimg.com/images/2023/06/27/o41kIn.png","_content":"\n> 不同路径（Unique Paths）是一个经典的动态规划算法问题，该问题给出了一个m×n的网格，只能向下或向右移动，求从左上角到右下角一共有多少条不同的路径。这个问题的重点在于如何运用动态规划算法，将问题转化为相对简单的子问题，并利用已知的最优解来获取原问题的最优解。\n\n# 一、题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次**只能向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n**问总共有多少条不同的路径？**\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41kIn.png\">\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/unique-paths\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？\n在[爬楼梯](https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/)\n中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。\n\n- 机器人要从左上角的Start走到右下角Finish的位置，并且**只能向下或者向右移动一步**。\n  乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。\n- 机器人达到Finish，必须是**从Finish上方一个格子向下走，或者从Finish左方一个格子向右走**。\n  是不是有点眼熟？这就是本题的**核心**，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。\n- 总结：**机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解**\n\n## 2.2 算法分析\n\n还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：\n\n### 2.2.1 定义数组元素含义\n\n- 我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。\n  注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font>\n\n```java\nclass Solution {\n    /*  省略  */\n    int[][] dp = new int[m + 1][n + 1];\n    /*  省略  */\n}\n```\n\n### 2.2.2 找出数组元素之间的关系式（状态转移方程）\n\n- **dp[m][n] = dp[m][n-1] + dp[m-1][n];**\n\n### 2.2.3 找出初始值\n\n- 这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        /*  省略  */\n    }\n}\n```\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //到达finish只能是从finish左边那一格向右或上面那一格向下\n        //假设d[i][j]表示到达i*j格子的方法数\n        //找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];\n        //排除特殊情况\n        if (m <= 0 || n <= 0) {\n            return 0;\n        }\n        //定义状态转移方程\n        int[][] dp = new int[m + 1][n + 1];\n        //设置初始值\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        //运用状态转移方程求出结果\n        for (int i = 2; i <= m; i++) {\n            for (int j = 2; j <= n; j++) {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n# 四、总结\n\n- 相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。  \n  不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。","source":"_posts/动态规划_02_不同路径.md","raw":"---\ntitle: '不同路径'\ndate: '2023-04-03'\ndescription: '介绍一个经典的动态规划问题 - 不同路径'\ncover: 'https://www.helloimg.com/images/2023/06/27/o41kIn.png'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 动态规划\n\n---\n\n> 不同路径（Unique Paths）是一个经典的动态规划算法问题，该问题给出了一个m×n的网格，只能向下或向右移动，求从左上角到右下角一共有多少条不同的路径。这个问题的重点在于如何运用动态规划算法，将问题转化为相对简单的子问题，并利用已知的最优解来获取原问题的最优解。\n\n# 一、题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次**只能向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n**问总共有多少条不同的路径？**\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41kIn.png\">\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/unique-paths\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？\n在[爬楼梯](https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/)\n中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。\n\n- 机器人要从左上角的Start走到右下角Finish的位置，并且**只能向下或者向右移动一步**。\n  乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。\n- 机器人达到Finish，必须是**从Finish上方一个格子向下走，或者从Finish左方一个格子向右走**。\n  是不是有点眼熟？这就是本题的**核心**，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。\n- 总结：**机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解**\n\n## 2.2 算法分析\n\n还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：\n\n### 2.2.1 定义数组元素含义\n\n- 我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。\n  注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font>\n\n```java\nclass Solution {\n    /*  省略  */\n    int[][] dp = new int[m + 1][n + 1];\n    /*  省略  */\n}\n```\n\n### 2.2.2 找出数组元素之间的关系式（状态转移方程）\n\n- **dp[m][n] = dp[m][n-1] + dp[m-1][n];**\n\n### 2.2.3 找出初始值\n\n- 这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        /*  省略  */\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        /*  省略  */\n    }\n}\n```\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //到达finish只能是从finish左边那一格向右或上面那一格向下\n        //假设d[i][j]表示到达i*j格子的方法数\n        //找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];\n        //排除特殊情况\n        if (m <= 0 || n <= 0) {\n            return 0;\n        }\n        //定义状态转移方程\n        int[][] dp = new int[m + 1][n + 1];\n        //设置初始值\n        for (int i = 1; i <= m; i++) {\n            dp[i][1] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1;\n        }\n        //运用状态转移方程求出结果\n        for (int i = 2; i <= m; i++) {\n            for (int j = 2; j <= n; j++) {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n# 四、总结\n\n- 相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。  \n  不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。","slug":"动态规划_02_不同路径","published":1,"updated":"2023-07-19T09:23:44.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkytl000im7hoe9125wan","content":"<blockquote>\n<p>不同路径（Unique Paths）是一个经典的动态规划算法问题，该问题给出了一个m×n的网格，只能向下或向右移动，求从左上角到右下角一共有多少条不同的路径。这个问题的重点在于如何运用动态规划算法，将问题转化为相对简单的子问题，并利用已知的最优解来获取原问题的最优解。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><strong>问总共有多少条不同的路径？</strong></p>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41kIn.png\">\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/unique-paths\">https://leetcode.cn/problems/unique-paths</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？<br>在<a href=\"https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/\">爬楼梯</a><br>中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。</p>\n<ul>\n<li>机器人要从左上角的Start走到右下角Finish的位置，并且<strong>只能向下或者向右移动一步</strong>。<br>乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。</li>\n<li>机器人达到Finish，必须是<strong>从Finish上方一个格子向下走，或者从Finish左方一个格子向右走</strong>。<br>是不是有点眼熟？这就是本题的<strong>核心</strong>，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。</li>\n<li>总结：<strong>机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解</strong></li>\n</ul>\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：</p>\n<h3 id=\"2-2-1-定义数组元素含义\"><a href=\"#2-2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.2.1 定义数组元素含义\"></a>2.2.1 定义数组元素含义</h3><ul>\n<li>我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。<br>注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2.2 找出数组元素之间的关系式（状态转移方程）</h3><ul>\n<li><strong>dp[m][n] = dp[m][n-1] + dp[m-1][n];</strong></li>\n</ul>\n<h3 id=\"2-2-3-找出初始值\"><a href=\"#2-2-3-找出初始值\" class=\"headerlink\" title=\"2.2.3 找出初始值\"></a>2.2.3 找出初始值</h3><ul>\n<li>这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//到达finish只能是从finish左边那一格向右或上面那一格向下</span></span><br><span class=\"line\">        <span class=\"comment\">//假设d[i][j]表示到达i*j格子的方法数</span></span><br><span class=\"line\">        <span class=\"comment\">//找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];</span></span><br><span class=\"line\">        <span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &lt;= <span class=\"number\">0</span> || n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义状态转移方程</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//设置初始值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//运用状态转移方程求出结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。<br>不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>不同路径（Unique Paths）是一个经典的动态规划算法问题，该问题给出了一个m×n的网格，只能向下或向右移动，求从左上角到右下角一共有多少条不同的路径。这个问题的重点在于如何运用动态规划算法，将问题转化为相对简单的子问题，并利用已知的最优解来获取原问题的最优解。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><strong>问总共有多少条不同的路径？</strong></p>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41kIn.png\">\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/unique-paths\">https://leetcode.cn/problems/unique-paths</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么算法技巧来求解此题。标题已经写得很明显了，可以使用动态规划，那为什么要使用动态规划呢？<br>在<a href=\"https://leihao168.top/2023/04/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01_%E7%88%AC%E6%A5%BC%E6%A2%AF/\">爬楼梯</a><br>中，已经对动态规划算法做过一些介绍，这里不再赘述，我们现在来分析为什么可以使用动态规划来解决此问题。</p>\n<ul>\n<li>机器人要从左上角的Start走到右下角Finish的位置，并且<strong>只能向下或者向右移动一步</strong>。<br>乍一看，似乎没有什么头绪，因为机器人每一步都有可能向下或者向右走，这样的话就会有非常多的走法，采用暴力枚举并不现实。</li>\n<li>机器人达到Finish，必须是<strong>从Finish上方一个格子向下走，或者从Finish左方一个格子向右走</strong>。<br>是不是有点眼熟？这就是本题的<strong>核心</strong>，在爬楼梯那个题目中，张三每次只能走一层或者两层，因此到达第n层时必须达到n-1或者n-2层，这个和本题的思路不谋而合。</li>\n<li>总结：<strong>机器人后续做的决策都会受到前面所做决策的影响！所以我们可以采用动态规划算法来进行求解</strong></li>\n</ul>\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>还记得前面说过的动态规划三步骤吗？我们照葫芦画瓢：</p>\n<h3 id=\"2-2-1-定义数组元素含义\"><a href=\"#2-2-1-定义数组元素含义\" class=\"headerlink\" title=\"2.2.1 定义数组元素含义\"></a>2.2.1 定义数组元素含义</h3><ul>\n<li>我们先来定义一个数组dp[m][n]，它代表机器人走到到第m * n方格所用的方法数，dp[m][n]也就是我们要求的结果。<br>注：<font color=\"#dd0000\">同爬楼梯题目一样，为了方便理解和贴合实际，我们舍弃掉dp[i][0]和dp[0][j]这样的数据，机器人初始位置就是(1，1)，即dp[1][1]。</font></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-找出数组元素之间的关系式（状态转移方程）\"><a href=\"#2-2-2-找出数组元素之间的关系式（状态转移方程）\" class=\"headerlink\" title=\"2.2.2 找出数组元素之间的关系式（状态转移方程）\"></a>2.2.2 找出数组元素之间的关系式（状态转移方程）</h3><ul>\n<li><strong>dp[m][n] = dp[m][n-1] + dp[m-1][n];</strong></li>\n</ul>\n<h3 id=\"2-2-3-找出初始值\"><a href=\"#2-2-3-找出初始值\" class=\"headerlink\" title=\"2.2.3 找出初始值\"></a>2.2.3 找出初始值</h3><ul>\n<li>这里可能需要稍微理解一下，因为机器人只能向右或者向下走，因此dp[i][1]和dp[1][j]全部都是1，即只有一种到达方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//到达finish只能是从finish左边那一格向右或上面那一格向下</span></span><br><span class=\"line\">        <span class=\"comment\">//假设d[i][j]表示到达i*j格子的方法数</span></span><br><span class=\"line\">        <span class=\"comment\">//找到关系dp[m][n] = dp[m][n-1]+dp[m-1][n];</span></span><br><span class=\"line\">        <span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &lt;= <span class=\"number\">0</span> || n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义状态转移方程</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//设置初始值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">1</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//运用状态转移方程求出结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>相比于爬楼梯那种一维情况的动态规划问题来说，这种二维情况下的动态规划会更常见一点，不过相应的也会更难理解一些。<br>不过没关系，做算法题也是熟能生巧的一个过程，只要多加练习，相信你也能很快的解决掉这类问题。</li>\n</ul>\n"},{"title":"组合","date":"2023-05-10T00:00:00.000Z","description":"回溯算法的经典题目 - 组合","cover":"https://www.helloimg.com/images/2023/05/10/oxlhYT.jpg","_content":"\n> 回溯算法（Backtracking）是一种在搜索过程中寻找问题解答的方法。顾名思义，回溯算法就是在考虑一个问题的所有选项时，使用回溯（即返回原状态）来尝试每个可能的选项，直到找到符合要求的解决方案。需要注意的是，回溯算法只适用于问题的解空间较小，否则其时间复杂度会非常高。在本篇文章中，我们将通过介绍回溯算法的基本概念和简单应用，来阐述这一算法。为了更好地讲解，我们选择了一个回溯算法经典使用场景作为例子。希望本文能够帮助读者更加深入地理解和掌握回溯算法。\n\n# 一、题目\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n你可以按 `任何顺序` 返回答案。\n\n示例一：\n\n    输入：n = 4, k = 2\n      输出：\n      [\n      [2,4],\n      [3,4],\n      [2,3],\n      [1,2],\n      [1,3],\n      [1,4],\n      ]\n\n示例二：\n\n    输入：n = 1, k = 1\n      输出：[[1]]\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/combinations/\n\n# 二、思路\n\n## 2.1 暴力枚举\n\n- 题目读起来易懂，但是题目本身并不简单。在 leetcode 上，只要涉及到使用回溯算法的题目，可以发现难度都为`中等`以上。\n- 由于回溯本质上仍然是暴力搜索，所以为了能更好的理解回溯算法，我们先从暴力法入手，尝试解决这个问题。\n\n### 2.1.1 举例分析\n\n- 为了方便理解，我们由浅入深，先来看看`n = 3，k = 1`的情况，即从`[1,2,3]`中选`1`个数出来，有多少种组合？\n  这个直接一眼能看出来，即`[1],[2],[3]`共三种组合。代码随便写一下：\n```java\nclass Solution {\n    public List<List<Integer>> combine() {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 1; i <= 3; i++) {\n          List<Integer> tmp = new ArrayList<>();\n          tmp.add(i);\n          result.add(tmp);\n        }\n        return result;\n    }\n}\n```\n- 然后，我们来看看`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？\n  有数学基础的小伙伴应该能一眼看出组合的个数，即`3`个，学过排列组合就对这个不陌生。\n  $$\n    C_3^1 = C_3^2\n  $$\n  但是题目的要求是输出所有组合，并不是单纯求组合个数，因此我们需要用到下面的暴力算法：\n```java\nclass Solution {\n    public List<List<Integer>> combine2() {\n        List<List<Integer>> result = new ArrayList<>();\n        // 为什么是 3 - 1 ？因为我们需要2个数，i = 3 没必要进入循环了\n        for (int i = 1; i <= 3 - 1; i++) {\n            for (int j = i + 1; j <= 3; j++) {\n                List<Integer> tmp = new ArrayList<>();\n                tmp.add(i);\n                tmp.add(j);\n                result.add(tmp);\n            }\n        }\n        return result;\n    }\n}\n\n```\n- 得出的结果为：`[[1, 2], [1, 3], [2, 3]]`\n\n- 最后，我们来看看`n = 4，k = 3`的情况，即从`[1,2,3,4]`中选`3`个数出来，有多少种组合？\n```java\nclass Solution {\n    public List<List<Integer>> combine() {\n        List<List<Integer>> result = new ArrayList<>();\n            for (int i = 1; i <= 4 - 2; i++) {\n                for (int j = i + 1; j <= 4 - 1; j++) {\n                    for (int k = j + 1; k <= 4; k++) {\n                        List<Integer> tmp = new ArrayList<>();\n                        tmp.add(i);\n                        tmp.add(j);\n                        tmp.add(k);\n                        result.add(tmp);\n                    }\n                }\n            }\n        return result;\n    }\n}\n```\n- 得出的结果为：`[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]`\n\n### 2.1.2 总结\n\n- 发现了吗？随着我们需要的组合的个数(k)增加，for循环的个数也在增加，这意味着时间复杂度将会变得非常糟糕，由于 n 和 k 不确定，我们还需要动态的改变for循环的个数。这无疑又增加了编码难度，简直吃力不讨好。\n- 这样一通操作下来，面试官肯定会说让你回家等消息了，不要慌，我们接下来看看回溯是如何操作的。\n\n<img src=\"https://www.helloimg.com/images/2023/05/10/oxMeKY.jpg\">\n\n## 2.2 回溯\n\n### 2.2.1 暴力枚举和回溯的区别\n\n- 前面已经提到过，回溯的本质也是暴力枚举，那和普通的暴力枚举有什么区别？我们为什么还要选择这个算法？\n- 首先回答第一个问题：回溯和普通的暴力枚举有什么区别？\n  1. 暴力枚举算法。通常采用嵌套循环的方式枚举所有可能的情况。适用于数据规模较小的场景。在数据规模较大的时候，这种暴力枚举算法会存在时间复杂度过高的问题，造成程序运行时间过长，甚至超时。\n  2. 回溯算法。通常采用递归的方式实现，通过不断尝试并回溯的方式，从所有可能的情况中搜索出符合要求的解。因为它具有回溯的功能，可以排除掉一些明显不符合要求的情况，从而避免了不必要的计算，从而实现了剪枝的功能，减少了计算的时间和空间复杂度。\n- 我们为什么还要选择这个算法？\n  很简单，大部分都是因为`没得选`。\n\n### 2.2.2 算法核心\n\n- 回溯算法的核心思想是深度优先搜索（DFS）。具体而言，在每一步搜索时，我们将当前节点加入已选列表中，然后递归地搜索下一个节点，直到满足结束条件时返回。接着我们将当前节点回溯，再搜索下一个节点。重复上述步骤，直到遍历完整个状态空间。其中，回溯过程可以通过撤销当前节点的选择来实现。\n- 就拿我们今天的组合问题举例，使用回溯算法求解组合问题的具体步骤如下：\n  1. 定义状态：我们将每一步选择的结果视为一个状态，可以使用一个列表来记录已选元素。例如，选择`{1,2,3}`作为当前的组合方案，则当前状态为`[1,2,3]`。\n  2. 判断结束条件：当选出`k`个元素时，我们得到了一个组合方案，输出该方案并返回上一层继续搜索。\n  3. 递归搜索下一步：对于每一个未被选中的元素，我们将其加入已选列表中，并继续递归搜索下一个元素。然后`回溯撤销选择`，再在下一个节点继续搜索。\n  4. 剪枝：由于回溯算法的性质，我们需要在搜索时动态剪枝，避免不必要的搜索。具体而言，在每一步选择时，我们需要判断是否符合条件，如果不符则进行剪枝，直接返回上一层。\n\n### 2.2.3 举例分析\n\n- 光说不练假把式，我们来模拟一遍流程：\n  就选择`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？\n- 分析\n  1. 定义状态。当前初始状态为`[]`，还没开始选择。\n  2. 判断结束条件。我们是选择`k = 2`个数，也就是说，当选出的元素达到`2`个时，就得到了一个组合方案\n  3. 递归搜索下一步。下面具体分析\n  4. 剪枝。下面具体分析\n- 具体操作\n  1. 当前状态`[]`，可供选择的有`{1,2,3}`。\n  2. 选择`1`，当前状态为`[1]`，可供选择的有`{2,3}`。\n  3. 选择`2`，当前状态为`[1,2]`，满足结束条件，得到了一个组合方案`[1,2]`。\n  4. `回溯，撤销选择2`，当前状态`[1]`，可供选择的有`{3}`。\n  5. 选择`3`，当前状态为`[1,3]`，满足结束条件，得到了一个组合方案`[1,3]`。\n  6. `回溯，撤销选择3`，当前状态`[1]`，没有可供选择的元素。\n  7. `回溯，撤销选择1`，当前状态`[]`，可供选择的有`{2,3}`。\n  8. 选择`2`，当前状态为`[2]`，可供选择的有`{3}`。\n  9. 选择`3`，当前状态为`[2,3]`，满足结束条件，得到了一个组合方案`[2,3]`。\n  10. `回溯，撤销选择3`，当前状态`[2]`，没有可供选择的元素。\n  11. `回溯，撤销选择2`，当前状态`[]`，可供选择的有`{3}`。\n  12. 剪枝，由于可供选择的元素个数已经小于需要的组合元素个数`k`，抛弃掉后续所有分支。\n\n- 上面的步骤中，第2步到第5步、第6步到第9步、第8步到第9步都参与了递归，每次选择一个元素后，继续递归搜索下一个元素，直到选出需要的k个元素或剪枝退出。在每次递归结束后，都要进行回溯撤销选择操作，并返回上一层继续搜索下一个元素。\n- 用文字来描述递归回溯操作实在太过抽象，本身回溯操作就非常的烧脑子，说得越多越乱，因此读者一定要自己动手画一下流程，加深对每一步操作的理解。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2dUh.jpg\" width=\"30%\">\n\n### 2.2.4 总结\n\n- 在理解清楚每一个步骤之后，可以发现回溯确实明显是一种暴力枚举方案，但是呢，相比于传统的暴力枚举算法，它更加高效、灵活，具有极强的泛用性。\n- 还是没有体会到回溯相比传统暴力枚举算法的好处？没关系，下面的实操代码也许能帮助你感受二者的区别。\n\n# 三、题解\n\n- 一但涉及到递归，对于初学者来说编码都会是灾难级的。但是没关系，我会尽量在所有复杂的地方都写上注释，让代码更容易理解。\n- `强烈建议`在IDE中打断点进行 Debug 调试！一步一步观察数据的变化，会极大的帮助你理解递归和回溯的操作。\n\n- 下面就是一个组合问题的Java回溯算法代码：\n```Java\nclass Solution {\n    // 用来暂存满足条件的组合\n    List<Integer> path = new ArrayList<>();\n    // 最终的所有组合集合\n    List<List<Integer>> result = new ArrayList<>();\n  \n    public List<List<Integer>> combine(int n, int k) {\n      // 回溯操作，从1开始确认每一个数字是否可选\n      backTracking(n, k, 1);\n      return result;\n    }\n  \n    // 回溯核心代码\n    private void backTracking(int n, int k, int startIndex) {\n        // 递归终止条件\n        if (path.size() == k) {\n          // 满足条件，保存当前结果到result中\n          result.add(new ArrayList(path));\n          return; // 结束当前函数调用，进行回溯操作\n        }\n    \n        // 剪枝操作，部分叶子结点不可能满足条件，可以不参与回溯操作\n        // 这里startIndex表示当前可选择的范围起始数字\n        // 由于最终组合的长度为k，所以剩下的数字个数应该 >= 组合还需要的数字个数 (k - path.size())\n        // 故剩下的数字范围是 [startIndex, n - (k - path.size()) + 1]\n        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {\n          path.add(i); // 处理节点，将当前数字加入path中\n          backTracking(n, k, i + 1); // 递归，继续处理下一位数字\n          path.remove(path.size() - 1); // 回溯，撤销处理的节点，进行回溯操作\n        }\n    }\n}\n```\n- 需要注意的地方：\n  1. 函数参数startIndex表示当前可选择的范围起始数字，而不是当前处理的数字。\n  2. 对于每一次满足条件的结果，需要将结果的一个拷贝new ArrayList(path)添加到最终结果中。如果直接添加path，会在回溯时对结果进行修改，导致最终结果出错（由于回溯操作最后都会清空暂存数组，最终结果将全为空集`[]`）。\n\n# 四、总结\n\n- 回溯算法是求解组合问题的一种常用算法。对于组合问题，我们可以通过深度优先搜索的方式进行求解，并在实现过程中注意剪枝等优化措施。","source":"_posts/回溯_01_组合.md","raw":"---\ntitle: '组合'\ndate: '2023-05-10'\ndescription: '回溯算法的经典题目 - 组合'\ncover: 'https://www.helloimg.com/images/2023/05/10/oxlhYT.jpg'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 回溯\n\n---\n\n> 回溯算法（Backtracking）是一种在搜索过程中寻找问题解答的方法。顾名思义，回溯算法就是在考虑一个问题的所有选项时，使用回溯（即返回原状态）来尝试每个可能的选项，直到找到符合要求的解决方案。需要注意的是，回溯算法只适用于问题的解空间较小，否则其时间复杂度会非常高。在本篇文章中，我们将通过介绍回溯算法的基本概念和简单应用，来阐述这一算法。为了更好地讲解，我们选择了一个回溯算法经典使用场景作为例子。希望本文能够帮助读者更加深入地理解和掌握回溯算法。\n\n# 一、题目\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n你可以按 `任何顺序` 返回答案。\n\n示例一：\n\n    输入：n = 4, k = 2\n      输出：\n      [\n      [2,4],\n      [3,4],\n      [2,3],\n      [1,2],\n      [1,3],\n      [1,4],\n      ]\n\n示例二：\n\n    输入：n = 1, k = 1\n      输出：[[1]]\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/combinations/\n\n# 二、思路\n\n## 2.1 暴力枚举\n\n- 题目读起来易懂，但是题目本身并不简单。在 leetcode 上，只要涉及到使用回溯算法的题目，可以发现难度都为`中等`以上。\n- 由于回溯本质上仍然是暴力搜索，所以为了能更好的理解回溯算法，我们先从暴力法入手，尝试解决这个问题。\n\n### 2.1.1 举例分析\n\n- 为了方便理解，我们由浅入深，先来看看`n = 3，k = 1`的情况，即从`[1,2,3]`中选`1`个数出来，有多少种组合？\n  这个直接一眼能看出来，即`[1],[2],[3]`共三种组合。代码随便写一下：\n```java\nclass Solution {\n    public List<List<Integer>> combine() {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 1; i <= 3; i++) {\n          List<Integer> tmp = new ArrayList<>();\n          tmp.add(i);\n          result.add(tmp);\n        }\n        return result;\n    }\n}\n```\n- 然后，我们来看看`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？\n  有数学基础的小伙伴应该能一眼看出组合的个数，即`3`个，学过排列组合就对这个不陌生。\n  $$\n    C_3^1 = C_3^2\n  $$\n  但是题目的要求是输出所有组合，并不是单纯求组合个数，因此我们需要用到下面的暴力算法：\n```java\nclass Solution {\n    public List<List<Integer>> combine2() {\n        List<List<Integer>> result = new ArrayList<>();\n        // 为什么是 3 - 1 ？因为我们需要2个数，i = 3 没必要进入循环了\n        for (int i = 1; i <= 3 - 1; i++) {\n            for (int j = i + 1; j <= 3; j++) {\n                List<Integer> tmp = new ArrayList<>();\n                tmp.add(i);\n                tmp.add(j);\n                result.add(tmp);\n            }\n        }\n        return result;\n    }\n}\n\n```\n- 得出的结果为：`[[1, 2], [1, 3], [2, 3]]`\n\n- 最后，我们来看看`n = 4，k = 3`的情况，即从`[1,2,3,4]`中选`3`个数出来，有多少种组合？\n```java\nclass Solution {\n    public List<List<Integer>> combine() {\n        List<List<Integer>> result = new ArrayList<>();\n            for (int i = 1; i <= 4 - 2; i++) {\n                for (int j = i + 1; j <= 4 - 1; j++) {\n                    for (int k = j + 1; k <= 4; k++) {\n                        List<Integer> tmp = new ArrayList<>();\n                        tmp.add(i);\n                        tmp.add(j);\n                        tmp.add(k);\n                        result.add(tmp);\n                    }\n                }\n            }\n        return result;\n    }\n}\n```\n- 得出的结果为：`[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]`\n\n### 2.1.2 总结\n\n- 发现了吗？随着我们需要的组合的个数(k)增加，for循环的个数也在增加，这意味着时间复杂度将会变得非常糟糕，由于 n 和 k 不确定，我们还需要动态的改变for循环的个数。这无疑又增加了编码难度，简直吃力不讨好。\n- 这样一通操作下来，面试官肯定会说让你回家等消息了，不要慌，我们接下来看看回溯是如何操作的。\n\n<img src=\"https://www.helloimg.com/images/2023/05/10/oxMeKY.jpg\">\n\n## 2.2 回溯\n\n### 2.2.1 暴力枚举和回溯的区别\n\n- 前面已经提到过，回溯的本质也是暴力枚举，那和普通的暴力枚举有什么区别？我们为什么还要选择这个算法？\n- 首先回答第一个问题：回溯和普通的暴力枚举有什么区别？\n  1. 暴力枚举算法。通常采用嵌套循环的方式枚举所有可能的情况。适用于数据规模较小的场景。在数据规模较大的时候，这种暴力枚举算法会存在时间复杂度过高的问题，造成程序运行时间过长，甚至超时。\n  2. 回溯算法。通常采用递归的方式实现，通过不断尝试并回溯的方式，从所有可能的情况中搜索出符合要求的解。因为它具有回溯的功能，可以排除掉一些明显不符合要求的情况，从而避免了不必要的计算，从而实现了剪枝的功能，减少了计算的时间和空间复杂度。\n- 我们为什么还要选择这个算法？\n  很简单，大部分都是因为`没得选`。\n\n### 2.2.2 算法核心\n\n- 回溯算法的核心思想是深度优先搜索（DFS）。具体而言，在每一步搜索时，我们将当前节点加入已选列表中，然后递归地搜索下一个节点，直到满足结束条件时返回。接着我们将当前节点回溯，再搜索下一个节点。重复上述步骤，直到遍历完整个状态空间。其中，回溯过程可以通过撤销当前节点的选择来实现。\n- 就拿我们今天的组合问题举例，使用回溯算法求解组合问题的具体步骤如下：\n  1. 定义状态：我们将每一步选择的结果视为一个状态，可以使用一个列表来记录已选元素。例如，选择`{1,2,3}`作为当前的组合方案，则当前状态为`[1,2,3]`。\n  2. 判断结束条件：当选出`k`个元素时，我们得到了一个组合方案，输出该方案并返回上一层继续搜索。\n  3. 递归搜索下一步：对于每一个未被选中的元素，我们将其加入已选列表中，并继续递归搜索下一个元素。然后`回溯撤销选择`，再在下一个节点继续搜索。\n  4. 剪枝：由于回溯算法的性质，我们需要在搜索时动态剪枝，避免不必要的搜索。具体而言，在每一步选择时，我们需要判断是否符合条件，如果不符则进行剪枝，直接返回上一层。\n\n### 2.2.3 举例分析\n\n- 光说不练假把式，我们来模拟一遍流程：\n  就选择`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？\n- 分析\n  1. 定义状态。当前初始状态为`[]`，还没开始选择。\n  2. 判断结束条件。我们是选择`k = 2`个数，也就是说，当选出的元素达到`2`个时，就得到了一个组合方案\n  3. 递归搜索下一步。下面具体分析\n  4. 剪枝。下面具体分析\n- 具体操作\n  1. 当前状态`[]`，可供选择的有`{1,2,3}`。\n  2. 选择`1`，当前状态为`[1]`，可供选择的有`{2,3}`。\n  3. 选择`2`，当前状态为`[1,2]`，满足结束条件，得到了一个组合方案`[1,2]`。\n  4. `回溯，撤销选择2`，当前状态`[1]`，可供选择的有`{3}`。\n  5. 选择`3`，当前状态为`[1,3]`，满足结束条件，得到了一个组合方案`[1,3]`。\n  6. `回溯，撤销选择3`，当前状态`[1]`，没有可供选择的元素。\n  7. `回溯，撤销选择1`，当前状态`[]`，可供选择的有`{2,3}`。\n  8. 选择`2`，当前状态为`[2]`，可供选择的有`{3}`。\n  9. 选择`3`，当前状态为`[2,3]`，满足结束条件，得到了一个组合方案`[2,3]`。\n  10. `回溯，撤销选择3`，当前状态`[2]`，没有可供选择的元素。\n  11. `回溯，撤销选择2`，当前状态`[]`，可供选择的有`{3}`。\n  12. 剪枝，由于可供选择的元素个数已经小于需要的组合元素个数`k`，抛弃掉后续所有分支。\n\n- 上面的步骤中，第2步到第5步、第6步到第9步、第8步到第9步都参与了递归，每次选择一个元素后，继续递归搜索下一个元素，直到选出需要的k个元素或剪枝退出。在每次递归结束后，都要进行回溯撤销选择操作，并返回上一层继续搜索下一个元素。\n- 用文字来描述递归回溯操作实在太过抽象，本身回溯操作就非常的烧脑子，说得越多越乱，因此读者一定要自己动手画一下流程，加深对每一步操作的理解。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2dUh.jpg\" width=\"30%\">\n\n### 2.2.4 总结\n\n- 在理解清楚每一个步骤之后，可以发现回溯确实明显是一种暴力枚举方案，但是呢，相比于传统的暴力枚举算法，它更加高效、灵活，具有极强的泛用性。\n- 还是没有体会到回溯相比传统暴力枚举算法的好处？没关系，下面的实操代码也许能帮助你感受二者的区别。\n\n# 三、题解\n\n- 一但涉及到递归，对于初学者来说编码都会是灾难级的。但是没关系，我会尽量在所有复杂的地方都写上注释，让代码更容易理解。\n- `强烈建议`在IDE中打断点进行 Debug 调试！一步一步观察数据的变化，会极大的帮助你理解递归和回溯的操作。\n\n- 下面就是一个组合问题的Java回溯算法代码：\n```Java\nclass Solution {\n    // 用来暂存满足条件的组合\n    List<Integer> path = new ArrayList<>();\n    // 最终的所有组合集合\n    List<List<Integer>> result = new ArrayList<>();\n  \n    public List<List<Integer>> combine(int n, int k) {\n      // 回溯操作，从1开始确认每一个数字是否可选\n      backTracking(n, k, 1);\n      return result;\n    }\n  \n    // 回溯核心代码\n    private void backTracking(int n, int k, int startIndex) {\n        // 递归终止条件\n        if (path.size() == k) {\n          // 满足条件，保存当前结果到result中\n          result.add(new ArrayList(path));\n          return; // 结束当前函数调用，进行回溯操作\n        }\n    \n        // 剪枝操作，部分叶子结点不可能满足条件，可以不参与回溯操作\n        // 这里startIndex表示当前可选择的范围起始数字\n        // 由于最终组合的长度为k，所以剩下的数字个数应该 >= 组合还需要的数字个数 (k - path.size())\n        // 故剩下的数字范围是 [startIndex, n - (k - path.size()) + 1]\n        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {\n          path.add(i); // 处理节点，将当前数字加入path中\n          backTracking(n, k, i + 1); // 递归，继续处理下一位数字\n          path.remove(path.size() - 1); // 回溯，撤销处理的节点，进行回溯操作\n        }\n    }\n}\n```\n- 需要注意的地方：\n  1. 函数参数startIndex表示当前可选择的范围起始数字，而不是当前处理的数字。\n  2. 对于每一次满足条件的结果，需要将结果的一个拷贝new ArrayList(path)添加到最终结果中。如果直接添加path，会在回溯时对结果进行修改，导致最终结果出错（由于回溯操作最后都会清空暂存数组，最终结果将全为空集`[]`）。\n\n# 四、总结\n\n- 回溯算法是求解组合问题的一种常用算法。对于组合问题，我们可以通过深度优先搜索的方式进行求解，并在实现过程中注意剪枝等优化措施。","slug":"回溯_01_组合","published":1,"updated":"2023-07-20T01:18:20.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkytm000km7ho26ze0yy4","content":"<blockquote>\n<p>回溯算法（Backtracking）是一种在搜索过程中寻找问题解答的方法。顾名思义，回溯算法就是在考虑一个问题的所有选项时，使用回溯（即返回原状态）来尝试每个可能的选项，直到找到符合要求的解决方案。需要注意的是，回溯算法只适用于问题的解空间较小，否则其时间复杂度会非常高。在本篇文章中，我们将通过介绍回溯算法的基本概念和简单应用，来阐述这一算法。为了更好地讲解，我们选择了一个回溯算法经典使用场景作为例子。希望本文能够帮助读者更加深入地理解和掌握回溯算法。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>\n<p>你可以按 <code>任何顺序</code> 返回答案。</p>\n<p>示例一：</p>\n<pre><code>输入：n = 4, k = 2\n  输出：\n  [\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n  ]\n</code></pre>\n<p>示例二：</p>\n<pre><code>输入：n = 1, k = 1\n  输出：[[1]]\n</code></pre>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/combinations/\">https://leetcode.cn/problems/combinations/</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-暴力枚举\"><a href=\"#2-1-暴力枚举\" class=\"headerlink\" title=\"2.1 暴力枚举\"></a>2.1 暴力枚举</h2><ul>\n<li>题目读起来易懂，但是题目本身并不简单。在 leetcode 上，只要涉及到使用回溯算法的题目，可以发现难度都为<code>中等</code>以上。</li>\n<li>由于回溯本质上仍然是暴力搜索，所以为了能更好的理解回溯算法，我们先从暴力法入手，尝试解决这个问题。</li>\n</ul>\n<h3 id=\"2-1-1-举例分析\"><a href=\"#2-1-1-举例分析\" class=\"headerlink\" title=\"2.1.1 举例分析\"></a>2.1.1 举例分析</h3><ul>\n<li><p>为了方便理解，我们由浅入深，先来看看<code>n = 3，k = 1</code>的情况，即从<code>[1,2,3]</code>中选<code>1</code>个数出来，有多少种组合？<br>这个直接一眼能看出来，即<code>[1],[2],[3]</code>共三种组合。代码随便写一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">          List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">          tmp.add(i);</span><br><span class=\"line\">          result.add(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>然后，我们来看看<code>n = 3，k = 2</code>的情况，即从<code>[1,2,3]</code>中选<code>2</code>个数出来，有多少种组合？<br>有数学基础的小伙伴应该能一眼看出组合的个数，即<code>3</code>个，学过排列组合就对这个不陌生。<br>$$<br>  C_3^1 = C_3^2<br>$$<br>但是题目的要求是输出所有组合，并不是单纯求组合个数，因此我们需要用到下面的暴力算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 为什么是 3 - 1 ？因为我们需要2个数，i = 3 没必要进入循环了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span> - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt;= <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                tmp.add(i);</span><br><span class=\"line\">                tmp.add(j);</span><br><span class=\"line\">                result.add(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>得出的结果为：<code>[[1, 2], [1, 3], [2, 3]]</code></p>\n</li>\n<li><p>最后，我们来看看<code>n = 4，k = 3</code>的情况，即从<code>[1,2,3,4]</code>中选<code>3</code>个数出来，有多少种组合？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span> - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span> - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> j + <span class=\"number\">1</span>; k &lt;= <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">                        List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                        tmp.add(i);</span><br><span class=\"line\">                        tmp.add(j);</span><br><span class=\"line\">                        tmp.add(k);</span><br><span class=\"line\">                        result.add(tmp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>得出的结果为：<code>[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]</code></p>\n</li>\n</ul>\n<h3 id=\"2-1-2-总结\"><a href=\"#2-1-2-总结\" class=\"headerlink\" title=\"2.1.2 总结\"></a>2.1.2 总结</h3><ul>\n<li>发现了吗？随着我们需要的组合的个数(k)增加，for循环的个数也在增加，这意味着时间复杂度将会变得非常糟糕，由于 n 和 k 不确定，我们还需要动态的改变for循环的个数。这无疑又增加了编码难度，简直吃力不讨好。</li>\n<li>这样一通操作下来，面试官肯定会说让你回家等消息了，不要慌，我们接下来看看回溯是如何操作的。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/10/oxMeKY.jpg\">\n\n<h2 id=\"2-2-回溯\"><a href=\"#2-2-回溯\" class=\"headerlink\" title=\"2.2 回溯\"></a>2.2 回溯</h2><h3 id=\"2-2-1-暴力枚举和回溯的区别\"><a href=\"#2-2-1-暴力枚举和回溯的区别\" class=\"headerlink\" title=\"2.2.1 暴力枚举和回溯的区别\"></a>2.2.1 暴力枚举和回溯的区别</h3><ul>\n<li>前面已经提到过，回溯的本质也是暴力枚举，那和普通的暴力枚举有什么区别？我们为什么还要选择这个算法？</li>\n<li>首先回答第一个问题：回溯和普通的暴力枚举有什么区别？<ol>\n<li>暴力枚举算法。通常采用嵌套循环的方式枚举所有可能的情况。适用于数据规模较小的场景。在数据规模较大的时候，这种暴力枚举算法会存在时间复杂度过高的问题，造成程序运行时间过长，甚至超时。</li>\n<li>回溯算法。通常采用递归的方式实现，通过不断尝试并回溯的方式，从所有可能的情况中搜索出符合要求的解。因为它具有回溯的功能，可以排除掉一些明显不符合要求的情况，从而避免了不必要的计算，从而实现了剪枝的功能，减少了计算的时间和空间复杂度。</li>\n</ol>\n</li>\n<li>我们为什么还要选择这个算法？<br>很简单，大部分都是因为<code>没得选</code>。</li>\n</ul>\n<h3 id=\"2-2-2-算法核心\"><a href=\"#2-2-2-算法核心\" class=\"headerlink\" title=\"2.2.2 算法核心\"></a>2.2.2 算法核心</h3><ul>\n<li>回溯算法的核心思想是深度优先搜索（DFS）。具体而言，在每一步搜索时，我们将当前节点加入已选列表中，然后递归地搜索下一个节点，直到满足结束条件时返回。接着我们将当前节点回溯，再搜索下一个节点。重复上述步骤，直到遍历完整个状态空间。其中，回溯过程可以通过撤销当前节点的选择来实现。</li>\n<li>就拿我们今天的组合问题举例，使用回溯算法求解组合问题的具体步骤如下：<ol>\n<li>定义状态：我们将每一步选择的结果视为一个状态，可以使用一个列表来记录已选元素。例如，选择<code>&#123;1,2,3&#125;</code>作为当前的组合方案，则当前状态为<code>[1,2,3]</code>。</li>\n<li>判断结束条件：当选出<code>k</code>个元素时，我们得到了一个组合方案，输出该方案并返回上一层继续搜索。</li>\n<li>递归搜索下一步：对于每一个未被选中的元素，我们将其加入已选列表中，并继续递归搜索下一个元素。然后<code>回溯撤销选择</code>，再在下一个节点继续搜索。</li>\n<li>剪枝：由于回溯算法的性质，我们需要在搜索时动态剪枝，避免不必要的搜索。具体而言，在每一步选择时，我们需要判断是否符合条件，如果不符则进行剪枝，直接返回上一层。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-2-3-举例分析\"><a href=\"#2-2-3-举例分析\" class=\"headerlink\" title=\"2.2.3 举例分析\"></a>2.2.3 举例分析</h3><ul>\n<li><p>光说不练假把式，我们来模拟一遍流程：<br>就选择<code>n = 3，k = 2</code>的情况，即从<code>[1,2,3]</code>中选<code>2</code>个数出来，有多少种组合？</p>\n</li>\n<li><p>分析</p>\n<ol>\n<li>定义状态。当前初始状态为<code>[]</code>，还没开始选择。</li>\n<li>判断结束条件。我们是选择<code>k = 2</code>个数，也就是说，当选出的元素达到<code>2</code>个时，就得到了一个组合方案</li>\n<li>递归搜索下一步。下面具体分析</li>\n<li>剪枝。下面具体分析</li>\n</ol>\n</li>\n<li><p>具体操作</p>\n<ol>\n<li>当前状态<code>[]</code>，可供选择的有<code>&#123;1,2,3&#125;</code>。</li>\n<li>选择<code>1</code>，当前状态为<code>[1]</code>，可供选择的有<code>&#123;2,3&#125;</code>。</li>\n<li>选择<code>2</code>，当前状态为<code>[1,2]</code>，满足结束条件，得到了一个组合方案<code>[1,2]</code>。</li>\n<li><code>回溯，撤销选择2</code>，当前状态<code>[1]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>选择<code>3</code>，当前状态为<code>[1,3]</code>，满足结束条件，得到了一个组合方案<code>[1,3]</code>。</li>\n<li><code>回溯，撤销选择3</code>，当前状态<code>[1]</code>，没有可供选择的元素。</li>\n<li><code>回溯，撤销选择1</code>，当前状态<code>[]</code>，可供选择的有<code>&#123;2,3&#125;</code>。</li>\n<li>选择<code>2</code>，当前状态为<code>[2]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>选择<code>3</code>，当前状态为<code>[2,3]</code>，满足结束条件，得到了一个组合方案<code>[2,3]</code>。</li>\n<li><code>回溯，撤销选择3</code>，当前状态<code>[2]</code>，没有可供选择的元素。</li>\n<li><code>回溯，撤销选择2</code>，当前状态<code>[]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>剪枝，由于可供选择的元素个数已经小于需要的组合元素个数<code>k</code>，抛弃掉后续所有分支。</li>\n</ol>\n</li>\n<li><p>上面的步骤中，第2步到第5步、第6步到第9步、第8步到第9步都参与了递归，每次选择一个元素后，继续递归搜索下一个元素，直到选出需要的k个元素或剪枝退出。在每次递归结束后，都要进行回溯撤销选择操作，并返回上一层继续搜索下一个元素。</p>\n</li>\n<li><p>用文字来描述递归回溯操作实在太过抽象，本身回溯操作就非常的烧脑子，说得越多越乱，因此读者一定要自己动手画一下流程，加深对每一步操作的理解。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2dUh.jpg\" width=\"30%\">\n\n<h3 id=\"2-2-4-总结\"><a href=\"#2-2-4-总结\" class=\"headerlink\" title=\"2.2.4 总结\"></a>2.2.4 总结</h3><ul>\n<li>在理解清楚每一个步骤之后，可以发现回溯确实明显是一种暴力枚举方案，但是呢，相比于传统的暴力枚举算法，它更加高效、灵活，具有极强的泛用性。</li>\n<li>还是没有体会到回溯相比传统暴力枚举算法的好处？没关系，下面的实操代码也许能帮助你感受二者的区别。</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li><p>一但涉及到递归，对于初学者来说编码都会是灾难级的。但是没关系，我会尽量在所有复杂的地方都写上注释，让代码更容易理解。</p>\n</li>\n<li><p><code>强烈建议</code>在IDE中打断点进行 Debug 调试！一步一步观察数据的变化，会极大的帮助你理解递归和回溯的操作。</p>\n</li>\n<li><p>下面就是一个组合问题的Java回溯算法代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来暂存满足条件的组合</span></span><br><span class=\"line\">    List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 最终的所有组合集合</span></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 回溯操作，从1开始确认每一个数字是否可选</span></span><br><span class=\"line\">      backTracking(n, k, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 回溯核心代码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> startIndex)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 满足条件，保存当前结果到result中</span></span><br><span class=\"line\">          result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(path));</span><br><span class=\"line\">          <span class=\"keyword\">return</span>; <span class=\"comment\">// 结束当前函数调用，进行回溯操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 剪枝操作，部分叶子结点不可能满足条件，可以不参与回溯操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里startIndex表示当前可选择的范围起始数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于最终组合的长度为k，所以剩下的数字个数应该 &gt;= 组合还需要的数字个数 (k - path.size())</span></span><br><span class=\"line\">        <span class=\"comment\">// 故剩下的数字范围是 [startIndex, n - (k - path.size()) + 1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">          path.add(i); <span class=\"comment\">// 处理节点，将当前数字加入path中</span></span><br><span class=\"line\">          backTracking(n, k, i + <span class=\"number\">1</span>); <span class=\"comment\">// 递归，继续处理下一位数字</span></span><br><span class=\"line\">          path.remove(path.size() - <span class=\"number\">1</span>); <span class=\"comment\">// 回溯，撤销处理的节点，进行回溯操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>需要注意的地方：</p>\n<ol>\n<li>函数参数startIndex表示当前可选择的范围起始数字，而不是当前处理的数字。</li>\n<li>对于每一次满足条件的结果，需要将结果的一个拷贝new ArrayList(path)添加到最终结果中。如果直接添加path，会在回溯时对结果进行修改，导致最终结果出错（由于回溯操作最后都会清空暂存数组，最终结果将全为空集<code>[]</code>）。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>回溯算法是求解组合问题的一种常用算法。对于组合问题，我们可以通过深度优先搜索的方式进行求解，并在实现过程中注意剪枝等优化措施。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>回溯算法（Backtracking）是一种在搜索过程中寻找问题解答的方法。顾名思义，回溯算法就是在考虑一个问题的所有选项时，使用回溯（即返回原状态）来尝试每个可能的选项，直到找到符合要求的解决方案。需要注意的是，回溯算法只适用于问题的解空间较小，否则其时间复杂度会非常高。在本篇文章中，我们将通过介绍回溯算法的基本概念和简单应用，来阐述这一算法。为了更好地讲解，我们选择了一个回溯算法经典使用场景作为例子。希望本文能够帮助读者更加深入地理解和掌握回溯算法。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>\n<p>你可以按 <code>任何顺序</code> 返回答案。</p>\n<p>示例一：</p>\n<pre><code>输入：n = 4, k = 2\n  输出：\n  [\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n  ]\n</code></pre>\n<p>示例二：</p>\n<pre><code>输入：n = 1, k = 1\n  输出：[[1]]\n</code></pre>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/combinations/\">https://leetcode.cn/problems/combinations/</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-暴力枚举\"><a href=\"#2-1-暴力枚举\" class=\"headerlink\" title=\"2.1 暴力枚举\"></a>2.1 暴力枚举</h2><ul>\n<li>题目读起来易懂，但是题目本身并不简单。在 leetcode 上，只要涉及到使用回溯算法的题目，可以发现难度都为<code>中等</code>以上。</li>\n<li>由于回溯本质上仍然是暴力搜索，所以为了能更好的理解回溯算法，我们先从暴力法入手，尝试解决这个问题。</li>\n</ul>\n<h3 id=\"2-1-1-举例分析\"><a href=\"#2-1-1-举例分析\" class=\"headerlink\" title=\"2.1.1 举例分析\"></a>2.1.1 举例分析</h3><ul>\n<li><p>为了方便理解，我们由浅入深，先来看看<code>n = 3，k = 1</code>的情况，即从<code>[1,2,3]</code>中选<code>1</code>个数出来，有多少种组合？<br>这个直接一眼能看出来，即<code>[1],[2],[3]</code>共三种组合。代码随便写一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">          List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">          tmp.add(i);</span><br><span class=\"line\">          result.add(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>然后，我们来看看<code>n = 3，k = 2</code>的情况，即从<code>[1,2,3]</code>中选<code>2</code>个数出来，有多少种组合？<br>有数学基础的小伙伴应该能一眼看出组合的个数，即<code>3</code>个，学过排列组合就对这个不陌生。<br>$$<br>  C_3^1 = C_3^2<br>$$<br>但是题目的要求是输出所有组合，并不是单纯求组合个数，因此我们需要用到下面的暴力算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 为什么是 3 - 1 ？因为我们需要2个数，i = 3 没必要进入循环了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span> - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt;= <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                tmp.add(i);</span><br><span class=\"line\">                tmp.add(j);</span><br><span class=\"line\">                result.add(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>得出的结果为：<code>[[1, 2], [1, 3], [2, 3]]</code></p>\n</li>\n<li><p>最后，我们来看看<code>n = 4，k = 3</code>的情况，即从<code>[1,2,3,4]</code>中选<code>3</code>个数出来，有多少种组合？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span> - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span> - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> j + <span class=\"number\">1</span>; k &lt;= <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">                        List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                        tmp.add(i);</span><br><span class=\"line\">                        tmp.add(j);</span><br><span class=\"line\">                        tmp.add(k);</span><br><span class=\"line\">                        result.add(tmp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>得出的结果为：<code>[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]</code></p>\n</li>\n</ul>\n<h3 id=\"2-1-2-总结\"><a href=\"#2-1-2-总结\" class=\"headerlink\" title=\"2.1.2 总结\"></a>2.1.2 总结</h3><ul>\n<li>发现了吗？随着我们需要的组合的个数(k)增加，for循环的个数也在增加，这意味着时间复杂度将会变得非常糟糕，由于 n 和 k 不确定，我们还需要动态的改变for循环的个数。这无疑又增加了编码难度，简直吃力不讨好。</li>\n<li>这样一通操作下来，面试官肯定会说让你回家等消息了，不要慌，我们接下来看看回溯是如何操作的。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/10/oxMeKY.jpg\">\n\n<h2 id=\"2-2-回溯\"><a href=\"#2-2-回溯\" class=\"headerlink\" title=\"2.2 回溯\"></a>2.2 回溯</h2><h3 id=\"2-2-1-暴力枚举和回溯的区别\"><a href=\"#2-2-1-暴力枚举和回溯的区别\" class=\"headerlink\" title=\"2.2.1 暴力枚举和回溯的区别\"></a>2.2.1 暴力枚举和回溯的区别</h3><ul>\n<li>前面已经提到过，回溯的本质也是暴力枚举，那和普通的暴力枚举有什么区别？我们为什么还要选择这个算法？</li>\n<li>首先回答第一个问题：回溯和普通的暴力枚举有什么区别？<ol>\n<li>暴力枚举算法。通常采用嵌套循环的方式枚举所有可能的情况。适用于数据规模较小的场景。在数据规模较大的时候，这种暴力枚举算法会存在时间复杂度过高的问题，造成程序运行时间过长，甚至超时。</li>\n<li>回溯算法。通常采用递归的方式实现，通过不断尝试并回溯的方式，从所有可能的情况中搜索出符合要求的解。因为它具有回溯的功能，可以排除掉一些明显不符合要求的情况，从而避免了不必要的计算，从而实现了剪枝的功能，减少了计算的时间和空间复杂度。</li>\n</ol>\n</li>\n<li>我们为什么还要选择这个算法？<br>很简单，大部分都是因为<code>没得选</code>。</li>\n</ul>\n<h3 id=\"2-2-2-算法核心\"><a href=\"#2-2-2-算法核心\" class=\"headerlink\" title=\"2.2.2 算法核心\"></a>2.2.2 算法核心</h3><ul>\n<li>回溯算法的核心思想是深度优先搜索（DFS）。具体而言，在每一步搜索时，我们将当前节点加入已选列表中，然后递归地搜索下一个节点，直到满足结束条件时返回。接着我们将当前节点回溯，再搜索下一个节点。重复上述步骤，直到遍历完整个状态空间。其中，回溯过程可以通过撤销当前节点的选择来实现。</li>\n<li>就拿我们今天的组合问题举例，使用回溯算法求解组合问题的具体步骤如下：<ol>\n<li>定义状态：我们将每一步选择的结果视为一个状态，可以使用一个列表来记录已选元素。例如，选择<code>&#123;1,2,3&#125;</code>作为当前的组合方案，则当前状态为<code>[1,2,3]</code>。</li>\n<li>判断结束条件：当选出<code>k</code>个元素时，我们得到了一个组合方案，输出该方案并返回上一层继续搜索。</li>\n<li>递归搜索下一步：对于每一个未被选中的元素，我们将其加入已选列表中，并继续递归搜索下一个元素。然后<code>回溯撤销选择</code>，再在下一个节点继续搜索。</li>\n<li>剪枝：由于回溯算法的性质，我们需要在搜索时动态剪枝，避免不必要的搜索。具体而言，在每一步选择时，我们需要判断是否符合条件，如果不符则进行剪枝，直接返回上一层。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-2-3-举例分析\"><a href=\"#2-2-3-举例分析\" class=\"headerlink\" title=\"2.2.3 举例分析\"></a>2.2.3 举例分析</h3><ul>\n<li><p>光说不练假把式，我们来模拟一遍流程：<br>就选择<code>n = 3，k = 2</code>的情况，即从<code>[1,2,3]</code>中选<code>2</code>个数出来，有多少种组合？</p>\n</li>\n<li><p>分析</p>\n<ol>\n<li>定义状态。当前初始状态为<code>[]</code>，还没开始选择。</li>\n<li>判断结束条件。我们是选择<code>k = 2</code>个数，也就是说，当选出的元素达到<code>2</code>个时，就得到了一个组合方案</li>\n<li>递归搜索下一步。下面具体分析</li>\n<li>剪枝。下面具体分析</li>\n</ol>\n</li>\n<li><p>具体操作</p>\n<ol>\n<li>当前状态<code>[]</code>，可供选择的有<code>&#123;1,2,3&#125;</code>。</li>\n<li>选择<code>1</code>，当前状态为<code>[1]</code>，可供选择的有<code>&#123;2,3&#125;</code>。</li>\n<li>选择<code>2</code>，当前状态为<code>[1,2]</code>，满足结束条件，得到了一个组合方案<code>[1,2]</code>。</li>\n<li><code>回溯，撤销选择2</code>，当前状态<code>[1]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>选择<code>3</code>，当前状态为<code>[1,3]</code>，满足结束条件，得到了一个组合方案<code>[1,3]</code>。</li>\n<li><code>回溯，撤销选择3</code>，当前状态<code>[1]</code>，没有可供选择的元素。</li>\n<li><code>回溯，撤销选择1</code>，当前状态<code>[]</code>，可供选择的有<code>&#123;2,3&#125;</code>。</li>\n<li>选择<code>2</code>，当前状态为<code>[2]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>选择<code>3</code>，当前状态为<code>[2,3]</code>，满足结束条件，得到了一个组合方案<code>[2,3]</code>。</li>\n<li><code>回溯，撤销选择3</code>，当前状态<code>[2]</code>，没有可供选择的元素。</li>\n<li><code>回溯，撤销选择2</code>，当前状态<code>[]</code>，可供选择的有<code>&#123;3&#125;</code>。</li>\n<li>剪枝，由于可供选择的元素个数已经小于需要的组合元素个数<code>k</code>，抛弃掉后续所有分支。</li>\n</ol>\n</li>\n<li><p>上面的步骤中，第2步到第5步、第6步到第9步、第8步到第9步都参与了递归，每次选择一个元素后，继续递归搜索下一个元素，直到选出需要的k个元素或剪枝退出。在每次递归结束后，都要进行回溯撤销选择操作，并返回上一层继续搜索下一个元素。</p>\n</li>\n<li><p>用文字来描述递归回溯操作实在太过抽象，本身回溯操作就非常的烧脑子，说得越多越乱，因此读者一定要自己动手画一下流程，加深对每一步操作的理解。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2dUh.jpg\" width=\"30%\">\n\n<h3 id=\"2-2-4-总结\"><a href=\"#2-2-4-总结\" class=\"headerlink\" title=\"2.2.4 总结\"></a>2.2.4 总结</h3><ul>\n<li>在理解清楚每一个步骤之后，可以发现回溯确实明显是一种暴力枚举方案，但是呢，相比于传统的暴力枚举算法，它更加高效、灵活，具有极强的泛用性。</li>\n<li>还是没有体会到回溯相比传统暴力枚举算法的好处？没关系，下面的实操代码也许能帮助你感受二者的区别。</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li><p>一但涉及到递归，对于初学者来说编码都会是灾难级的。但是没关系，我会尽量在所有复杂的地方都写上注释，让代码更容易理解。</p>\n</li>\n<li><p><code>强烈建议</code>在IDE中打断点进行 Debug 调试！一步一步观察数据的变化，会极大的帮助你理解递归和回溯的操作。</p>\n</li>\n<li><p>下面就是一个组合问题的Java回溯算法代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来暂存满足条件的组合</span></span><br><span class=\"line\">    List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 最终的所有组合集合</span></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 回溯操作，从1开始确认每一个数字是否可选</span></span><br><span class=\"line\">      backTracking(n, k, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 回溯核心代码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> startIndex)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 满足条件，保存当前结果到result中</span></span><br><span class=\"line\">          result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(path));</span><br><span class=\"line\">          <span class=\"keyword\">return</span>; <span class=\"comment\">// 结束当前函数调用，进行回溯操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 剪枝操作，部分叶子结点不可能满足条件，可以不参与回溯操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里startIndex表示当前可选择的范围起始数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于最终组合的长度为k，所以剩下的数字个数应该 &gt;= 组合还需要的数字个数 (k - path.size())</span></span><br><span class=\"line\">        <span class=\"comment\">// 故剩下的数字范围是 [startIndex, n - (k - path.size()) + 1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">          path.add(i); <span class=\"comment\">// 处理节点，将当前数字加入path中</span></span><br><span class=\"line\">          backTracking(n, k, i + <span class=\"number\">1</span>); <span class=\"comment\">// 递归，继续处理下一位数字</span></span><br><span class=\"line\">          path.remove(path.size() - <span class=\"number\">1</span>); <span class=\"comment\">// 回溯，撤销处理的节点，进行回溯操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>需要注意的地方：</p>\n<ol>\n<li>函数参数startIndex表示当前可选择的范围起始数字，而不是当前处理的数字。</li>\n<li>对于每一次满足条件的结果，需要将结果的一个拷贝new ArrayList(path)添加到最终结果中。如果直接添加path，会在回溯时对结果进行修改，导致最终结果出错（由于回溯操作最后都会清空暂存数组，最终结果将全为空集<code>[]</code>）。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>回溯算法是求解组合问题的一种常用算法。对于组合问题，我们可以通过深度优先搜索的方式进行求解，并在实现过程中注意剪枝等优化措施。</li>\n</ul>\n"},{"title":"安卓线程间通信的两种方式","date":"2023-03-31T00:00:00.000Z","description":"安卓多线程异步任务处理的两种方案 AsyncTask 与 Handler 的异同","cover":"https://www.helloimg.com/images/2023/07/19/oA2wPc.webp","_content":"\n> 在安卓开发中，我们经常会需要使用异步处理任务，以避免应用在执行一些耗时操作时出现卡顿或ANR（Application Not Responding）现象。在这种情况下，Handler和AsyncTask是两个非常有用的工具。\n\n# 一、多线程概述\n\n## 1.1 什么是多线程？\n\n- 相信只要接触过编程的同学对\"多线程\"、\"异步\"这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是\"线程\"，以及跟线程密切相关的另一个家伙：进程。\n- 一般来说，线程和进程的概念如下：\n    - 进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。\n    - 线程：一个基本的CPU执行单元 & 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。\n\n- 概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：\n    - CPU：一座时刻运行的工厂\n    - 进程：工厂的一个车间\n    - 线程：在车间里面活动的工人\n      CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 & 程序执行流的最小单元。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA20Hq.webp\">\n\n  **多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务**\n\n# 二、安卓实现多线程异步任务的两种方式\n\n我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。\n但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论**如何让安卓实现线程间通信（一般是指子线程和主线程通信）**。\n\n## 2.1 Handler\n\n- 首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。\n    - <font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font>\n      这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2N7r.gif\">\n\n### 2.1.1 Handler的使用\n\n下面将演示Handler的基本使用</br>\n<font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。\n\n1. 定义Handler，在handleMessage方法中，推荐使用switch...case语句判断msg.what，从而进行指定的操作\n\n```Java\nclass Concurrent_ {\n    private final Handler handler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            //根据msg.what的值处理不同的任务，主线程中，可以操作UI\n            switch (msg.what) {\n                case 1:\n                    //操作1\n                    break;\n                case 2:\n                    //操作2\n                    //可以直接更改某控件的UI\n                    tvTest.setText((String) msg.obj);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n}\n```\n\n2. 子线程中使用Handler发送空消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        new Thread(() -> {\n            //模拟一个网络请求\n            try {\n                Thread.sleep(2000);//两秒后请求成功\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            handler.sendEmptyMessage(1);//使用sendEmptyMessage发送一个空消息，what为1\n        }).start();\n    }\n}\n```\n\n3. 子线程中使用Handler发送消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        /*  省略  */\n        Message message = new Message();\n        message.obj = \"Hello Word\";\n        message.what = 2;\n        handler.sendMessage(message);//使用sendMessage发送一个带Message对象的消息，what为2\n        /*  省略  */\n    }\n}\n```\n\n### 2.1.2 Handler小结\n\n- 可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)\n  运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。\n\n## 2.2 AsyncTask\n\nAsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。\n\n### 2.2.1 AsyncTask的使用\n\n1. 创建一个类继承自AsyncTask\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    /*  省略  */\n    @Override\n    protected Bitmap doInBackground(Integer... integers) {\n        //做异步任务\n    }\n\n    /*  省略  */\n    @Override\n    protected void onPostExecute(Bitmap bitmap) {\n        //异步任务完成后的操作\n    }\n}\n\n```\n\n2. 开启异步任务\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        MyTask myTask = new MyTask();\n        myTask.execute();\n    }\n}\n```\n\n是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。\n除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    @Override\n    protected void onPreExecute() {\n        //执行异步任务之前，当然还处于主线程，可以操作UI\n    }\n\n    @Override\n    protected void onProgressUpdate(Void... values) {\n        //用来更新进度条等操作\n    }\n}\n```\n\nAsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理\n他的三个泛型参数AsyncTask<Integer, Void, Bitmap>代表的含义分别是：\n\n- Void：表示在执行AsyncTask的时候不需要传入参数给后台任务\n- Integer：表示使用整型数据来作为进度显示单位\n- Bitmap：表示使用Bitmap位图来反馈执行结果\n\n下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：\n\n```java\nclass AsyncTask_ extends AsyncTask<Void, Integer, Boolean> {\n\n    //在一步开始之前，在主线程，可操作UI，一般用来做准备工作\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        Toast.makeText(context, \"开始模拟下载\", Toast.LENGTH_SHORT).show();\n    }\n\n    //异步线程中执行\n    @Override\n    protected Boolean doInBackground(Void... voids) {\n        int p = 0;\n        //模拟网络延迟\n        try {\n            //p = 1 / 0;//模拟下载失败\n            while (p < 100) {\n                Thread.sleep(1000);\n                p += 10;\n                publishProgress(p);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        //通知主线程当前执行的进度\n        return true;\n    }\n\n    //切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n        super.onProgressUpdate(values);\n        Log.e(\"TAG\", \"正在下载：\" + values[0] + \"%\");\n        binding.pb.setProgress(values[0]);\n    }\n\n    //切换到主线程\n    @Override\n    protected void onPostExecute(Boolean b) {\n        super.onPostExecute(b);\n        if (b) {\n            Toast.makeText(context, \"下载完成！\", Toast.LENGTH_SHORT).show();\n        } else Toast.makeText(context, \"下载失败！\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n### 2.2.2 AsyncTask小结\n\n- 不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。\n\n# 三、总结\n\n- Handler\n    - 优点\n        - 结构清晰，功能定义明确\n        - 对于多个后台任务时，更加简单，根据msg.what进行判断即可\n    - 缺点\n        - 在单个后台异步处理时，显得代码过多，结构过于复杂\n- AsyncTask\n    - 优点\n        - 对于单个任务是，更加简单，快捷\n        - 操作过程更加清晰明确，过程可控\n    - 缺点\n        - 在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来\n        - 最大并发数不超过5\n\n- 看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。","source":"_posts/安卓_01_安卓线程间通信的两种方式.md","raw":"---\ntitle: '安卓线程间通信的两种方式'\ndate: '2023-03-31'\ndescription: '安卓多线程异步任务处理的两种方案 AsyncTask 与 Handler 的异同'\ncover: 'https://www.helloimg.com/images/2023/07/19/oA2wPc.webp'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Java\n- Android\n- 并发编程\n\n---\n\n> 在安卓开发中，我们经常会需要使用异步处理任务，以避免应用在执行一些耗时操作时出现卡顿或ANR（Application Not Responding）现象。在这种情况下，Handler和AsyncTask是两个非常有用的工具。\n\n# 一、多线程概述\n\n## 1.1 什么是多线程？\n\n- 相信只要接触过编程的同学对\"多线程\"、\"异步\"这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是\"线程\"，以及跟线程密切相关的另一个家伙：进程。\n- 一般来说，线程和进程的概念如下：\n    - 进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。\n    - 线程：一个基本的CPU执行单元 & 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。\n\n- 概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：\n    - CPU：一座时刻运行的工厂\n    - 进程：工厂的一个车间\n    - 线程：在车间里面活动的工人\n      CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 & 程序执行流的最小单元。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA20Hq.webp\">\n\n  **多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务**\n\n# 二、安卓实现多线程异步任务的两种方式\n\n我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。\n但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论**如何让安卓实现线程间通信（一般是指子线程和主线程通信）**。\n\n## 2.1 Handler\n\n- 首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。\n    - <font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font>\n      这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。\n\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2N7r.gif\">\n\n### 2.1.1 Handler的使用\n\n下面将演示Handler的基本使用</br>\n<font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。\n\n1. 定义Handler，在handleMessage方法中，推荐使用switch...case语句判断msg.what，从而进行指定的操作\n\n```Java\nclass Concurrent_ {\n    private final Handler handler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            //根据msg.what的值处理不同的任务，主线程中，可以操作UI\n            switch (msg.what) {\n                case 1:\n                    //操作1\n                    break;\n                case 2:\n                    //操作2\n                    //可以直接更改某控件的UI\n                    tvTest.setText((String) msg.obj);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n}\n```\n\n2. 子线程中使用Handler发送空消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        new Thread(() -> {\n            //模拟一个网络请求\n            try {\n                Thread.sleep(2000);//两秒后请求成功\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            handler.sendEmptyMessage(1);//使用sendEmptyMessage发送一个空消息，what为1\n        }).start();\n    }\n}\n```\n\n3. 子线程中使用Handler发送消息给主线程\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        /*  省略  */\n        Message message = new Message();\n        message.obj = \"Hello Word\";\n        message.what = 2;\n        handler.sendMessage(message);//使用sendMessage发送一个带Message对象的消息，what为2\n        /*  省略  */\n    }\n}\n```\n\n### 2.1.2 Handler小结\n\n- 可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)\n  运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。\n\n## 2.2 AsyncTask\n\nAsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。\n\n### 2.2.1 AsyncTask的使用\n\n1. 创建一个类继承自AsyncTask\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    /*  省略  */\n    @Override\n    protected Bitmap doInBackground(Integer... integers) {\n        //做异步任务\n    }\n\n    /*  省略  */\n    @Override\n    protected void onPostExecute(Bitmap bitmap) {\n        //异步任务完成后的操作\n    }\n}\n\n```\n\n2. 开启异步任务\n\n```java\nclass Concurrent_ {\n    public void method_() {\n        MyTask myTask = new MyTask();\n        myTask.execute();\n    }\n}\n```\n\n是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。\n除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：\n\n```java\nclass MyTask extends AsyncTask<Void, Integer, Bitmap> {\n    @Override\n    protected void onPreExecute() {\n        //执行异步任务之前，当然还处于主线程，可以操作UI\n    }\n\n    @Override\n    protected void onProgressUpdate(Void... values) {\n        //用来更新进度条等操作\n    }\n}\n```\n\nAsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理\n他的三个泛型参数AsyncTask<Integer, Void, Bitmap>代表的含义分别是：\n\n- Void：表示在执行AsyncTask的时候不需要传入参数给后台任务\n- Integer：表示使用整型数据来作为进度显示单位\n- Bitmap：表示使用Bitmap位图来反馈执行结果\n\n下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：\n\n```java\nclass AsyncTask_ extends AsyncTask<Void, Integer, Boolean> {\n\n    //在一步开始之前，在主线程，可操作UI，一般用来做准备工作\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        Toast.makeText(context, \"开始模拟下载\", Toast.LENGTH_SHORT).show();\n    }\n\n    //异步线程中执行\n    @Override\n    protected Boolean doInBackground(Void... voids) {\n        int p = 0;\n        //模拟网络延迟\n        try {\n            //p = 1 / 0;//模拟下载失败\n            while (p < 100) {\n                Thread.sleep(1000);\n                p += 10;\n                publishProgress(p);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        //通知主线程当前执行的进度\n        return true;\n    }\n\n    //切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n        super.onProgressUpdate(values);\n        Log.e(\"TAG\", \"正在下载：\" + values[0] + \"%\");\n        binding.pb.setProgress(values[0]);\n    }\n\n    //切换到主线程\n    @Override\n    protected void onPostExecute(Boolean b) {\n        super.onPostExecute(b);\n        if (b) {\n            Toast.makeText(context, \"下载完成！\", Toast.LENGTH_SHORT).show();\n        } else Toast.makeText(context, \"下载失败！\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n### 2.2.2 AsyncTask小结\n\n- 不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。\n\n# 三、总结\n\n- Handler\n    - 优点\n        - 结构清晰，功能定义明确\n        - 对于多个后台任务时，更加简单，根据msg.what进行判断即可\n    - 缺点\n        - 在单个后台异步处理时，显得代码过多，结构过于复杂\n- AsyncTask\n    - 优点\n        - 对于单个任务是，更加简单，快捷\n        - 操作过程更加清晰明确，过程可控\n    - 缺点\n        - 在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来\n        - 最大并发数不超过5\n\n- 看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。","slug":"安卓_01_安卓线程间通信的两种方式","published":1,"updated":"2023-07-19T09:23:44.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyto000om7ho20pl0si9","content":"<blockquote>\n<p>在安卓开发中，我们经常会需要使用异步处理任务，以避免应用在执行一些耗时操作时出现卡顿或ANR（Application Not Responding）现象。在这种情况下，Handler和AsyncTask是两个非常有用的工具。</p>\n</blockquote>\n<h1 id=\"一、多线程概述\"><a href=\"#一、多线程概述\" class=\"headerlink\" title=\"一、多线程概述\"></a>一、多线程概述</h1><h2 id=\"1-1-什么是多线程？\"><a href=\"#1-1-什么是多线程？\" class=\"headerlink\" title=\"1.1 什么是多线程？\"></a>1.1 什么是多线程？</h2><ul>\n<li><p>相信只要接触过编程的同学对”多线程”、”异步”这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是”线程”，以及跟线程密切相关的另一个家伙：进程。</p>\n</li>\n<li><p>一般来说，线程和进程的概念如下：</p>\n<ul>\n<li>进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。</li>\n<li>线程：一个基本的CPU执行单元 &amp; 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。</li>\n</ul>\n</li>\n<li><p>概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：</p>\n<ul>\n<li>CPU：一座时刻运行的工厂</li>\n<li>进程：工厂的一个车间</li>\n<li>线程：在车间里面活动的工人<br>CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 &amp; 程序执行流的最小单元。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA20Hq.webp\">\n\n<p>  <strong>多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务</strong></p>\n<h1 id=\"二、安卓实现多线程异步任务的两种方式\"><a href=\"#二、安卓实现多线程异步任务的两种方式\" class=\"headerlink\" title=\"二、安卓实现多线程异步任务的两种方式\"></a>二、安卓实现多线程异步任务的两种方式</h1><p>我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。<br>但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论<strong>如何让安卓实现线程间通信（一般是指子线程和主线程通信）</strong>。</p>\n<h2 id=\"2-1-Handler\"><a href=\"#2-1-Handler\" class=\"headerlink\" title=\"2.1 Handler\"></a>2.1 Handler</h2><ul>\n<li>首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。<ul>\n<li><font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font><br>这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2N7r.gif\">\n\n<h3 id=\"2-1-1-Handler的使用\"><a href=\"#2-1-1-Handler的使用\" class=\"headerlink\" title=\"2.1.1 Handler的使用\"></a>2.1.1 Handler的使用</h3><p>下面将演示Handler的基本使用</br><br><font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。</p>\n<ol>\n<li>定义Handler，在handleMessage方法中，推荐使用switch…case语句判断msg.what，从而进行指定的操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据msg.what的值处理不同的任务，主线程中，可以操作UI</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作2</span></span><br><span class=\"line\">                    <span class=\"comment\">//可以直接更改某控件的UI</span></span><br><span class=\"line\">                    tvTest.setText((String) msg.obj);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子线程中使用Handler发送空消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//模拟一个网络请求</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//两秒后请求成功</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">1</span>);<span class=\"comment\">//使用sendEmptyMessage发送一个空消息，what为1</span></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子线程中使用Handler发送消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>();</span><br><span class=\"line\">        message.obj = <span class=\"string\">&quot;Hello Word&quot;</span>;</span><br><span class=\"line\">        message.what = <span class=\"number\">2</span>;</span><br><span class=\"line\">        handler.sendMessage(message);<span class=\"comment\">//使用sendMessage发送一个带Message对象的消息，what为2</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-Handler小结\"><a href=\"#2-1-2-Handler小结\" class=\"headerlink\" title=\"2.1.2 Handler小结\"></a>2.1.2 Handler小结</h3><ul>\n<li>可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)<br>运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。</li>\n</ul>\n<h2 id=\"2-2-AsyncTask\"><a href=\"#2-2-AsyncTask\" class=\"headerlink\" title=\"2.2 AsyncTask\"></a>2.2 AsyncTask</h2><p>AsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。</p>\n<h3 id=\"2-2-1-AsyncTask的使用\"><a href=\"#2-2-1-AsyncTask的使用\" class=\"headerlink\" title=\"2.2.1 AsyncTask的使用\"></a>2.2.1 AsyncTask的使用</h3><ol>\n<li>创建一个类继承自AsyncTask</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Bitmap <span class=\"title function_\">doInBackground</span><span class=\"params\">(Integer... integers)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//做异步任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//异步任务完成后的操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启异步任务</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyTask</span> <span class=\"variable\">myTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyTask</span>();</span><br><span class=\"line\">        myTask.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。<br>除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行异步任务之前，当然还处于主线程，可以操作UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Void... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用来更新进度条等操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理<br>他的三个泛型参数AsyncTask&lt;Integer, Void, Bitmap&gt;代表的含义分别是：</p>\n<ul>\n<li>Void：表示在执行AsyncTask的时候不需要传入参数给后台任务</li>\n<li>Integer：表示使用整型数据来作为进度显示单位</li>\n<li>Bitmap：表示使用Bitmap位图来反馈执行结果</li>\n</ul>\n<p>下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncTask_</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//在一步开始之前，在主线程，可操作UI，一般用来做准备工作</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPreExecute();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;开始模拟下载&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异步线程中执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Boolean <span class=\"title function_\">doInBackground</span><span class=\"params\">(Void... voids)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//模拟网络延迟</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p = 1 / 0;//模拟下载失败</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                p += <span class=\"number\">10</span>;</span><br><span class=\"line\">                publishProgress(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//通知主线程当前执行的进度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Integer... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onProgressUpdate(values);</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;正在下载：&quot;</span> + values[<span class=\"number\">0</span>] + <span class=\"string\">&quot;%&quot;</span>);</span><br><span class=\"line\">        binding.pb.setProgress(values[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到主线程</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Boolean b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPostExecute(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">            Toast.makeText(context, <span class=\"string\">&quot;下载完成！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> Toast.makeText(context, <span class=\"string\">&quot;下载失败！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-AsyncTask小结\"><a href=\"#2-2-2-AsyncTask小结\" class=\"headerlink\" title=\"2.2.2 AsyncTask小结\"></a>2.2.2 AsyncTask小结</h3><ul>\n<li>不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li><p>Handler</p>\n<ul>\n<li>优点<ul>\n<li>结构清晰，功能定义明确</li>\n<li>对于多个后台任务时，更加简单，根据msg.what进行判断即可</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在单个后台异步处理时，显得代码过多，结构过于复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AsyncTask</p>\n<ul>\n<li>优点<ul>\n<li>对于单个任务是，更加简单，快捷</li>\n<li>操作过程更加清晰明确，过程可控</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来</li>\n<li>最大并发数不超过5</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。</p>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>在安卓开发中，我们经常会需要使用异步处理任务，以避免应用在执行一些耗时操作时出现卡顿或ANR（Application Not Responding）现象。在这种情况下，Handler和AsyncTask是两个非常有用的工具。</p>\n</blockquote>\n<h1 id=\"一、多线程概述\"><a href=\"#一、多线程概述\" class=\"headerlink\" title=\"一、多线程概述\"></a>一、多线程概述</h1><h2 id=\"1-1-什么是多线程？\"><a href=\"#1-1-什么是多线程？\" class=\"headerlink\" title=\"1.1 什么是多线程？\"></a>1.1 什么是多线程？</h2><ul>\n<li><p>相信只要接触过编程的同学对”多线程”、”异步”这些字眼肯定不会陌生，那么什么是多线程呢？讨论多线程之前，我们需要先知道什么是”线程”，以及跟线程密切相关的另一个家伙：进程。</p>\n</li>\n<li><p>一般来说，线程和进程的概念如下：</p>\n<ul>\n<li>进程：是程序运行过程中系统进行资源分配和调度的一个独立单位，使多个程序可并发执行，以提高系统的资源利用率和吞吐量。</li>\n<li>线程：一个基本的CPU执行单元 &amp; 程序执行流的最小单元。 线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。</li>\n</ul>\n</li>\n<li><p>概念里面涉及到一些操作系统里面的概念，不需要深入理解。CPU、线程、进程之间的关系，我们可以举个形象的例子：</p>\n<ul>\n<li>CPU：一座时刻运行的工厂</li>\n<li>进程：工厂的一个车间</li>\n<li>线程：在车间里面活动的工人<br>CPU作为工厂，拥有很多个车间（进程），具体取决于CPU的核心数。一条车间（进程）可同时容纳多个工人（线程），即可以同时有多个工人同时在同一个车间上工作。工人不可再分，即线程是CPU执行单元 &amp; 程序执行流的最小单元。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA20Hq.webp\">\n\n<p>  <strong>多线程即：在一个程序中可以同时运行多个不同的线程来执行不同的任务</strong></p>\n<h1 id=\"二、安卓实现多线程异步任务的两种方式\"><a href=\"#二、安卓实现多线程异步任务的两种方式\" class=\"headerlink\" title=\"二、安卓实现多线程异步任务的两种方式\"></a>二、安卓实现多线程异步任务的两种方式</h1><p>我们知道，安卓是可以使用Java语言进行开发的，而在Java的并发包JUC（java.util.concurrent）中，提供了丰富的api供程序员们使用，可以非常好的实现高并发任务。<br>但是今天我们并不讨论太多关于多线程实现细节方面的问题，而是讨论Android应用如何实现异步任务，并返回结果给主线程；换句话说，是讨论<strong>如何让安卓实现线程间通信（一般是指子线程和主线程通信）</strong>。</p>\n<h2 id=\"2-1-Handler\"><a href=\"#2-1-Handler\" class=\"headerlink\" title=\"2.1 Handler\"></a>2.1 Handler</h2><ul>\n<li>首先出场的，就是我们的Handler，相信绝大多数安卓程序员在首次进行线程间通信时，使用的就是Handler来进行的。并且，通常是因为下面这个错误导致程序崩溃后，查阅资料发现的Handler。<ul>\n<li><font color=\"#dd0000\">Only the original thread that created a view hierarchy can touch its views.</font><br>这句话可以理解为：只能在UI线程才能操作UI，当在子线程中操作UI，例如更改一个TextView的内容时，就会抛出这个错误，相信几乎所有的安卓新手程序员都遇到过这个错误。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/19/oA2N7r.gif\">\n\n<h3 id=\"2-1-1-Handler的使用\"><a href=\"#2-1-1-Handler的使用\" class=\"headerlink\" title=\"2.1.1 Handler的使用\"></a>2.1.1 Handler的使用</h3><p>下面将演示Handler的基本使用</br><br><font color=\"#dd0000\">注意：</font>后续的代码由于是演示，因此并未太过规范，实际情况中一定要注意变量的声明格式，以及线程管理等等，千万不能随意new线程然后直接启动，这样可能严重拖慢程序运行，甚至导致程序崩溃。</p>\n<ol>\n<li>定义Handler，在handleMessage方法中，推荐使用switch…case语句判断msg.what，从而进行指定的操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据msg.what的值处理不同的任务，主线程中，可以操作UI</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//操作2</span></span><br><span class=\"line\">                    <span class=\"comment\">//可以直接更改某控件的UI</span></span><br><span class=\"line\">                    tvTest.setText((String) msg.obj);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子线程中使用Handler发送空消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//模拟一个网络请求</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//两秒后请求成功</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">1</span>);<span class=\"comment\">//使用sendEmptyMessage发送一个空消息，what为1</span></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子线程中使用Handler发送消息给主线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>();</span><br><span class=\"line\">        message.obj = <span class=\"string\">&quot;Hello Word&quot;</span>;</span><br><span class=\"line\">        message.what = <span class=\"number\">2</span>;</span><br><span class=\"line\">        handler.sendMessage(message);<span class=\"comment\">//使用sendMessage发送一个带Message对象的消息，what为2</span></span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-Handler小结\"><a href=\"#2-1-2-Handler小结\" class=\"headerlink\" title=\"2.1.2 Handler小结\"></a>2.1.2 Handler小结</h3><ul>\n<li>可以看到，Handler使用起来还是非常方便的。Handler异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），thread(子线程)<br>运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。</li>\n</ul>\n<h2 id=\"2-2-AsyncTask\"><a href=\"#2-2-AsyncTask\" class=\"headerlink\" title=\"2.2 AsyncTask\"></a>2.2 AsyncTask</h2><p>AsyncTask是Google推出的轻量级的异步处理工具，本质上就是一个封装了线程池和handler的异步框架，更加方便程序员调用。说到这里，肯定会有很多同学认为AsyncTask既然是对Handler的封装，那一定更好用吧！诶，先别急，他们的优缺点在介绍完他们俩之后再来总结。</p>\n<h3 id=\"2-2-1-AsyncTask的使用\"><a href=\"#2-2-1-AsyncTask的使用\" class=\"headerlink\" title=\"2.2.1 AsyncTask的使用\"></a>2.2.1 AsyncTask的使用</h3><ol>\n<li>创建一个类继承自AsyncTask</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Bitmap <span class=\"title function_\">doInBackground</span><span class=\"params\">(Integer... integers)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//做异步任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//异步任务完成后的操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启异步任务</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Concurrent_</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method_</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyTask</span> <span class=\"variable\">myTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyTask</span>();</span><br><span class=\"line\">        myTask.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，这样就完成了一个最基本的异步任务，好像真的比Handler要简单不少。<br>除了上面两个重载方法以外，AsyncTask还有两个很重要的重载方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Bitmap&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行异步任务之前，当然还处于主线程，可以操作UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Void... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用来更新进度条等操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AsyncTask功能非常强大，可以很轻松的实现一些异步任务的管理<br>他的三个泛型参数AsyncTask&lt;Integer, Void, Bitmap&gt;代表的含义分别是：</p>\n<ul>\n<li>Void：表示在执行AsyncTask的时候不需要传入参数给后台任务</li>\n<li>Integer：表示使用整型数据来作为进度显示单位</li>\n<li>Bitmap：表示使用Bitmap位图来反馈执行结果</li>\n</ul>\n<p>下面是一个使用AsyncTask实现模拟下载功能的一个程序Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AsyncTask_</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//在一步开始之前，在主线程，可操作UI，一般用来做准备工作</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPreExecute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPreExecute();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;开始模拟下载&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异步线程中执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Boolean <span class=\"title function_\">doInBackground</span><span class=\"params\">(Void... voids)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//模拟网络延迟</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p = 1 / 0;//模拟下载失败</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                p += <span class=\"number\">10</span>;</span><br><span class=\"line\">                publishProgress(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//通知主线程当前执行的进度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到了主线程，可以根据publishProgress()传递过来的参数进行进度更改</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressUpdate</span><span class=\"params\">(Integer... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onProgressUpdate(values);</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;正在下载：&quot;</span> + values[<span class=\"number\">0</span>] + <span class=\"string\">&quot;%&quot;</span>);</span><br><span class=\"line\">        binding.pb.setProgress(values[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//切换到主线程</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPostExecute</span><span class=\"params\">(Boolean b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onPostExecute(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">            Toast.makeText(context, <span class=\"string\">&quot;下载完成！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> Toast.makeText(context, <span class=\"string\">&quot;下载失败！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-AsyncTask小结\"><a href=\"#2-2-2-AsyncTask小结\" class=\"headerlink\" title=\"2.2.2 AsyncTask小结\"></a>2.2.2 AsyncTask小结</h3><ul>\n<li>不难发现，对比Handler的话，AsyncTask的过程更加透明，并且结果更易于管理。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li><p>Handler</p>\n<ul>\n<li>优点<ul>\n<li>结构清晰，功能定义明确</li>\n<li>对于多个后台任务时，更加简单，根据msg.what进行判断即可</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在单个后台异步处理时，显得代码过多，结构过于复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AsyncTask</p>\n<ul>\n<li>优点<ul>\n<li>对于单个任务是，更加简单，快捷</li>\n<li>操作过程更加清晰明确，过程可控</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在使用多个异步操作的同时，共同进行Ui变更时，就变得复杂起来</li>\n<li>最大并发数不超过5</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>看完了优缺点分析，相信以后在选择使用哪个进行异步任务处理的时候，不会再犹豫不决了吧。</p>\n</li>\n</ul>\n"},{"title":"初识 Jetpack","date":"2023-05-12T00:00:00.000Z","description":"初步了解Jetpack的概念和目标，并介绍LiveCycle、LiveData和ViewModel组件。","cover":"https://www.helloimg.com/images/2023/05/12/oxIXog.jpg","_content":"\n> Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳实践、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者可将精力集中于真正重要的编码工作。\n\n# 一、Jetpack 的概念和目标\n\n## 1.1 概念\n\n- Jetpack是一个由Google官方推出的Android应用程序开发工具包。\n- 举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。\n- 通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。\n\n## 1.2 目标\n\n- 旨在提供一系列库和工具，帮助开发者`更快`、`更简便`地构建`高质量`的Android应用程序。\n\n# 二、Jetpack 的诞生和发展\n\n## 2.1 诞生\n\n- Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的\"引擎\"或\"助推器\"的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。\n- 最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIHzc.png\" width=\"30%\">\n\n## 2.2 发展\n\n- 当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。\n- 随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。\n- 2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。\n- 2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。\n- 总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。\n\n\n# 三、Jetpack 的运用\n\n- 说明：\n  1. 由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。\n  2. 为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用`Kotlin`。\n\n## 3.1 LiveCycle\n\n- Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。\n- 作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。\n- Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。\n\n下面是代码示例：\n\n```kotlin\nimport androidx.lifecycle.LifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.OnLifecycleEvent\n\nclass MyLifecycleObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate(owner: LifecycleOwner) {\n        // 执行 onCreate 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart(owner: LifecycleOwner) {\n        // 执行 onStart 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume(owner: LifecycleOwner) {\n        // 执行 onResume 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause(owner: LifecycleOwner) {\n        // 执行 onPause 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onStop(owner: LifecycleOwner) {\n        // 执行 onStop 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy(owner: LifecycleOwner) {\n        // 执行 onDestroy 事件\n    }\n}\n```\n- 上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。\n- 下面演示如何使用：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private lateinit var myObserver: MyLifecycleObserver\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 创建 MyLifecycleObserver 实例\n        myObserver = MyLifecycleObserver()\n        \n        // 将 myObserver 添加到 Activity 的生命周期观察者列表中\n        lifecycle.addObserver(myObserver)\n    }\n}\n```\n- 在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：\n\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    //从观察者列表中移除\n    lifecycle.removeObserver(myObserver)\n}\n```\n\n- 如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。\n\n## 3.2 LiveData 和 ViewModel\n\n- 由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。\n- LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。\n- ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n- 在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为`旋转手机、配置更改（如切换语言）、资源内存不足`等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。\n下面演示一下横屏导致数据丢失的情况：\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIfwn.gif\" width=\"30%\">\n\n- 下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。\n\n1. 先自定义一个继承自 ViewModel 的 DataBindingViewModel 类\n```kotlin\n// 定义一个 MyViewModel 类，继承自 ViewModel\nclass MyViewModel : ViewModel() {\n  // 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字\n  var number: MutableLiveData<Int> = MutableLiveData()\n\n  // addOne 方法，用于将 number 自增 1\n  fun addOne() {\n    // 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0\n    number.value = (number.value ?: 0) + 1\n  }\n}\n```\n2. 在 Activity 中使用\n```kotlin\nclass ViewModelActivity : AppCompatActivity() {\n    // 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding\n    private lateinit var binding: ActivityViewModelBinding\n    // 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象\n    private val myViewModel: MyViewModel by viewModels()\n  \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象\n        binding = ActivityViewModelBinding.inflate(layoutInflater)\n        // 设置界面布局为 binding.root\n        setContentView(binding.root)\n    \n        // 观察 myViewModel 中的 number 属性的变化\n        myViewModel.number.observe(this, Observer {\n          // 将 number 的值显示在 textView 上\n          binding.textView.text = myViewModel.number.value.toString()\n        })\n    \n        // 给 button 的点击事件添加监听器\n        binding.button.setOnClickListener {\n          // 在 myViewModel 中执行 addOne 函数\n          myViewModel.addOne()\n        }\n    }\n}\n```\n3. 实现效果\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/ox6Pwr.gif\" width=\"30%\">\n\n- 上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。\n- 总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。\n\n# 四、总结\n\n- 由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定...或许接触新知识的最大的乐趣就在于此吧。\n- 这两天使用 kotlin 进行编码，也让我对 Kotlin 语法'太甜了'的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。","source":"_posts/安卓_03_初识Jetpack.md","raw":"---\ntitle: '初识 Jetpack'\ndate: '2023-05-12'\ndescription: '初步了解Jetpack的概念和目标，并介绍LiveCycle、LiveData和ViewModel组件。'\ncover: 'https://www.helloimg.com/images/2023/05/12/oxIXog.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n> Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳实践、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者可将精力集中于真正重要的编码工作。\n\n# 一、Jetpack 的概念和目标\n\n## 1.1 概念\n\n- Jetpack是一个由Google官方推出的Android应用程序开发工具包。\n- 举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。\n- 通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。\n\n## 1.2 目标\n\n- 旨在提供一系列库和工具，帮助开发者`更快`、`更简便`地构建`高质量`的Android应用程序。\n\n# 二、Jetpack 的诞生和发展\n\n## 2.1 诞生\n\n- Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的\"引擎\"或\"助推器\"的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。\n- 最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIHzc.png\" width=\"30%\">\n\n## 2.2 发展\n\n- 当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。\n- 随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。\n- 2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。\n- 2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。\n- 总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。\n\n\n# 三、Jetpack 的运用\n\n- 说明：\n  1. 由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。\n  2. 为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用`Kotlin`。\n\n## 3.1 LiveCycle\n\n- Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。\n- 作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。\n- Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。\n\n下面是代码示例：\n\n```kotlin\nimport androidx.lifecycle.LifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.OnLifecycleEvent\n\nclass MyLifecycleObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate(owner: LifecycleOwner) {\n        // 执行 onCreate 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart(owner: LifecycleOwner) {\n        // 执行 onStart 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume(owner: LifecycleOwner) {\n        // 执行 onResume 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause(owner: LifecycleOwner) {\n        // 执行 onPause 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onStop(owner: LifecycleOwner) {\n        // 执行 onStop 事件\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy(owner: LifecycleOwner) {\n        // 执行 onDestroy 事件\n    }\n}\n```\n- 上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。\n- 下面演示如何使用：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private lateinit var myObserver: MyLifecycleObserver\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 创建 MyLifecycleObserver 实例\n        myObserver = MyLifecycleObserver()\n        \n        // 将 myObserver 添加到 Activity 的生命周期观察者列表中\n        lifecycle.addObserver(myObserver)\n    }\n}\n```\n- 在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：\n\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    //从观察者列表中移除\n    lifecycle.removeObserver(myObserver)\n}\n```\n\n- 如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。\n\n## 3.2 LiveData 和 ViewModel\n\n- 由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。\n- LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。\n- ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n- 在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为`旋转手机、配置更改（如切换语言）、资源内存不足`等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。\n下面演示一下横屏导致数据丢失的情况：\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIfwn.gif\" width=\"30%\">\n\n- 下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。\n\n1. 先自定义一个继承自 ViewModel 的 DataBindingViewModel 类\n```kotlin\n// 定义一个 MyViewModel 类，继承自 ViewModel\nclass MyViewModel : ViewModel() {\n  // 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字\n  var number: MutableLiveData<Int> = MutableLiveData()\n\n  // addOne 方法，用于将 number 自增 1\n  fun addOne() {\n    // 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0\n    number.value = (number.value ?: 0) + 1\n  }\n}\n```\n2. 在 Activity 中使用\n```kotlin\nclass ViewModelActivity : AppCompatActivity() {\n    // 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding\n    private lateinit var binding: ActivityViewModelBinding\n    // 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象\n    private val myViewModel: MyViewModel by viewModels()\n  \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象\n        binding = ActivityViewModelBinding.inflate(layoutInflater)\n        // 设置界面布局为 binding.root\n        setContentView(binding.root)\n    \n        // 观察 myViewModel 中的 number 属性的变化\n        myViewModel.number.observe(this, Observer {\n          // 将 number 的值显示在 textView 上\n          binding.textView.text = myViewModel.number.value.toString()\n        })\n    \n        // 给 button 的点击事件添加监听器\n        binding.button.setOnClickListener {\n          // 在 myViewModel 中执行 addOne 函数\n          myViewModel.addOne()\n        }\n    }\n}\n```\n3. 实现效果\n\n<img src=\"https://www.helloimg.com/images/2023/05/12/ox6Pwr.gif\" width=\"30%\">\n\n- 上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。\n- 总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。\n\n# 四、总结\n\n- 由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定...或许接触新知识的最大的乐趣就在于此吧。\n- 这两天使用 kotlin 进行编码，也让我对 Kotlin 语法'太甜了'的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。","slug":"安卓_03_初识Jetpack","published":1,"updated":"2023-07-20T01:17:44.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyu8000qm7hogbalazqo","content":"<blockquote>\n<p>Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳实践、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者可将精力集中于真正重要的编码工作。</p>\n</blockquote>\n<h1 id=\"一、Jetpack-的概念和目标\"><a href=\"#一、Jetpack-的概念和目标\" class=\"headerlink\" title=\"一、Jetpack 的概念和目标\"></a>一、Jetpack 的概念和目标</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack是一个由Google官方推出的Android应用程序开发工具包。</li>\n<li>举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。</li>\n<li>通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。</li>\n</ul>\n<h2 id=\"1-2-目标\"><a href=\"#1-2-目标\" class=\"headerlink\" title=\"1.2 目标\"></a>1.2 目标</h2><ul>\n<li>旨在提供一系列库和工具，帮助开发者<code>更快</code>、<code>更简便</code>地构建<code>高质量</code>的Android应用程序。</li>\n</ul>\n<h1 id=\"二、Jetpack-的诞生和发展\"><a href=\"#二、Jetpack-的诞生和发展\" class=\"headerlink\" title=\"二、Jetpack 的诞生和发展\"></a>二、Jetpack 的诞生和发展</h1><h2 id=\"2-1-诞生\"><a href=\"#2-1-诞生\" class=\"headerlink\" title=\"2.1 诞生\"></a>2.1 诞生</h2><ul>\n<li>Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的”引擎”或”助推器”的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。</li>\n<li>最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIHzc.png\" width=\"30%\">\n\n<h2 id=\"2-2-发展\"><a href=\"#2-2-发展\" class=\"headerlink\" title=\"2.2 发展\"></a>2.2 发展</h2><ul>\n<li>当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。</li>\n<li>随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。</li>\n<li>2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。</li>\n<li>2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。</li>\n<li>总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。</li>\n</ul>\n<h1 id=\"三、Jetpack-的运用\"><a href=\"#三、Jetpack-的运用\" class=\"headerlink\" title=\"三、Jetpack 的运用\"></a>三、Jetpack 的运用</h1><ul>\n<li>说明：<ol>\n<li>由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。</li>\n<li>为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用<code>Kotlin</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-1-LiveCycle\"><a href=\"#3-1-LiveCycle\" class=\"headerlink\" title=\"3.1 LiveCycle\"></a>3.1 LiveCycle</h2><ul>\n<li>Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。</li>\n<li>作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。</li>\n<li>Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleOwner</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.OnLifecycleEvent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLifecycleObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onCreate 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStart 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onResume 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onPause 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStop 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onDestroy 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。</li>\n<li>下面演示如何使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> myObserver: MyLifecycleObserver</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建 MyLifecycleObserver 实例</span></span><br><span class=\"line\">        myObserver = MyLifecycleObserver()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将 myObserver 添加到 Activity 的生命周期观察者列表中</span></span><br><span class=\"line\">        lifecycle.addObserver(myObserver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">    <span class=\"comment\">//从观察者列表中移除</span></span><br><span class=\"line\">    lifecycle.removeObserver(myObserver)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。</li>\n</ul>\n<h2 id=\"3-2-LiveData-和-ViewModel\"><a href=\"#3-2-LiveData-和-ViewModel\" class=\"headerlink\" title=\"3.2 LiveData 和 ViewModel\"></a>3.2 LiveData 和 ViewModel</h2><ul>\n<li>由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。</li>\n<li>LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。</li>\n<li>ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n<li>在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为<code>旋转手机、配置更改（如切换语言）、资源内存不足</code>等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。<br>下面演示一下横屏导致数据丢失的情况：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIfwn.gif\" width=\"30%\">\n\n<ul>\n<li>下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。</li>\n</ul>\n<ol>\n<li>先自定义一个继承自 ViewModel 的 DataBindingViewModel 类<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个 MyViewModel 类，继承自 ViewModel</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> number: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// addOne 方法，用于将 number 自增 1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOne</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0</span></span><br><span class=\"line\">    number.value = (number.value ?: <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 Activity 中使用<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ViewModelActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityViewModelBinding</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> viewModels()</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">// 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象</span></span><br><span class=\"line\">        binding = ActivityViewModelBinding.inflate(layoutInflater)</span><br><span class=\"line\">        <span class=\"comment\">// 设置界面布局为 binding.root</span></span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 观察 myViewModel 中的 number 属性的变化</span></span><br><span class=\"line\">        myViewModel.number.observe(<span class=\"keyword\">this</span>, Observer &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 number 的值显示在 textView 上</span></span><br><span class=\"line\">          binding.textView.text = myViewModel.number.value.toString()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 给 button 的点击事件添加监听器</span></span><br><span class=\"line\">        binding.button.setOnClickListener &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在 myViewModel 中执行 addOne 函数</span></span><br><span class=\"line\">          myViewModel.addOne()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现效果</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/05/12/ox6Pwr.gif\" width=\"30%\">\n\n<ul>\n<li>上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。</li>\n<li>总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定…或许接触新知识的最大的乐趣就在于此吧。</li>\n<li>这两天使用 kotlin 进行编码，也让我对 Kotlin 语法’太甜了’的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳实践、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者可将精力集中于真正重要的编码工作。</p>\n</blockquote>\n<h1 id=\"一、Jetpack-的概念和目标\"><a href=\"#一、Jetpack-的概念和目标\" class=\"headerlink\" title=\"一、Jetpack 的概念和目标\"></a>一、Jetpack 的概念和目标</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack是一个由Google官方推出的Android应用程序开发工具包。</li>\n<li>举个通俗易懂的例子：Jetpack就像是一个庞大的工具箱，里面装满了各种适用于Android应用程序开发的工具。这些工具可以帮助开发者解决诸如生命周期管理、界面设计、数据库访问、数据绑定、通讯等各种常见问题，让开发者能够更专注于业务逻辑的编写，减少样板代码的编写和一般性问题的处理。</li>\n<li>通过Jetpack提供的各种组件和库，可以较为轻松地完成包括基本的Activity和Fragment开发，到Room Database、Data Binding、ViewModel、LiveData、WorkManager、Navigation等高级组件的开发，Jetpack是提高Android应用程序开发效率和质量的重要工具之一。</li>\n</ul>\n<h2 id=\"1-2-目标\"><a href=\"#1-2-目标\" class=\"headerlink\" title=\"1.2 目标\"></a>1.2 目标</h2><ul>\n<li>旨在提供一系列库和工具，帮助开发者<code>更快</code>、<code>更简便</code>地构建<code>高质量</code>的Android应用程序。</li>\n</ul>\n<h1 id=\"二、Jetpack-的诞生和发展\"><a href=\"#二、Jetpack-的诞生和发展\" class=\"headerlink\" title=\"二、Jetpack 的诞生和发展\"></a>二、Jetpack 的诞生和发展</h1><h2 id=\"2-1-诞生\"><a href=\"#2-1-诞生\" class=\"headerlink\" title=\"2.1 诞生\"></a>2.1 诞生</h2><ul>\n<li>Jetpack，本身这个单词的含义是喷气背包、喷气发动机组件。在2018年的Google I/O大会上，谷歌将其最新推出的开发工具包命名为Jetpack，也许是为了强调其在应用程序开发中的”引擎”或”助推器”的作用，同时也传递了一个信息：Jetpack可以帮助开发者更快地构建高质量的Android应用程序。Jetpack应该被视为一种可靠的、可扩展的、高效的开发工具，可以帮助开发者实现目标并推动应用程序向前发展。</li>\n<li>最初的 Jetpack 图标是一个背着喷气背包的 Android 机器人，可以说是非常形象生动了。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIHzc.png\" width=\"30%\">\n\n<h2 id=\"2-2-发展\"><a href=\"#2-2-发展\" class=\"headerlink\" title=\"2.2 发展\"></a>2.2 发展</h2><ul>\n<li>当Jetpack最初推出时，它只包含少量的库，比如Lifecycle和ViewModel等。这些库主要是为了帮助开发人员更轻松地编写高质量的应用程序，同时还可以在不同版本的Android操作系统之间保持一致性。</li>\n<li>随着时间的推移，Jetpack逐渐得到了扩展和完善。目前，Jetpack已经成长为一个包含多个库和工具的全面开发平台，其中包括：Room、WorkManager、Navigation、Paging、Data Binding等，涵盖了众多常见的开发需求和场景。</li>\n<li>2019年，Google宣布Jetpack Compose库，这是一种基于Kotlin语言的声明式UI开发工具，旨在通过简化UI组件的创建和交互，改进应用程序开发的速度和质量。</li>\n<li>2021年，还推出了Jetpack Compose for Web和Jetpack Compose for Desktop，这些新领域的Compose库进一步拓展了Jetpack的应用范围，让开发者可以更轻松地构建跨平台的应用程序。</li>\n<li>总的来说，Jetpack作为谷歌为Android应用程序开发者提供的全面工具包和平台，不断发展，不断更新，为开发者提供了更多便利和效率，也促进了Android生态系统的健康发展。</li>\n</ul>\n<h1 id=\"三、Jetpack-的运用\"><a href=\"#三、Jetpack-的运用\" class=\"headerlink\" title=\"三、Jetpack 的运用\"></a>三、Jetpack 的运用</h1><ul>\n<li>说明：<ol>\n<li>由于我也是初步接触到 Jetpack，所以对很多组件的认知有限。因此，今天就我目前接触到的一些组件做一些学习分享，可能会有错误的地方，多多担待。</li>\n<li>为了与较新的技术接轨，同时提高自己的 kotlin 编码能力，所以后续涉及到 Jetpack 的内容（包括后续的博客），编程语言都会使用<code>Kotlin</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-1-LiveCycle\"><a href=\"#3-1-LiveCycle\" class=\"headerlink\" title=\"3.1 LiveCycle\"></a>3.1 LiveCycle</h2><ul>\n<li>Lifecycle 这个词的含义就是生命周期，在各种各样的开发中，生命周期这个词出现的频率非常之高。在安卓开发领域，Activity 和 Fragment 等组件的生命周期管理可能是开发者每天都要接触到的事。</li>\n<li>作为 Jetpack 库中的一个组件，Lifecycle 主要用于管理Activity和Fragment等组件的生命周期。通过使用Lifecycle组件，开发者可以更方便地编写响应生命周期事件的代码，避免内存泄漏、资源浪费等问题。</li>\n<li>Lifecycle 组件提供了一个LifecycleOwner接口和一个LifecycleObserver接口，分别表示具有生命周期的组件和观察者，开发者可以通过实现这些接口来实现对组件的生命周期管理。</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.LifecycleOwner</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.OnLifecycleEvent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLifecycleObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onCreate 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStart 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onResume 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onPause 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onStop 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 onDestroy 事件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述代码创建了一个创建了一个名为MyLifecycleObserver的类，并实现了LifecycleObserver接口。该类提供了一些方法，用于响应不同的生命周期事件。在每个方法上，我们使用@OnLifecycleEvent注解标记要响应的事件类型，并在方法体中编写对应的业务逻辑。</li>\n<li>下面演示如何使用：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> myObserver: MyLifecycleObserver</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建 MyLifecycleObserver 实例</span></span><br><span class=\"line\">        myObserver = MyLifecycleObserver()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将 myObserver 添加到 Activity 的生命周期观察者列表中</span></span><br><span class=\"line\">        lifecycle.addObserver(myObserver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在不需要时，将MyLifecycleObserver实例从Activity的生命周期观察者列表中移除。如下代码所示：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">    <span class=\"comment\">//从观察者列表中移除</span></span><br><span class=\"line\">    lifecycle.removeObserver(myObserver)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如此一来，开发者可以更容易地管理和响应组件生命周期事件，减少代码的冗余和复杂性。</li>\n</ul>\n<h2 id=\"3-2-LiveData-和-ViewModel\"><a href=\"#3-2-LiveData-和-ViewModel\" class=\"headerlink\" title=\"3.2 LiveData 和 ViewModel\"></a>3.2 LiveData 和 ViewModel</h2><ul>\n<li>由于 LiveData 和 ViewModel 在一般情况下都是一起使用，因此这里将他们放在一起讲解。</li>\n<li>LiveData 的作用主要是将数据从 ViewModel 传递到相应的 View 上，并保证这种数据传递的安全性和正确性。是一种可观察的数据持有类，它可以感知生命周期并在数据变化时通知观察者。</li>\n<li>ViewModel 是 MVVM 架构中的一部分，用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n<li>在 Android 中，每个 Activity 或 Fragment 都有其自己的生命周期，当这些 UI 组件因为<code>旋转手机、配置更改（如切换语言）、资源内存不足</code>等原因被销毁并重新创建时，会导致其中包含的数据丢失，从而影响用户体验。而 ViewModel 的引入，则可以帮助我们在这些 UI 组件被销毁重建时，保持其中的数据状态不变。<br>下面演示一下横屏导致数据丢失的情况：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/12/oxIfwn.gif\" width=\"30%\">\n\n<ul>\n<li>下面展示如何使用 ViewModel 和 LiveData 技术来实现数据的绑定和更新。</li>\n</ul>\n<ol>\n<li>先自定义一个继承自 ViewModel 的 DataBindingViewModel 类<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个 MyViewModel 类，继承自 ViewModel</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义一个 MutableLiveData 类型的 number 变量，用于存储需要展示到 UI 上的数字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> number: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// addOne 方法，用于将 number 自增 1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOne</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 Elvis 运算符获取 number 当前的值，如果为 null 则默认为 0</span></span><br><span class=\"line\">    number.value = (number.value ?: <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 Activity 中使用<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ViewModelActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个 lateinit 的属性 binding，类型为 ActivityViewModelBinding</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityViewModelBinding</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个属性 myViewModel，使用了 viewModels() 函数来创建 MyViewModel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> viewModels()</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">// 使用 ActivityViewModelBinding 类中的 inflate 函数来创建 binding 对象</span></span><br><span class=\"line\">        binding = ActivityViewModelBinding.inflate(layoutInflater)</span><br><span class=\"line\">        <span class=\"comment\">// 设置界面布局为 binding.root</span></span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 观察 myViewModel 中的 number 属性的变化</span></span><br><span class=\"line\">        myViewModel.number.observe(<span class=\"keyword\">this</span>, Observer &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 number 的值显示在 textView 上</span></span><br><span class=\"line\">          binding.textView.text = myViewModel.number.value.toString()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 给 button 的点击事件添加监听器</span></span><br><span class=\"line\">        binding.button.setOnClickListener &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在 myViewModel 中执行 addOne 函数</span></span><br><span class=\"line\">          myViewModel.addOne()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现效果</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/05/12/ox6Pwr.gif\" width=\"30%\">\n\n<ul>\n<li>上述示例中，我们使用了 LiveData 和 ViewModel 这两个组件来实现 Activity 销毁并重建时数据不会丢失的功能。</li>\n<li>总的来说，LiveData 和 ViewModel 是 Android Jetpack 组件库中非常重要的两个组件，它们能够帮助我们实现应用程序中大量的业务逻辑和提高应用程序性能，并且它们的生命周期与其关联的组件相对应，能够更好地处理组件销毁等情况，从而避免数据丢失或内存泄漏等问题。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>由于目前只接触到这几个组件，先分享到这里，体验下来的感觉可以说非常奇妙。原来数据还能这样更新，原来视图还能这样绑定…或许接触新知识的最大的乐趣就在于此吧。</li>\n<li>这两天使用 kotlin 进行编码，也让我对 Kotlin 语法’太甜了’的感觉有所改善，确实在某些时候能感觉到这门语言的便利之处，希望在后续学习中能见识到这门语言更强大的地方。</li>\n</ul>\n"},{"title":"OrmLite 框架的简单使用","date":"2023-04-19T00:00:00.000Z","description":"介绍如何使用OrmLite框架对SQLite数据库进行管理","cover":"https://www.helloimg.com/images/2023/07/19/oA2z41.webp","_content":"\n> OrmLite是一个轻量级的对象关系映射（ORM）框架，可帮助开发人员通过简单的Java对象来操作SQLite数据库，是使用Java进行移动端应用程序开发的理想选择。SQLite是一款自给自足的、无服务器的、零配置的SQL数据库引擎，它被广泛部署在世界各地的设备上，包括移动设备和桌面系统。\n> 在今天的博客中，我们将详细介绍如何使用OrmLite框架来操作SQLite数据库，包括如何创建和更新数据库表格，如何执行增删改查操作等。本教程旨在让读者了解OrmLite的基本概念和核心功能，帮助读者快速掌握使用OrmLite框架操作SQLite数据库的方法。\n<!--more-->\n\n# 一、OrmLite和SQLite简介\n\n## 1.1 ORM\n\n- 首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？\n  一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。\n    - 有过 MyBatis 经验的小伙伴对\"将映射关系定义为元数据（XML、注解等形式\"这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。\n    - 没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。\n\n  举个例子：\n    - 假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的\n      SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。\n    - 使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的\n      User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWVvE.gif\" width=\"30%\">\n\n## 1.2 OrmLite\n\nLite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。\n再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。\n\n- 具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。\n- 由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。\n- OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。\n- OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。\n\n## 1.3 SQLite\n\n- SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。\n- SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。\n- 无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。\n- 支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。\n- SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。\n- SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。\n\n# 二、OrmLite的使用\n\n概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。\n\n## 2.1 引入依赖\n\n- 由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：\n\n```groovy\ndependencies {\n    //...\n    //ormlite\n    implementation 'com.j256.ormlite:ormlite-core:4.48'\n    implementation 'com.j256.ormlite:ormlite-android:4.48'\n    //...\n}\n```\n\n## 2.2 定义数据模型类\n\n- 我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，\n\n```java\n\n@DatabaseTable(tableName = \"user\")\npublic class User {\n    //唯一身份识别\n    @DatabaseField(generatedId = true) // 自动生成的主键，主键可以省略canBeNull = false\n    private int id;\n\n    //姓名\n    @DatabaseField(columnName = \"name\", canBeNull = false)\n    private String name;\n\n    //年龄\n    @DatabaseField(columnName = \"age\", canBeNull = false)\n    private int age;\n\n    //性别\n    @DatabaseField(columnName = \"gender\", canBeNull = false)\n    private String gender;\n\n    public User() {\n    }\n\n    //其他构造器、getter和setter方法、toString等\n}\n```\n\n<font color=\"FF0000\"><br>重点来了（敲黑板!!）</font>\n首先解释一下这段代码：**使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。**\n\n1. 注解解释：\n    1. @DatabaseTable(tableName = \"user\")\n       该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。\n    2. @DatabaseField(generatedId = true)\n       该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。\n    3. @DatabaseField(columnName = \"name\", canBeNull = false)\n       该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。\n2. 注意事项：\n    1. 无参构造必须存在\n       有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？  \n       Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的**无参构造**方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。\n\n## 2.3 创建工具类\n\n### 2.3.1 数据库管理工具类\n\n为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：\n\n```java\npublic class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n\n    // 数据库名称\n    private static final String DATABASE_NAME = \"db_demo.db\";\n\n    // 数据库版本号\n    private static final int DATABASE_VERSION = 1;\n\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            // 在这里创建表格\n            TableUtils.createTable(connectionSource, User.class);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            // 在这里升级表格\n            TableUtils.dropTable(connectionSource, User.class, true);\n            onCreate(db, connectionSource);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。\n通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。\n例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：\n\n```java\n        Dao<User, Integer> userDao=ormLiteUtils.getDao(User.class);\n        User user=new User(\"雷皓\",18,\"男\");\n        userDao.create(user);\n```\n\n在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。\n\n### 2.3.2 操作 DAO 对象的工具类\n\n为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：\n\n```java\npublic class OrmLiteUtils {\n\n    // 单例模式静态变量\n    private static OrmLiteUtils instance;\n    // DatabaseHelper 对象\n    private final DatabaseHelper databaseHelper;\n    // UserDao 对象\n    private Dao<User, Integer> userDao;\n\n    // 私有构造方法\n    private OrmLiteUtils(Context context) {\n        // 创建 DatabaseHelper 对象\n        databaseHelper = new DatabaseHelper(context);\n    }\n\n    // 获取实例对象（实现单例模式）\n    public static synchronized OrmLiteUtils getInstance(Context context) {\n        if (instance == null) instance = new OrmLiteUtils(context);\n\n        return instance;\n    }\n\n    // 获取 UserDao 对象\n    public synchronized Dao<User, Integer> getUserDao() throws SQLException, java.sql.SQLException {\n        if (userDao == null)\n            // 获取 Dao 对象\n            userDao = databaseHelper.getDao(User.class);\n\n        return userDao;\n    }\n}\n```\n\n该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO\n获取方法都是同步方法，防止多线程获取时出现冲突。\n\n在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。\n\n## 2.4 开始使用\n\n好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！\n接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。\n应用很简单，提供几个按钮，可以操作 user 表即可。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWhe9.jpg\" width=\"50%\">\n\n### 2.4.1 获取数据库访问对象\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    //数据库访问对象\n    private Dao<User, Integer> userDao;\n\n    /*...*/\n    private void initEvent() {\n        /*...*/\n        // 点击获取 Dao 对象\n        OrmLiteUtils ormLiteUtils = OrmLiteUtils.getInstance(context);\n        userDao = ormLiteUtils.getUserDao();\n        /*...*/\n    }\n}\n```\n\n### 2.4.2 插入操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //插入数据\n        binding.btnInsert.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = new User(name, Integer.parseInt(age), gender);\n            //插入用户\n            userDao.create(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n### 2.4.3 删除操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //删除数据\n        binding.btnDeleteById.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = userDao.queryForId(Integer.valueOf(id));\n            //删除用户\n            userDao.delete(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。\n接下来我们看看他给我们存到数据库里面的内容：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWjTX.png\"  width=\"50%\">\n\n没有任何问题！\n\n# 三、总结\n\n- 在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。\n- 除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。\n- 总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。","source":"_posts/安卓_02_OrmLite框架的简单使用.md","raw":"---\ntitle: 'OrmLite 框架的简单使用'\ndate: '2023-04-19'\ndescription: '介绍如何使用OrmLite框架对SQLite数据库进行管理'\ncover: 'https://www.helloimg.com/images/2023/07/19/oA2z41.webp'\ncategories:\n\n- 数据库\n\ntags:\n\n- Android\n- Java\n- 数据库\n- SQLite\n\n---\n\n> OrmLite是一个轻量级的对象关系映射（ORM）框架，可帮助开发人员通过简单的Java对象来操作SQLite数据库，是使用Java进行移动端应用程序开发的理想选择。SQLite是一款自给自足的、无服务器的、零配置的SQL数据库引擎，它被广泛部署在世界各地的设备上，包括移动设备和桌面系统。\n> 在今天的博客中，我们将详细介绍如何使用OrmLite框架来操作SQLite数据库，包括如何创建和更新数据库表格，如何执行增删改查操作等。本教程旨在让读者了解OrmLite的基本概念和核心功能，帮助读者快速掌握使用OrmLite框架操作SQLite数据库的方法。\n<!--more-->\n\n# 一、OrmLite和SQLite简介\n\n## 1.1 ORM\n\n- 首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？\n  一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。\n    - 有过 MyBatis 经验的小伙伴对\"将映射关系定义为元数据（XML、注解等形式\"这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。\n    - 没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。\n\n  举个例子：\n    - 假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的\n      SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。\n    - 使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的\n      User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWVvE.gif\" width=\"30%\">\n\n## 1.2 OrmLite\n\nLite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。\n再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。\n\n- 具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。\n- 由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。\n- OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。\n- OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。\n\n## 1.3 SQLite\n\n- SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。\n- SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。\n- 无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。\n- 支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。\n- SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。\n- SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。\n\n# 二、OrmLite的使用\n\n概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。\n\n## 2.1 引入依赖\n\n- 由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：\n\n```groovy\ndependencies {\n    //...\n    //ormlite\n    implementation 'com.j256.ormlite:ormlite-core:4.48'\n    implementation 'com.j256.ormlite:ormlite-android:4.48'\n    //...\n}\n```\n\n## 2.2 定义数据模型类\n\n- 我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，\n\n```java\n\n@DatabaseTable(tableName = \"user\")\npublic class User {\n    //唯一身份识别\n    @DatabaseField(generatedId = true) // 自动生成的主键，主键可以省略canBeNull = false\n    private int id;\n\n    //姓名\n    @DatabaseField(columnName = \"name\", canBeNull = false)\n    private String name;\n\n    //年龄\n    @DatabaseField(columnName = \"age\", canBeNull = false)\n    private int age;\n\n    //性别\n    @DatabaseField(columnName = \"gender\", canBeNull = false)\n    private String gender;\n\n    public User() {\n    }\n\n    //其他构造器、getter和setter方法、toString等\n}\n```\n\n<font color=\"FF0000\"><br>重点来了（敲黑板!!）</font>\n首先解释一下这段代码：**使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。**\n\n1. 注解解释：\n    1. @DatabaseTable(tableName = \"user\")\n       该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。\n    2. @DatabaseField(generatedId = true)\n       该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。\n    3. @DatabaseField(columnName = \"name\", canBeNull = false)\n       该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。\n2. 注意事项：\n    1. 无参构造必须存在\n       有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？  \n       Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的**无参构造**方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。\n\n## 2.3 创建工具类\n\n### 2.3.1 数据库管理工具类\n\n为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：\n\n```java\npublic class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n\n    // 数据库名称\n    private static final String DATABASE_NAME = \"db_demo.db\";\n\n    // 数据库版本号\n    private static final int DATABASE_VERSION = 1;\n\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            // 在这里创建表格\n            TableUtils.createTable(connectionSource, User.class);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            // 在这里升级表格\n            TableUtils.dropTable(connectionSource, User.class, true);\n            onCreate(db, connectionSource);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。\n通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。\n例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：\n\n```java\n        Dao<User, Integer> userDao=ormLiteUtils.getDao(User.class);\n        User user=new User(\"雷皓\",18,\"男\");\n        userDao.create(user);\n```\n\n在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。\n\n### 2.3.2 操作 DAO 对象的工具类\n\n为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：\n\n```java\npublic class OrmLiteUtils {\n\n    // 单例模式静态变量\n    private static OrmLiteUtils instance;\n    // DatabaseHelper 对象\n    private final DatabaseHelper databaseHelper;\n    // UserDao 对象\n    private Dao<User, Integer> userDao;\n\n    // 私有构造方法\n    private OrmLiteUtils(Context context) {\n        // 创建 DatabaseHelper 对象\n        databaseHelper = new DatabaseHelper(context);\n    }\n\n    // 获取实例对象（实现单例模式）\n    public static synchronized OrmLiteUtils getInstance(Context context) {\n        if (instance == null) instance = new OrmLiteUtils(context);\n\n        return instance;\n    }\n\n    // 获取 UserDao 对象\n    public synchronized Dao<User, Integer> getUserDao() throws SQLException, java.sql.SQLException {\n        if (userDao == null)\n            // 获取 Dao 对象\n            userDao = databaseHelper.getDao(User.class);\n\n        return userDao;\n    }\n}\n```\n\n该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO\n获取方法都是同步方法，防止多线程获取时出现冲突。\n\n在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。\n\n## 2.4 开始使用\n\n好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！\n接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。\n应用很简单，提供几个按钮，可以操作 user 表即可。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWhe9.jpg\" width=\"50%\">\n\n### 2.4.1 获取数据库访问对象\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    //数据库访问对象\n    private Dao<User, Integer> userDao;\n\n    /*...*/\n    private void initEvent() {\n        /*...*/\n        // 点击获取 Dao 对象\n        OrmLiteUtils ormLiteUtils = OrmLiteUtils.getInstance(context);\n        userDao = ormLiteUtils.getUserDao();\n        /*...*/\n    }\n}\n```\n\n### 2.4.2 插入操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //插入数据\n        binding.btnInsert.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = new User(name, Integer.parseInt(age), gender);\n            //插入用户\n            userDao.create(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n### 2.4.3 删除操作\n\n```java\npublic class SQLiteActivity extends AppCompatActivity {\n    private void initEvent() {\n        //删除数据\n        binding.btnDeleteById.setOnClickListener(view -> {\n            /* 其他操作 */\n            User user = userDao.queryForId(Integer.valueOf(id));\n            //删除用户\n            userDao.delete(user);\n            /* 其他操作 */\n        });\n    }\n}\n```\n\n这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。\n接下来我们看看他给我们存到数据库里面的内容：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWjTX.png\"  width=\"50%\">\n\n没有任何问题！\n\n# 三、总结\n\n- 在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。\n- 除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。\n- 总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。","slug":"安卓_02_OrmLite框架的简单使用","published":1,"updated":"2023-07-20T01:13:07.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyu9000um7hohmuq9q49","content":"<blockquote>\n<p>OrmLite是一个轻量级的对象关系映射（ORM）框架，可帮助开发人员通过简单的Java对象来操作SQLite数据库，是使用Java进行移动端应用程序开发的理想选择。SQLite是一款自给自足的、无服务器的、零配置的SQL数据库引擎，它被广泛部署在世界各地的设备上，包括移动设备和桌面系统。<br>在今天的博客中，我们将详细介绍如何使用OrmLite框架来操作SQLite数据库，包括如何创建和更新数据库表格，如何执行增删改查操作等。本教程旨在让读者了解OrmLite的基本概念和核心功能，帮助读者快速掌握使用OrmLite框架操作SQLite数据库的方法。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"一、OrmLite和SQLite简介\"><a href=\"#一、OrmLite和SQLite简介\" class=\"headerlink\" title=\"一、OrmLite和SQLite简介\"></a>一、OrmLite和SQLite简介</h1><h2 id=\"1-1-ORM\"><a href=\"#1-1-ORM\" class=\"headerlink\" title=\"1.1 ORM\"></a>1.1 ORM</h2><ul>\n<li><p>首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？<br>一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。</p>\n<ul>\n<li>有过 MyBatis 经验的小伙伴对”将映射关系定义为元数据（XML、注解等形式”这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。</li>\n<li>没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。</li>\n</ul>\n<p>举个例子：</p>\n<ul>\n<li>假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的<br>SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。</li>\n<li>使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的<br>User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWVvE.gif\" width=\"30%\">\n\n<h2 id=\"1-2-OrmLite\"><a href=\"#1-2-OrmLite\" class=\"headerlink\" title=\"1.2 OrmLite\"></a>1.2 OrmLite</h2><p>Lite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。<br>再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。</p>\n<ul>\n<li>具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。</li>\n<li>由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。</li>\n<li>OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。</li>\n<li>OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。</li>\n</ul>\n<h2 id=\"1-3-SQLite\"><a href=\"#1-3-SQLite\" class=\"headerlink\" title=\"1.3 SQLite\"></a>1.3 SQLite</h2><ul>\n<li>SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。</li>\n<li>SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。</li>\n<li>无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。</li>\n<li>支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。</li>\n<li>SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。</li>\n<li>SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。</li>\n</ul>\n<h1 id=\"二、OrmLite的使用\"><a href=\"#二、OrmLite的使用\" class=\"headerlink\" title=\"二、OrmLite的使用\"></a>二、OrmLite的使用</h1><p>概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。</p>\n<h2 id=\"2-1-引入依赖\"><a href=\"#2-1-引入依赖\" class=\"headerlink\" title=\"2.1 引入依赖\"></a>2.1 引入依赖</h2><ul>\n<li>由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//ormlite</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-core:4.48&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-android:4.48&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-定义数据模型类\"><a href=\"#2-2-定义数据模型类\" class=\"headerlink\" title=\"2.2 定义数据模型类\"></a>2.2 定义数据模型类</h2><ul>\n<li>我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DatabaseTable(tableName = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一身份识别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(generatedId = true)</span> <span class=\"comment\">// 自动生成的主键，主键可以省略canBeNull = false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;name&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;age&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;gender&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他构造器、getter和setter方法、toString等</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"FF0000\"><br>重点来了（敲黑板!!）</font><br>首先解释一下这段代码：<strong>使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。</strong></p>\n<ol>\n<li>注解解释：<ol>\n<li>@DatabaseTable(tableName = “user”)<br>该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。</li>\n<li>@DatabaseField(generatedId = true)<br>该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。</li>\n<li>@DatabaseField(columnName = “name”, canBeNull = false)<br>该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。</li>\n</ol>\n</li>\n<li>注意事项：<ol>\n<li>无参构造必须存在<br>有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？<br>Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的<strong>无参构造</strong>方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-3-创建工具类\"><a href=\"#2-3-创建工具类\" class=\"headerlink\" title=\"2.3 创建工具类\"></a>2.3 创建工具类</h2><h3 id=\"2-3-1-数据库管理工具类\"><a href=\"#2-3-1-数据库管理工具类\" class=\"headerlink\" title=\"2.3.1 数据库管理工具类\"></a>2.3.1 数据库管理工具类</h3><p>为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OrmLiteSqliteOpenHelper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DATABASE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;db_demo.db&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DATABASE_VERSION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DatabaseHelper</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, DATABASE_NAME, <span class=\"literal\">null</span>, DATABASE_VERSION);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里创建表格</span></span><br><span class=\"line\">            TableUtils.createTable(connectionSource, User.class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里升级表格</span></span><br><span class=\"line\">            TableUtils.dropTable(connectionSource, User.class, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            onCreate(db, connectionSource);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。<br>通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。<br>例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao&lt;User, Integer&gt; userDao=ormLiteUtils.getDao(User.class);</span><br><span class=\"line\">User user=<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;雷皓&quot;</span>,<span class=\"number\">18</span>,<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">userDao.create(user);</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。</p>\n<h3 id=\"2-3-2-操作-DAO-对象的工具类\"><a href=\"#2-3-2-操作-DAO-对象的工具类\" class=\"headerlink\" title=\"2.3.2 操作 DAO 对象的工具类\"></a>2.3.2 操作 DAO 对象的工具类</h3><p>为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrmLiteUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例模式静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OrmLiteUtils instance;</span><br><span class=\"line\">    <span class=\"comment\">// DatabaseHelper 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DatabaseHelper databaseHelper;</span><br><span class=\"line\">    <span class=\"comment\">// UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">OrmLiteUtils</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 DatabaseHelper 对象</span></span><br><span class=\"line\">        databaseHelper = <span class=\"keyword\">new</span> <span class=\"title class_\">DatabaseHelper</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取实例对象（实现单例模式）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> OrmLiteUtils <span class=\"title function_\">getInstance</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) instance = <span class=\"keyword\">new</span> <span class=\"title class_\">OrmLiteUtils</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Dao&lt;User, Integer&gt; <span class=\"title function_\">getUserDao</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException, java.sql.SQLException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userDao == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 获取 Dao 对象</span></span><br><span class=\"line\">            userDao = databaseHelper.getDao(User.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO<br>获取方法都是同步方法，防止多线程获取时出现冲突。</p>\n<p>在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。</p>\n<h2 id=\"2-4-开始使用\"><a href=\"#2-4-开始使用\" class=\"headerlink\" title=\"2.4 开始使用\"></a>2.4 开始使用</h2><p>好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！<br>接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。<br>应用很简单，提供几个按钮，可以操作 user 表即可。</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWhe9.jpg\" width=\"50%\">\n\n<h3 id=\"2-4-1-获取数据库访问对象\"><a href=\"#2-4-1-获取数据库访问对象\" class=\"headerlink\" title=\"2.4.1 获取数据库访问对象\"></a>2.4.1 获取数据库访问对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数据库访问对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        <span class=\"comment\">// 点击获取 Dao 对象</span></span><br><span class=\"line\">        <span class=\"type\">OrmLiteUtils</span> <span class=\"variable\">ormLiteUtils</span> <span class=\"operator\">=</span> OrmLiteUtils.getInstance(context);</span><br><span class=\"line\">        userDao = ormLiteUtils.getUserDao();</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-插入操作\"><a href=\"#2-4-2-插入操作\" class=\"headerlink\" title=\"2.4.2 插入操作\"></a>2.4.2 插入操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入数据</span></span><br><span class=\"line\">        binding.btnInsert.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(name, Integer.parseInt(age), gender);</span><br><span class=\"line\">            <span class=\"comment\">//插入用户</span></span><br><span class=\"line\">            userDao.create(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-3-删除操作\"><a href=\"#2-4-3-删除操作\" class=\"headerlink\" title=\"2.4.3 删除操作\"></a>2.4.3 删除操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//删除数据</span></span><br><span class=\"line\">        binding.btnDeleteById.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userDao.queryForId(Integer.valueOf(id));</span><br><span class=\"line\">            <span class=\"comment\">//删除用户</span></span><br><span class=\"line\">            userDao.delete(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。<br>接下来我们看看他给我们存到数据库里面的内容：</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWjTX.png\"  width=\"50%\">\n\n<p>没有任何问题！</p>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。</li>\n<li>除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。</li>\n<li>总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"<blockquote>\n<p>OrmLite是一个轻量级的对象关系映射（ORM）框架，可帮助开发人员通过简单的Java对象来操作SQLite数据库，是使用Java进行移动端应用程序开发的理想选择。SQLite是一款自给自足的、无服务器的、零配置的SQL数据库引擎，它被广泛部署在世界各地的设备上，包括移动设备和桌面系统。<br>在今天的博客中，我们将详细介绍如何使用OrmLite框架来操作SQLite数据库，包括如何创建和更新数据库表格，如何执行增删改查操作等。本教程旨在让读者了解OrmLite的基本概念和核心功能，帮助读者快速掌握使用OrmLite框架操作SQLite数据库的方法。</p>\n</blockquote>","more":"<h1 id=\"一、OrmLite和SQLite简介\"><a href=\"#一、OrmLite和SQLite简介\" class=\"headerlink\" title=\"一、OrmLite和SQLite简介\"></a>一、OrmLite和SQLite简介</h1><h2 id=\"1-1-ORM\"><a href=\"#1-1-ORM\" class=\"headerlink\" title=\"1.1 ORM\"></a>1.1 ORM</h2><ul>\n<li><p>首先我们需要了解一个概念，什么是 ORM（Object Relational Mapping，对象关系映射）？<br>一种编程技术或工具，它可以将面向对象的编程语言中的对象和关系型数据库中的数据表之间的映射关系定义为元数据（XML、注解等形式），并且能够在程序运行时自动地将对象转化为关系型数据，或者将关系型数据转换为对象，以此来实现程序员所需的数据访问。</p>\n<ul>\n<li>有过 MyBatis 经验的小伙伴对”将映射关系定义为元数据（XML、注解等形式”这种表述肯定不会陌生，在 MyBatis 中就是通过XML映射文件或注解的方式将 SQL 语句和 Java 对象进行映射。</li>\n<li>没有相关开发经验也没有关系，通俗的说，ORM 就是一种工具或框架，它将数据库中的表和数据都映射成我们代码中的对象和属性，从而使我们能够像操作实例对象一样去操作数据库。</li>\n</ul>\n<p>举个例子：</p>\n<ul>\n<li>假设我们有一个 User 表，其中包括 id、name 和 age 三个字段。如果不使用 ORM，我们需要先使用 SQL 语句查询数据库，然后将查询结果手动转换成 Java 对象，再进行业务操作。这样做的话，我们需要写很多繁琐的<br>SQL 语句，而且还需要手动将查询结果转换成 Java 对象，挺麻烦的。</li>\n<li>使用 ORM 后，我们只需要定义一个 User 类，通过一些注解或者配置文件告诉 ORM 框架 User 类与数据库中的哪个表相对应，以及每个属性对应表中的哪个字段，ORM 框架就可以自动的将 User 对象和数据库中的<br>User 表进行映射。这样我们就可以像操作普通的 Java 对象一样去操作数据库了，不需要写复杂的 SQL 语句，也不需要手动进行数据转换。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWVvE.gif\" width=\"30%\">\n\n<h2 id=\"1-2-OrmLite\"><a href=\"#1-2-OrmLite\" class=\"headerlink\" title=\"1.2 OrmLite\"></a>1.2 OrmLite</h2><p>Lite 我们都知道，是精简、轻量的意思，像手机或者软件就会有 lite 版，表示青春版或者精简版的意思。所以 OrmLite 这个直接看名字就能知道，是一个轻量级的 ORM 框架。<br>再比如本章后面要说的 SQLite，看名字就能知道就是一个轻量级的数据库。</p>\n<ul>\n<li>具体来说，OrmLite 是一个基于 Java 的轻量级 ORM 框架。它提供了对 SQLite、MySQL、PostgreSQL、SQLServer 等数据库的访问支持。</li>\n<li>由于轻量级的设计，他非常适合嵌入式设备和移动应用程序等场景。</li>\n<li>OrmLite 提供了一个简单易用的 API，以及一些可以方便地配置、自定义和扩展的工具类和接口。</li>\n<li>OrmLite 的查询性能很高，在大量数据查询时具有优势。此外，它还支持事务处理和存储过程，可以在数据库中执行复杂操作。</li>\n</ul>\n<h2 id=\"1-3-SQLite\"><a href=\"#1-3-SQLite\" class=\"headerlink\" title=\"1.3 SQLite\"></a>1.3 SQLite</h2><ul>\n<li>SQLite 是一种轻量级的嵌入式关系型数据库，被广泛应用于各种平台和应用程序中，包括移动设备、桌面应用、Web 应用等。</li>\n<li>SQLite 的代码量非常小，可靠性高，而且它不需要一个单独的服务器进程或操作系统访问数据库，因此它非常适合于嵌入式设备、移动设备以及桌面应用。</li>\n<li>无类型、支持多数标准数据类型：SQLite 采用无类型的数据模型，因此它可以支持多种标准数据类型，包括 INTEGER、REAL、BLOB 和 TEXT 类型数据。</li>\n<li>支持 ACID 事务：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，使开发人员可以方便地编写安全可靠的应用程序。</li>\n<li>SQLite 可以在多种平台上运行，包括 Windows、Linux、Mac OS X、Android 等，我们这里就着重讲在 Android 平台的运用。</li>\n<li>SQLite 非常易于学习和使用，它提供了非常简单的 SQL 语法，同时还提供了大量的 API 接口，可以轻松地进行各种数据操作。</li>\n</ul>\n<h1 id=\"二、OrmLite的使用\"><a href=\"#二、OrmLite的使用\" class=\"headerlink\" title=\"二、OrmLite的使用\"></a>二、OrmLite的使用</h1><p>概念说多了没有太大意义，我们直接进行实操，才能深入体会 ORM 这种思想和 OrmLite 在操作数据库方面带来的便利。</p>\n<h2 id=\"2-1-引入依赖\"><a href=\"#2-1-引入依赖\" class=\"headerlink\" title=\"2.1 引入依赖\"></a>2.1 引入依赖</h2><ul>\n<li>由于是安卓开发，我们这里使用 Gradle 作为构建工具。在 app 的 build.Gradle 中引入依赖包，然后重新同步一下依赖：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//ormlite</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-core:4.48&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.j256.ormlite:ormlite-android:4.48&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-定义数据模型类\"><a href=\"#2-2-定义数据模型类\" class=\"headerlink\" title=\"2.2 定义数据模型类\"></a>2.2 定义数据模型类</h2><ul>\n<li>我们这里简单定义一个 User 类，表示用户，属性有唯一id、姓名、年龄和性别，</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DatabaseTable(tableName = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一身份识别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(generatedId = true)</span> <span class=\"comment\">// 自动生成的主键，主键可以省略canBeNull = false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;name&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;age&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"meta\">@DatabaseField(columnName = &quot;gender&quot;, canBeNull = false)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">User</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他构造器、getter和setter方法、toString等</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"FF0000\"><br>重点来了（敲黑板!!）</font><br>首先解释一下这段代码：<strong>使用 OrmLite 框架，定义一个 User 类，并映射为数据库中的一张名为 user 的表。</strong></p>\n<ol>\n<li>注解解释：<ol>\n<li>@DatabaseTable(tableName = “user”)<br>该注解用于标记该类为数据库表，tableName 指定了表的名称，在该注解中可以设置一些属性，例如索引、外键等。</li>\n<li>@DatabaseField(generatedId = true)<br>该注解用于标记主键字段，generatedId=true 表示该字段为自增长主键。如果不想使用自增主键，在对应的 @DatabaseField 注解中加入 id = true 即可。</li>\n<li>@DatabaseField(columnName = “name”, canBeNull = false)<br>该注解用于标记一个普通的字段，columnName 指定了该字段在表中的列名，canBeNull=false 表示该字段不能为空。</li>\n</ol>\n</li>\n<li>注意事项：<ol>\n<li>无参构造必须存在<br>有框架使用经验的小伙伴对这个应该不会陌生，<font color=\"FF0000\">框架 = 反射 + 注解 + 设计模式</font>，这和必须存在无参构造有什么关系呢？<br>Java 反射机制会根据类的信息动态地创建对象，并给属性赋值，而这个过程是通过默认的<strong>无参构造</strong>方法实现的。如果一个类没有提供无参构造方法，那么反射机制就无法创建该类的实例，也就无法将其映射为数据库表中的一行数据。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-3-创建工具类\"><a href=\"#2-3-创建工具类\" class=\"headerlink\" title=\"2.3 创建工具类\"></a>2.3 创建工具类</h2><h3 id=\"2-3-1-数据库管理工具类\"><a href=\"#2-3-1-数据库管理工具类\" class=\"headerlink\" title=\"2.3.1 数据库管理工具类\"></a>2.3.1 数据库管理工具类</h3><p>为了重用代码，提高代码的可复用性、可读性和可维护性。我们构建一个工具类专门管理数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OrmLiteSqliteOpenHelper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DATABASE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;db_demo.db&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据库版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DATABASE_VERSION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DatabaseHelper</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, DATABASE_NAME, <span class=\"literal\">null</span>, DATABASE_VERSION);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里创建表格</span></span><br><span class=\"line\">            TableUtils.createTable(connectionSource, User.class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, ConnectionSource connectionSource, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这里升级表格</span></span><br><span class=\"line\">            TableUtils.dropTable(connectionSource, User.class, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            onCreate(db, connectionSource);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，为了操作我们的数据库，我们应该为每一个实体类都创建一个相应的 DAO 接口和实现类。但是 OrmLite 已经提供了大量的 API 来操作数据库，不需要我们再手动编写 DAO 接口和实现类。<br>通过 OrmLite 提供的 Dao 接口，我们可以非常方便地进行数据库的插入、更新、删除和查询等操作。<br>例如，以下代码演示了如何使用 Dao 类完成对 User 实体类的插入操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao&lt;User, Integer&gt; userDao=ormLiteUtils.getDao(User.class);</span><br><span class=\"line\">User user=<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;雷皓&quot;</span>,<span class=\"number\">18</span>,<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">userDao.create(user);</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，Dao 后面的两个泛型参数 User 和 Integer 分别表示需要操作的实体类和实体类主键的类型。</p>\n<h3 id=\"2-3-2-操作-DAO-对象的工具类\"><a href=\"#2-3-2-操作-DAO-对象的工具类\" class=\"headerlink\" title=\"2.3.2 操作 DAO 对象的工具类\"></a>2.3.2 操作 DAO 对象的工具类</h3><p>为了方便我们更容易的创建和获取 DAO 对象，我们创建一个工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrmLiteUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例模式静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OrmLiteUtils instance;</span><br><span class=\"line\">    <span class=\"comment\">// DatabaseHelper 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DatabaseHelper databaseHelper;</span><br><span class=\"line\">    <span class=\"comment\">// UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">OrmLiteUtils</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 DatabaseHelper 对象</span></span><br><span class=\"line\">        databaseHelper = <span class=\"keyword\">new</span> <span class=\"title class_\">DatabaseHelper</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取实例对象（实现单例模式）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> OrmLiteUtils <span class=\"title function_\">getInstance</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) instance = <span class=\"keyword\">new</span> <span class=\"title class_\">OrmLiteUtils</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 UserDao 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Dao&lt;User, Integer&gt; <span class=\"title function_\">getUserDao</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException, java.sql.SQLException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userDao == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 获取 Dao 对象</span></span><br><span class=\"line\">            userDao = databaseHelper.getDao(User.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该工具类提供了懒加载模式的 DAO 获取方式，即只有在第一次调用 getUserDao() 方法时才会去创建相应的 DAO 对象，并缓存在类的私有属性中。这种方式可以优化性能，提高应用启动速度。同时，为了线程安全，该类中的 DAO<br>获取方法都是同步方法，防止多线程获取时出现冲突。</p>\n<p>在实际开发中，根据业务的需要，更改对应的数据库和实例类对象即可。</p>\n<h2 id=\"2-4-开始使用\"><a href=\"#2-4-开始使用\" class=\"headerlink\" title=\"2.4 开始使用\"></a>2.4 开始使用</h2><p>好了，准备工作已经全部完成，接下来就会拥有非常愉快的数据库操作体验了！<br>接下来我们创建一个非常简单的应用，测试我们的上面的配置能否正常工作。具体的安卓代码就省略了，它不是今天的重点。<br>应用很简单，提供几个按钮，可以操作 user 表即可。</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWhe9.jpg\" width=\"50%\">\n\n<h3 id=\"2-4-1-获取数据库访问对象\"><a href=\"#2-4-1-获取数据库访问对象\" class=\"headerlink\" title=\"2.4.1 获取数据库访问对象\"></a>2.4.1 获取数据库访问对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数据库访问对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dao&lt;User, Integer&gt; userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        <span class=\"comment\">// 点击获取 Dao 对象</span></span><br><span class=\"line\">        <span class=\"type\">OrmLiteUtils</span> <span class=\"variable\">ormLiteUtils</span> <span class=\"operator\">=</span> OrmLiteUtils.getInstance(context);</span><br><span class=\"line\">        userDao = ormLiteUtils.getUserDao();</span><br><span class=\"line\">        <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-插入操作\"><a href=\"#2-4-2-插入操作\" class=\"headerlink\" title=\"2.4.2 插入操作\"></a>2.4.2 插入操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入数据</span></span><br><span class=\"line\">        binding.btnInsert.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(name, Integer.parseInt(age), gender);</span><br><span class=\"line\">            <span class=\"comment\">//插入用户</span></span><br><span class=\"line\">            userDao.create(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-3-删除操作\"><a href=\"#2-4-3-删除操作\" class=\"headerlink\" title=\"2.4.3 删除操作\"></a>2.4.3 删除操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initEvent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//删除数据</span></span><br><span class=\"line\">        binding.btnDeleteById.setOnClickListener(view -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">            <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userDao.queryForId(Integer.valueOf(id));</span><br><span class=\"line\">            <span class=\"comment\">//删除用户</span></span><br><span class=\"line\">            userDao.delete(user);</span><br><span class=\"line\">            <span class=\"comment\">/* 其他操作 */</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就演示这两个吧，因为其他操作也非常简单，几行代码就可以搞定，感兴趣的同学可以去探索一下。<br>接下来我们看看他给我们存到数据库里面的内容：</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWjTX.png\"  width=\"50%\">\n\n<p>没有任何问题！</p>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在使用 OrmLite 时，需要先定义数据表对应的实体类，然后通过 Annotation 来配置表名、字段名、主键等信息。OrmLite 还可以帮助程序员自动生成表结构，同时支持手动管理版本升级。</li>\n<li>除此之外，OrmLite 还提供了一些高级功能，例如事务处理、外键约束、查询器（QueryBuilder）等。查询器是 OrmLite 中用于查询数据的 API，支持链式调用、多条件查询等功能，可以帮助程序员快速提取所需数据。</li>\n<li>总之，OrmLite 简单易用、灵活可扩展、性能优良，是 Android 数据库操作中非常值得探究的一种工具。</li>\n</ul>"},{"title":"Navigation 组件使用示例","date":"2023-05-13T00:00:00.000Z","description":"Android Jetpack 组件之 Navigation","cover":"https://www.helloimg.com/images/2023/05/13/oxuaj9.png","_content":"\n> Navigation 是一个框架，用于在 Android 应用中的“目的地”之间导航，该框架提供一致的 API，无论目的地是作为 Fragment、Activity 还是其他组件实现。\n\n# 一、Navigation  \n\n## 1.1 概念\n\n- Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。\n- 使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。\n\n## 1.2 组成部分\n\n- 该组件包括以下几个基本部分：\n\n  1. 导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n  2. 目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。\n  3. 动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。\n  4. 导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。\n  5. 依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。\n\n# 二、Navigation 的使用\n\n## 2.1 添加依赖\n- 在 build.gradle(app) 中添加依赖（kotlin）：\n```groovy\ndependencies {\n  \n    implementation 'androidx.navigation:navigation-fragment-ktx:2.5.2'\n    implementation 'androidx.navigation:navigation-ui-ktx:2.5.2'\n\n}\n```\n\n## 2.2 创建两个 Fragment 示例\n- 直接 new -> Fragment -> Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。\n- 下面是 HomeFragment 的示例：\n```kotlin\nclass HomeFragment : Fragment() {\n\n    private lateinit var binding: FragmentHomeBinding\n  \n    override fun onCreateView(\n      inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View? {\n      // Inflate the layout for this fragment\n      binding = FragmentHomeBinding.inflate(inflater, container, false)\n      return binding.root\n    }\n  \n}\n```\n- 生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。\n- 布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。如下图：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxur3M.png\" width=\"30%\">\n\n## 2.3 创建导航图(Navigation Graph)\n\n- 导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n- 创建： res -> new -> Android Resource File\n- 名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择`Navigation`。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxuVMP.png\">\n\n- 导入刚才创建的 Fragment：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxy3p1.png\">\n\n- `tips`: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5kD6.png\" width=\"30%\">\n\n## 2.4 建立导航图与 NavHostFragment 的关联\n\n- 在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：\n- 在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)，完成后效果如下：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5RtE.jpg\">\n\n## 2.5 使用 NavController 完成跳转\n\n- 在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。\n- onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。\n```kotlin\nclass HomeFragment : Fragment() {\n\n  //复写 onViewCreated() 方法\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //设置按钮监听\n        binding.todetail.setOnClickListener {\n              //通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。\n              val controller = Navigation.findNavController(it)\n              //调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。\n              controller.navigate(R.id.action_homeFragment_to_detailFragment)\n        }\n        \n    }\n}\n```\n- 重点是这两行代码：\n```kotlin\n    val controller = Navigation.findNavController(it)\n    controller.navigate(R.id.action_homeFragment_to_detailFragment)\n```\n- 首先是第一行，用以获取与当前 Fragment 关联的 NavController。\n- `NavController` 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。\n- 第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。\n- `R.id.action_homeFragment_to_detailFragment`是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。\n\n- 在 DetailFragment 中进行同样的操作即可，这里不再给出代码。\n\n## 2.6 将导航过程与应用程序的 ActionBar 集成起来。\n\n- 现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxygB1.jpg\" width=\"30%\">\n\n- 在 Activity 中添加以下代码：\n```kotlin\nclass NavigationActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityNavigationBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNavigationBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n      \n        // 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。\n        // 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController\n        val navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()\n      \n        if (navController != null) {\n            //使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来\n            NavigationUI.setupActionBarWithNavController(this, navController)\n        }\n      \n    }\n    //重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。\n    override fun onSupportNavigateUp(): Boolean {\n        val controller = Navigation.findNavController(this, R.id.fragment)\n        return controller.navigateUp()\n    }\n}\n```\n- 实现的效果：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxyDKc.gif\"  width=\"30%\">\n\n- 目前为止，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！\n- 使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。\n\n# 三、总结\n\n- 在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。\n- 可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。\n- 当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！","source":"_posts/安卓_04_Navigation.md","raw":"---\ntitle: 'Navigation 组件使用示例'\ndate: '2023-05-13'\ndescription: 'Android Jetpack 组件之 Navigation'\ncover: 'https://www.helloimg.com/images/2023/05/13/oxuaj9.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n> Navigation 是一个框架，用于在 Android 应用中的“目的地”之间导航，该框架提供一致的 API，无论目的地是作为 Fragment、Activity 还是其他组件实现。\n\n# 一、Navigation  \n\n## 1.1 概念\n\n- Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。\n- 使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。\n\n## 1.2 组成部分\n\n- 该组件包括以下几个基本部分：\n\n  1. 导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n  2. 目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。\n  3. 动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。\n  4. 导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。\n  5. 依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。\n\n# 二、Navigation 的使用\n\n## 2.1 添加依赖\n- 在 build.gradle(app) 中添加依赖（kotlin）：\n```groovy\ndependencies {\n  \n    implementation 'androidx.navigation:navigation-fragment-ktx:2.5.2'\n    implementation 'androidx.navigation:navigation-ui-ktx:2.5.2'\n\n}\n```\n\n## 2.2 创建两个 Fragment 示例\n- 直接 new -> Fragment -> Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。\n- 下面是 HomeFragment 的示例：\n```kotlin\nclass HomeFragment : Fragment() {\n\n    private lateinit var binding: FragmentHomeBinding\n  \n    override fun onCreateView(\n      inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View? {\n      // Inflate the layout for this fragment\n      binding = FragmentHomeBinding.inflate(inflater, container, false)\n      return binding.root\n    }\n  \n}\n```\n- 生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。\n- 布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。如下图：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxur3M.png\" width=\"30%\">\n\n## 2.3 创建导航图(Navigation Graph)\n\n- 导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。\n- 创建： res -> new -> Android Resource File\n- 名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择`Navigation`。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxuVMP.png\">\n\n- 导入刚才创建的 Fragment：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxy3p1.png\">\n\n- `tips`: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5kD6.png\" width=\"30%\">\n\n## 2.4 建立导航图与 NavHostFragment 的关联\n\n- 在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：\n- 在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)，完成后效果如下：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5RtE.jpg\">\n\n## 2.5 使用 NavController 完成跳转\n\n- 在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。\n- onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。\n```kotlin\nclass HomeFragment : Fragment() {\n\n  //复写 onViewCreated() 方法\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //设置按钮监听\n        binding.todetail.setOnClickListener {\n              //通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。\n              val controller = Navigation.findNavController(it)\n              //调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。\n              controller.navigate(R.id.action_homeFragment_to_detailFragment)\n        }\n        \n    }\n}\n```\n- 重点是这两行代码：\n```kotlin\n    val controller = Navigation.findNavController(it)\n    controller.navigate(R.id.action_homeFragment_to_detailFragment)\n```\n- 首先是第一行，用以获取与当前 Fragment 关联的 NavController。\n- `NavController` 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。\n- 第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。\n- `R.id.action_homeFragment_to_detailFragment`是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。\n\n- 在 DetailFragment 中进行同样的操作即可，这里不再给出代码。\n\n## 2.6 将导航过程与应用程序的 ActionBar 集成起来。\n\n- 现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxygB1.jpg\" width=\"30%\">\n\n- 在 Activity 中添加以下代码：\n```kotlin\nclass NavigationActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityNavigationBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNavigationBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n      \n        // 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。\n        // 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController\n        val navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()\n      \n        if (navController != null) {\n            //使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来\n            NavigationUI.setupActionBarWithNavController(this, navController)\n        }\n      \n    }\n    //重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。\n    override fun onSupportNavigateUp(): Boolean {\n        val controller = Navigation.findNavController(this, R.id.fragment)\n        return controller.navigateUp()\n    }\n}\n```\n- 实现的效果：\n\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxyDKc.gif\"  width=\"30%\">\n\n- 目前为止，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！\n- 使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。\n\n# 三、总结\n\n- 在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。\n- 可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。\n- 当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！","slug":"安卓_04_Navigation","published":1,"updated":"2023-07-25T02:45:48.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyub000wm7hocrzwewlz","content":"<blockquote>\n<p>Navigation 是一个框架，用于在 Android 应用中的“目的地”之间导航，该框架提供一致的 API，无论目的地是作为 Fragment、Activity 还是其他组件实现。</p>\n</blockquote>\n<h1 id=\"一、Navigation\"><a href=\"#一、Navigation\" class=\"headerlink\" title=\"一、Navigation\"></a>一、Navigation</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。</li>\n<li>使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ul>\n<li><p>该组件包括以下几个基本部分：</p>\n<ol>\n<li>导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。</li>\n<li>动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。</li>\n<li>导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。</li>\n<li>依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、Navigation-的使用\"><a href=\"#二、Navigation-的使用\" class=\"headerlink\" title=\"二、Navigation 的使用\"></a>二、Navigation 的使用</h1><h2 id=\"2-1-添加依赖\"><a href=\"#2-1-添加依赖\" class=\"headerlink\" title=\"2.1 添加依赖\"></a>2.1 添加依赖</h2><ul>\n<li>在 build.gradle(app) 中添加依赖（kotlin）：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-fragment-ktx:2.5.2&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-ui-ktx:2.5.2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-2-创建两个-Fragment-示例\"><a href=\"#2-2-创建两个-Fragment-示例\" class=\"headerlink\" title=\"2.2 创建两个 Fragment 示例\"></a>2.2 创建两个 Fragment 示例</h2><ul>\n<li>直接 new -&gt; Fragment -&gt; Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。</li>\n<li>下面是 HomeFragment 的示例：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentHomeBinding</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View? &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Inflate the layout for this fragment</span></span><br><span class=\"line\">      binding = FragmentHomeBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。</li>\n<li>布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。如下图：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxur3M.png\" width=\"30%\">\n\n<h2 id=\"2-3-创建导航图-Navigation-Graph\"><a href=\"#2-3-创建导航图-Navigation-Graph\" class=\"headerlink\" title=\"2.3 创建导航图(Navigation Graph)\"></a>2.3 创建导航图(Navigation Graph)</h2><ul>\n<li>导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>创建： res -&gt; new -&gt; Android Resource File</li>\n<li>名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择<code>Navigation</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxuVMP.png\">\n\n<ul>\n<li>导入刚才创建的 Fragment：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxy3p1.png\">\n\n<ul>\n<li><code>tips</code>: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5kD6.png\" width=\"30%\">\n\n<h2 id=\"2-4-建立导航图与-NavHostFragment-的关联\"><a href=\"#2-4-建立导航图与-NavHostFragment-的关联\" class=\"headerlink\" title=\"2.4 建立导航图与 NavHostFragment 的关联\"></a>2.4 建立导航图与 NavHostFragment 的关联</h2><ul>\n<li>在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：</li>\n<li>在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)，完成后效果如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5RtE.jpg\">\n\n<h2 id=\"2-5-使用-NavController-完成跳转\"><a href=\"#2-5-使用-NavController-完成跳转\" class=\"headerlink\" title=\"2.5 使用 NavController 完成跳转\"></a>2.5 使用 NavController 完成跳转</h2><ul>\n<li><p>在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。</p>\n</li>\n<li><p>onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//复写 onViewCreated() 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//设置按钮监听</span></span><br><span class=\"line\">        binding.todetail.setOnClickListener &#123;</span><br><span class=\"line\">              <span class=\"comment\">//通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。</span></span><br><span class=\"line\">              <span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">              <span class=\"comment\">//调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。</span></span><br><span class=\"line\">              controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>重点是这两行代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br></pre></td></tr></table></figure></li>\n<li><p>首先是第一行，用以获取与当前 Fragment 关联的 NavController。</p>\n</li>\n<li><p><code>NavController</code> 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。</p>\n</li>\n<li><p>第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。</p>\n</li>\n<li><p><code>R.id.action_homeFragment_to_detailFragment</code>是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。</p>\n</li>\n<li><p>在 DetailFragment 中进行同样的操作即可，这里不再给出代码。</p>\n</li>\n</ul>\n<h2 id=\"2-6-将导航过程与应用程序的-ActionBar-集成起来。\"><a href=\"#2-6-将导航过程与应用程序的-ActionBar-集成起来。\" class=\"headerlink\" title=\"2.6 将导航过程与应用程序的 ActionBar 集成起来。\"></a>2.6 将导航过程与应用程序的 ActionBar 集成起来。</h2><ul>\n<li>现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxygB1.jpg\" width=\"30%\">\n\n<ul>\n<li>在 Activity 中添加以下代码：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NavigationActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityNavigationBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        binding = ActivityNavigationBinding.inflate(layoutInflater)</span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。</span></span><br><span class=\"line\">        <span class=\"comment\">// 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (navController != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来</span></span><br><span class=\"line\">            NavigationUI.setupActionBarWithNavController(<span class=\"keyword\">this</span>, navController)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSupportNavigateUp</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> controller = Navigation.findNavController(<span class=\"keyword\">this</span>, R.id.fragment)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.navigateUp()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现的效果：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxyDKc.gif\"  width=\"30%\">\n\n<ul>\n<li>目前为止，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！</li>\n<li>使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。</li>\n<li>可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。</li>\n<li>当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>Navigation 是一个框架，用于在 Android 应用中的“目的地”之间导航，该框架提供一致的 API，无论目的地是作为 Fragment、Activity 还是其他组件实现。</p>\n</blockquote>\n<h1 id=\"一、Navigation\"><a href=\"#一、Navigation\" class=\"headerlink\" title=\"一、Navigation\"></a>一、Navigation</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>Jetpack Navigation 组件是 Android Jetpack 中的一部分，它提供了一种简单而强大的方式来实现在应用程序中进行导航和交互的标准化方法。</li>\n<li>使用 Jetpack Navigation 组件可以轻松实现复杂的 UI 导航功能。与传统的 Fragment 事务相比，它们更加标准化、可重用和易于维护。此外，该组件还可以自动生成深度链接和测试导航行为。在现代的 Android 应用程序设计中，Jetpack Navigation 组件已成为 UI 导航的首选方法之一。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ul>\n<li><p>该组件包括以下几个基本部分：</p>\n<ol>\n<li>导航图 （Navigation Graph）：一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>目标（Destination）：表示应用程序中的屏幕或 UI 视图。例如，一个应用程序可能有一个主屏幕，一个设置屏幕和一个详细信息屏幕。</li>\n<li>动作（Action）：表示从一个屏幕到另一个屏幕之间的转换。例如，从主屏幕转到详细信息屏幕，用户需要单击列表项。</li>\n<li>导航控制器（NavController）：负责跟踪应用程序的当前目标和路径，并处理导航操作以更改这些值。</li>\n<li>依赖注入（Dependency Injection）：Navigation 组件提供了 ViewModel、SavedStateHandle 等支持依赖注入的类，方便开发者使用。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"二、Navigation-的使用\"><a href=\"#二、Navigation-的使用\" class=\"headerlink\" title=\"二、Navigation 的使用\"></a>二、Navigation 的使用</h1><h2 id=\"2-1-添加依赖\"><a href=\"#2-1-添加依赖\" class=\"headerlink\" title=\"2.1 添加依赖\"></a>2.1 添加依赖</h2><ul>\n<li>在 build.gradle(app) 中添加依赖（kotlin）：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-fragment-ktx:2.5.2&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.navigation:navigation-ui-ktx:2.5.2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-2-创建两个-Fragment-示例\"><a href=\"#2-2-创建两个-Fragment-示例\" class=\"headerlink\" title=\"2.2 创建两个 Fragment 示例\"></a>2.2 创建两个 Fragment 示例</h2><ul>\n<li>直接 new -&gt; Fragment -&gt; Fragment(Blank) 即可，一个取名 HomeFragment 作为主页，一个取名 DetailFragment 作为跳转的详情页。</li>\n<li>下面是 HomeFragment 的示例：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentHomeBinding</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View? &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Inflate the layout for this fragment</span></span><br><span class=\"line\">      binding = FragmentHomeBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>生成的多余内容可以删掉，只保留 onCreateView 即可。我这里使用了 ViewBinding，也可以使用 DataBinding 或者就 findViewById 都行。</li>\n<li>布局文件非常简单，两个页面都放置一个 TextView 和 一个 Button 即可。如下图：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxur3M.png\" width=\"30%\">\n\n<h2 id=\"2-3-创建导航图-Navigation-Graph\"><a href=\"#2-3-创建导航图-Navigation-Graph\" class=\"headerlink\" title=\"2.3 创建导航图(Navigation Graph)\"></a>2.3 创建导航图(Navigation Graph)</h2><ul>\n<li>导航图是一个 XML 文件，它定义了应用程序中的所有目标和路径，以及如何在应用程序中移动。</li>\n<li>创建： res -&gt; new -&gt; Android Resource File</li>\n<li>名称可以任意取一个满足要求的即可，这里取 my_nav.xml，重要的是资源类型 Resource Type，选择<code>Navigation</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxuVMP.png\">\n\n<ul>\n<li>导入刚才创建的 Fragment：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxy3p1.png\">\n\n<ul>\n<li><code>tips</code>: 如果发现主页不是 HomeFragment，可以点击左侧Component Tree中的 HomeFragment，然后右键选择Set as Start Destination 设置其为主页。更多的设置项可以自己探索。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5kD6.png\" width=\"30%\">\n\n<h2 id=\"2-4-建立导航图与-NavHostFragment-的关联\"><a href=\"#2-4-建立导航图与-NavHostFragment-的关联\" class=\"headerlink\" title=\"2.4 建立导航图与 NavHostFragment 的关联\"></a>2.4 建立导航图与 NavHostFragment 的关联</h2><ul>\n<li>在我们的宿主 Activity 的布局页面中，插入一个 NavHostFragment 布局控件：</li>\n<li>在弹出框中选择我们刚才创建好的Navigation Graph，即 my_nav.xml，并将其命名为 fragment (可使用默认名称)，完成后效果如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oE5RtE.jpg\">\n\n<h2 id=\"2-5-使用-NavController-完成跳转\"><a href=\"#2-5-使用-NavController-完成跳转\" class=\"headerlink\" title=\"2.5 使用 NavController 完成跳转\"></a>2.5 使用 NavController 完成跳转</h2><ul>\n<li><p>在 HomeFragment 中，重写 onViewCreated() 方法，我们在里面进行按钮点击事件的监听。</p>\n</li>\n<li><p>onViewCreated() 是 Fragment 的生命周期方法之一，用于在 Fragment 的视图层次结构被创建后执行自定义逻辑。在该方法中，您可以访问 Fragment 的根视图和子视图，并执行任何与视图相关的操作，例如初始化 UI 元素、设置监听器、加载数据等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//复写 onViewCreated() 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//设置按钮监听</span></span><br><span class=\"line\">        binding.todetail.setOnClickListener &#123;</span><br><span class=\"line\">              <span class=\"comment\">//通过传入 it 参数 (即按钮的 View 对象) 获取与当前 Fragment 关联的 NavController。</span></span><br><span class=\"line\">              <span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">              <span class=\"comment\">//调用 NavController 的 navigate() 方法将应用程序从 HomeFragment 导航到 DetailFragment。</span></span><br><span class=\"line\">              controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>重点是这两行代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> controller = Navigation.findNavController(it)</span><br><span class=\"line\">controller.navigate(R.id.action_homeFragment_to_detailFragment)</span><br></pre></td></tr></table></figure></li>\n<li><p>首先是第一行，用以获取与当前 Fragment 关联的 NavController。</p>\n</li>\n<li><p><code>NavController</code> 是 Navigation 组件的核心部分，负责管理应用程序的导航。每个 Destination（目标）都有一个相关的 NavGraph（导航图），NavController 将根据用户操作将应用程序从一个 Destination 导航到另一个 Destination。</p>\n</li>\n<li><p>第二行代码即调用 NavController 的 navigate() 方法，将应用程序从 HomeFragment 导航到 DetailFragment。</p>\n</li>\n<li><p><code>R.id.action_homeFragment_to_detailFragment</code>是自动（刚才拖动视图右侧圆点绑定跳转动作时）生成的，意为从 HomeFragment 到 DetailFragment 的动作。</p>\n</li>\n<li><p>在 DetailFragment 中进行同样的操作即可，这里不再给出代码。</p>\n</li>\n</ul>\n<h2 id=\"2-6-将导航过程与应用程序的-ActionBar-集成起来。\"><a href=\"#2-6-将导航过程与应用程序的-ActionBar-集成起来。\" class=\"headerlink\" title=\"2.6 将导航过程与应用程序的 ActionBar 集成起来。\"></a>2.6 将导航过程与应用程序的 ActionBar 集成起来。</h2><ul>\n<li>现在已经可以通过点击按钮实现 Fragment 跳转了，现在需要实现 ActionBar 栏的点击返回箭头实现返回主页的功能。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxygB1.jpg\" width=\"30%\">\n\n<ul>\n<li>在 Activity 中添加以下代码：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NavigationActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: ActivityNavigationBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        binding = ActivityNavigationBinding.inflate(layoutInflater)</span><br><span class=\"line\">        setContentView(binding.root)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 首先通过 supportFragmentManager 获取 Fragment 的管理器，并使用 R.id.fragment 找到当前活动的 Fragment。</span></span><br><span class=\"line\">        <span class=\"comment\">// 然后，我们调用 Fragment 的 findNavController() 方法获取与之关联的 NavController</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> navController = supportFragmentManager.findFragmentById(R.id.fragment)?.findNavController()</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (navController != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用 NavigationUI 类的 setupActionBarWithNavController() 方法将指定 Activity 的 ActionBar 与 NavController 关联起来</span></span><br><span class=\"line\">            NavigationUI.setupActionBarWithNavController(<span class=\"keyword\">this</span>, navController)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新获取与 Activity 中当前 Fragment 关联的 NavController，然后调用 navigateUp() 方法以返回上一个 Fragment。</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSupportNavigateUp</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> controller = Navigation.findNavController(<span class=\"keyword\">this</span>, R.id.fragment)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.navigateUp()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现的效果：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/13/oxyDKc.gif\"  width=\"30%\">\n\n<ul>\n<li>目前为止，就实现了两个 Fragment 之间的随意切换，再也不用频繁的进行 Fragment 事务的处理了！</li>\n<li>使用 Navigation 这种方式，使得添加 Fragment 非常简单，还可以自由的传递数据、设置跳转动画效果等等。</li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>在大型项目中，如果没有一个良好的导航体系，那么我们很容易陷入混乱，无法有效地管理 Fragment。而使用 Navigation 组件，我们可以轻松实现 Fragment 的模块化和复用，减少重复代码的编写，提高代码的可维护性和扩展性。</li>\n<li>可能只有两个 Fragment 还体现不出 Navigation 强大之处，但是能想象得出，在 Fragment 增多时，这种可视化的操作会使代码更加简洁易懂，让我们的逻辑也更为清晰。</li>\n<li>当然，本文只是简单介绍了 Navigation 的使用，Navigation 还有更多的功能等待我们进一步的探索！</li>\n</ul>\n"},{"title":"Jetpack 组件联合使用示例","date":"2023-06-27T00:00:00.000Z","description":"总结目前学过的 Jetpack 组件，并使用他们写一个口算练习App","cover":"https://www.helloimg.com/images/2023/05/12/oxIXog.jpg","_content":"\n> 目前学过的 Jetpack 组件有 ViewModel、Navigation以及DataBinding，今天汇总一下这三个重要的组件，包括概念和实际运用，并使用他们来完成一个简单的口算练习app。\n\n# 一、概念汇总\n\n## 1.1 ViewModel\n\n- 官方定义：[官方文档](https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn)中并没有明确的定义。\n- 按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。\n- 简而言之，就是`帮我们管理数据，让数据变得清晰明白，知根知底。`\n\n## 1.2 Navigation\n\n- 官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。\n- 之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。\n- 简而言之，就是`让界面之间的跳转变得更统一、更清晰（可视化）。`\n\n## 1.3 DataBinding\n\n- 官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。\n- 通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。\n- 简而言之，就是`让你不需要写很多重复的代码来更新界面上的数据。`\n\n# 二、实际运用\n\n- 目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个`口算练习App`案例来实际运用一下他们。\n\n## 2.1 导入依赖\n\n- 我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的`app`级别的`build.gradle`文件中添加：\n\n```groovy\nandroid {\n    buildFeatures {\n        //开启DataBinding\n        dataBinding = true\n    }\n}\n\ndependencies {\n    // 添加 DataBinding 的依赖项\n    implementation 'androidx.databinding:databinding-runtime:7.3.1'\n}\n```\n\n## 2.2 创建页面\n\n### 2.2.1 文件\n\n- 创建一个 Activity 页面，作为我们的 Fragment 容器。\n- 创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。\n- 创建好之后结构如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41vaQ.png\">\n\n### 2.2.2 布局\n\n- 这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。\n- 首先是 TitleFragment（主界面），内容很少，如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41wbt.png\" width=\"30%\">\n\n- 然后是 QuestionFragment（答题界面），主要用于答题，界面如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o410Du.png\" width=\"30%\">\n\n- 最后是成功（超过最高分）和失败（未超过最高分）的界面，二者布局几乎一样：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41QGv.png\" width=\"30%\"> <img src=\"https://www.helloimg.com/images/2023/06/27/o41pAE.png\" width=\"30%\">\n\n## 2.3 设置导航图(navGraph)\n\n### 2.3.1 新建导航图\n\n- 点击 res 资源路径，右键 -> new -> Android Resource File -> 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o417j9.png\">\n\n### 2.3.2 编辑导航图\n\n- 将四个 Fragment 添加进来，并设置 TitleFragment 为`Start Destination`，然后将所有的跳转逻辑`action`添加进来，直接在视图中拉箭头指向就可以了。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41U1P.png\">\n\n- 在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41IEX.png\">\n\n- 最后的效果如图：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o4169g.png\">\n\n## 2.4 ViewModel\n\n- 在项目目录下新建 MyViewModel 类，继承自`AndroidViewModel`，代码如下（有其他需求修改对应部分即可）：\n```kotlin\nclass MyViewModel(application: Application, savedStateHandle: SavedStateHandle) :\n    AndroidViewModel(application) {\n\n    private val handle: SavedStateHandle\n\n    private val spf: SharedPreferences\n    \n    var winFlag = false\n\n    companion object {\n        const val KEY_HIGH_SCORE = \"key_high_score\"\n        const val KEY_LEFT_NUMBER = \"key_left_number\"\n        const val KEY_RIGHT_NUMBER = \"key_right_number\"\n        const val KEY_OPERATOR = \"key_operator\"\n        const val KEY_ANSWER = \"key_answer\"\n        const val KEY_CURRENT_SCORE = \"key_current_score\"\n        const val SAVE_SHP_DATA_NAME = \"save_shp_data_name\"\n    }\n\n    init {\n        this.handle = savedStateHandle\n        spf = getApplication<Application>().getSharedPreferences(\n            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE\n        )\n        if (!handle.contains(KEY_HIGH_SCORE)) {\n            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, 0)\n            handle[KEY_LEFT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_RIGHT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_ANSWER] = 0\n            handle[KEY_CURRENT_SCORE] = 0\n        }\n    }\n\n    fun getLeftNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_LEFT_NUMBER)\n    }\n    \n    fun getRightNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_RIGHT_NUMBER)\n    }\n\n    fun getOperator(): MutableLiveData<String> {\n        return handle.getLiveData(KEY_OPERATOR)\n    }\n\n    fun getHighScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_HIGH_SCORE)\n    }\n\n    fun getCurrentScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_CURRENT_SCORE)\n    }\n\n    fun getAnswer(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_ANSWER)\n    }\n\n    //生成算式\n    fun generator() {\n        val level = 100\n        val random = Random()\n        val x = random.nextInt(level) + 1\n        val y = random.nextInt(level) + 1\n\n        if (x % 2 == 0) {\n            getOperator().value = \"+\"\n            if (x > y) {\n                getAnswer().value = x\n                getLeftNumber().value = y\n                getRightNumber().value = x - y\n            } else {\n                getAnswer().value = y\n                getLeftNumber().value = x\n                getRightNumber().value = y - x\n            }\n        } else {\n            getOperator().value = \"-\"\n            if (x > y) {\n                getAnswer().value = x - y\n                getLeftNumber().value = x\n                getRightNumber().value = y\n            } else {\n                getAnswer().value = y - x\n                getLeftNumber().value = y\n                getRightNumber().value = x\n            }\n        }\n\n\n    }\n\n    //保存新纪录\n    fun save() {\n        val edit = spf.edit()\n        getHighScore().value?.let { edit.putInt(KEY_HIGH_SCORE, it) }\n        edit.apply()\n    }\n\n\n    //答对处理\n    fun answerCorrect() {\n        val currentScore = getCurrentScore().value ?: 0\n        val highScore = getHighScore().value ?: 0\n        val updatedCurrentScore = currentScore + 1\n        //赋值最新得分结果\n        getCurrentScore().value = updatedCurrentScore\n        //如果超过最高分，就更新记录\n        if (updatedCurrentScore > highScore) {\n            getHighScore().value = updatedCurrentScore\n            winFlag = true\n        }\n        generator()\n    }\n}\n```\n- `注：`AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。\n\n## 2.5 DataBinding\n\n- 首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o418kM.png\">\n\n```xml\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.leihao.kotlinapp.calculation.viewmodel.MyViewModel\" />\n    </data>\n```\n### 2.5.1 TitleFragment 页面\n\n- 只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/high_score(data.highScore)}\"\n/>\n```\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：\n```xml\n<string name=\"high_score\">历史最高分：%d</string>\n```\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。\n\n### 2.5.2 Question 页面\n\n- 当前得分的 TextView 添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/current_score(data.currentScore)}\"\n/>\n```\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.leftNumber)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{data.operator}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.rightNumber)}\"\n/>\n```\n\n### 2.5.3 WinFragment 和 LoseFragment 页面\n\n- 在分数对应的 TextView 中分别添加属性：\n```xml\n<TextView\n        android:text=\"@{@string/win_score_message(data.currentScore)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{@string/lose_score_message(data.currentScore)}\"\n/>\n```\n- 大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。\n\n## 2.6 功能完善\n\n- 接下来将各个页面的剩余功能完成。\n- TitleFragment：\n```kotlin\nclass TitleFragment : Fragment() {\n    private lateinit var binding: FragmentTitleBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentTitleBinding.inflate(inflater, container, false)\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //去答题界面\n        binding.btnBegin.setOnClickListener {\n            val navController = Navigation.findNavController(view)\n            navController.navigate(R.id.action_titleFragment_to_questionFragment)\n        }\n    }\n}\n```\n\n- QuestionFragment：\n```kotlin\nclass QuestionFragment : Fragment() {\n    private lateinit var binding: FragmentQuestionBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentQuestionBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        //生成题目\n        myViewModel.generator()\n\n        //当前分数置0\n        myViewModel.getCurrentScore().value = 0\n\n        //显示输入的内容或者提示信息\n        val builder = StringBuilder()\n\n        val listener = View.OnClickListener {\n            when (it.id) {\n                R.id.button0 -> builder.append(\"0\")\n                R.id.button1 -> builder.append(\"1\")\n                R.id.button2 -> builder.append(\"2\")\n                R.id.button3 -> builder.append(\"3\")\n                R.id.button4 -> builder.append(\"4\")\n                R.id.button5 -> builder.append(\"5\")\n                R.id.button6 -> builder.append(\"6\")\n                R.id.button7 -> builder.append(\"7\")\n                R.id.button8 -> builder.append(\"8\")\n                R.id.button9 -> builder.append(\"9\")\n                R.id.button_clear -> builder.setLength(0)\n            }\n\n            if (builder.isEmpty()) {\n                binding.textView10.text = getString(R.string.input_indicator)\n            } else {\n                binding.textView10.text = builder.toString()\n            }\n        }\n        //提交答案\n        binding.buttonSubmit.setOnClickListener {\n            if (builder.isNotEmpty()) {\n                //计算正确\n                if (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) {\n                    myViewModel.answerCorrect()\n                    builder.setLength(0)\n                    binding.textView10.text = getString(R.string.answer_correct)\n                } else {//计算错误\n                    val navController = Navigation.findNavController(it)\n                    if (myViewModel.winFlag) {\n                        navController.navigate(R.id.action_questionFragment_to_winFragment)\n                        myViewModel.winFlag = false\n                        myViewModel.save()\n                    } else {\n                        navController.navigate(R.id.action_questionFragment_to_loseFragment)\n                    }\n                }\n            }\n        }\n        binding.button0.setOnClickListener(listener)\n        binding.button1.setOnClickListener(listener)\n        binding.button2.setOnClickListener(listener)\n        binding.button3.setOnClickListener(listener)\n        binding.button4.setOnClickListener(listener)\n        binding.button5.setOnClickListener(listener)\n        binding.button6.setOnClickListener(listener)\n        binding.button7.setOnClickListener(listener)\n        binding.button8.setOnClickListener(listener)\n        binding.button9.setOnClickListener(listener)\n        binding.buttonClear.setOnClickListener(listener)\n    }\n}\n```\n\n- WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：\n```kotlin\nclass WinFragment : Fragment() {\n\n    private lateinit var binding: FragmentWinBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentWinBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.btnBack.setOnClickListener {\n            val navController = Navigation.findNavController(it)\n            navController.navigate(R.id.action_winFragment_to_titleFragment)\n        }\n    }\n}\n```\n\n# 三、总结\n\n- 通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。\n- 在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！\n","source":"_posts/安卓_05_Jetpack组件联合使用示例.md","raw":"---\ntitle: 'Jetpack 组件联合使用示例'\ndate: '2023-06-27'\ndescription: '总结目前学过的 Jetpack 组件，并使用他们写一个口算练习App'\ncover: 'https://www.helloimg.com/images/2023/05/12/oxIXog.jpg'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n\n---\n\n> 目前学过的 Jetpack 组件有 ViewModel、Navigation以及DataBinding，今天汇总一下这三个重要的组件，包括概念和实际运用，并使用他们来完成一个简单的口算练习app。\n\n# 一、概念汇总\n\n## 1.1 ViewModel\n\n- 官方定义：[官方文档](https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn)中并没有明确的定义。\n- 按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。\n- 简而言之，就是`帮我们管理数据，让数据变得清晰明白，知根知底。`\n\n## 1.2 Navigation\n\n- 官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。\n- 之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。\n- 简而言之，就是`让界面之间的跳转变得更统一、更清晰（可视化）。`\n\n## 1.3 DataBinding\n\n- 官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。\n- 通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。\n- 简而言之，就是`让你不需要写很多重复的代码来更新界面上的数据。`\n\n# 二、实际运用\n\n- 目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个`口算练习App`案例来实际运用一下他们。\n\n## 2.1 导入依赖\n\n- 我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的`app`级别的`build.gradle`文件中添加：\n\n```groovy\nandroid {\n    buildFeatures {\n        //开启DataBinding\n        dataBinding = true\n    }\n}\n\ndependencies {\n    // 添加 DataBinding 的依赖项\n    implementation 'androidx.databinding:databinding-runtime:7.3.1'\n}\n```\n\n## 2.2 创建页面\n\n### 2.2.1 文件\n\n- 创建一个 Activity 页面，作为我们的 Fragment 容器。\n- 创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。\n- 创建好之后结构如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41vaQ.png\">\n\n### 2.2.2 布局\n\n- 这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。\n- 首先是 TitleFragment（主界面），内容很少，如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41wbt.png\" width=\"30%\">\n\n- 然后是 QuestionFragment（答题界面），主要用于答题，界面如下：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o410Du.png\" width=\"30%\">\n\n- 最后是成功（超过最高分）和失败（未超过最高分）的界面，二者布局几乎一样：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41QGv.png\" width=\"30%\"> <img src=\"https://www.helloimg.com/images/2023/06/27/o41pAE.png\" width=\"30%\">\n\n## 2.3 设置导航图(navGraph)\n\n### 2.3.1 新建导航图\n\n- 点击 res 资源路径，右键 -> new -> Android Resource File -> 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o417j9.png\">\n\n### 2.3.2 编辑导航图\n\n- 将四个 Fragment 添加进来，并设置 TitleFragment 为`Start Destination`，然后将所有的跳转逻辑`action`添加进来，直接在视图中拉箭头指向就可以了。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41U1P.png\">\n\n- 在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41IEX.png\">\n\n- 最后的效果如图：\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o4169g.png\">\n\n## 2.4 ViewModel\n\n- 在项目目录下新建 MyViewModel 类，继承自`AndroidViewModel`，代码如下（有其他需求修改对应部分即可）：\n```kotlin\nclass MyViewModel(application: Application, savedStateHandle: SavedStateHandle) :\n    AndroidViewModel(application) {\n\n    private val handle: SavedStateHandle\n\n    private val spf: SharedPreferences\n    \n    var winFlag = false\n\n    companion object {\n        const val KEY_HIGH_SCORE = \"key_high_score\"\n        const val KEY_LEFT_NUMBER = \"key_left_number\"\n        const val KEY_RIGHT_NUMBER = \"key_right_number\"\n        const val KEY_OPERATOR = \"key_operator\"\n        const val KEY_ANSWER = \"key_answer\"\n        const val KEY_CURRENT_SCORE = \"key_current_score\"\n        const val SAVE_SHP_DATA_NAME = \"save_shp_data_name\"\n    }\n\n    init {\n        this.handle = savedStateHandle\n        spf = getApplication<Application>().getSharedPreferences(\n            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE\n        )\n        if (!handle.contains(KEY_HIGH_SCORE)) {\n            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, 0)\n            handle[KEY_LEFT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_RIGHT_NUMBER] = 0\n            handle[KEY_OPERATOR] = \"+\"\n            handle[KEY_ANSWER] = 0\n            handle[KEY_CURRENT_SCORE] = 0\n        }\n    }\n\n    fun getLeftNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_LEFT_NUMBER)\n    }\n    \n    fun getRightNumber(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_RIGHT_NUMBER)\n    }\n\n    fun getOperator(): MutableLiveData<String> {\n        return handle.getLiveData(KEY_OPERATOR)\n    }\n\n    fun getHighScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_HIGH_SCORE)\n    }\n\n    fun getCurrentScore(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_CURRENT_SCORE)\n    }\n\n    fun getAnswer(): MutableLiveData<Int> {\n        return handle.getLiveData(KEY_ANSWER)\n    }\n\n    //生成算式\n    fun generator() {\n        val level = 100\n        val random = Random()\n        val x = random.nextInt(level) + 1\n        val y = random.nextInt(level) + 1\n\n        if (x % 2 == 0) {\n            getOperator().value = \"+\"\n            if (x > y) {\n                getAnswer().value = x\n                getLeftNumber().value = y\n                getRightNumber().value = x - y\n            } else {\n                getAnswer().value = y\n                getLeftNumber().value = x\n                getRightNumber().value = y - x\n            }\n        } else {\n            getOperator().value = \"-\"\n            if (x > y) {\n                getAnswer().value = x - y\n                getLeftNumber().value = x\n                getRightNumber().value = y\n            } else {\n                getAnswer().value = y - x\n                getLeftNumber().value = y\n                getRightNumber().value = x\n            }\n        }\n\n\n    }\n\n    //保存新纪录\n    fun save() {\n        val edit = spf.edit()\n        getHighScore().value?.let { edit.putInt(KEY_HIGH_SCORE, it) }\n        edit.apply()\n    }\n\n\n    //答对处理\n    fun answerCorrect() {\n        val currentScore = getCurrentScore().value ?: 0\n        val highScore = getHighScore().value ?: 0\n        val updatedCurrentScore = currentScore + 1\n        //赋值最新得分结果\n        getCurrentScore().value = updatedCurrentScore\n        //如果超过最高分，就更新记录\n        if (updatedCurrentScore > highScore) {\n            getHighScore().value = updatedCurrentScore\n            winFlag = true\n        }\n        generator()\n    }\n}\n```\n- `注：`AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。\n\n## 2.5 DataBinding\n\n- 首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。\n\n<img src=\"https://www.helloimg.com/images/2023/06/27/o418kM.png\">\n\n```xml\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.leihao.kotlinapp.calculation.viewmodel.MyViewModel\" />\n    </data>\n```\n### 2.5.1 TitleFragment 页面\n\n- 只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/high_score(data.highScore)}\"\n/>\n```\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：\n```xml\n<string name=\"high_score\">历史最高分：%d</string>\n```\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。\n\n### 2.5.2 Question 页面\n\n- 当前得分的 TextView 添加属性：\n```xml\n<TextView \n        android:text=\"@{@string/current_score(data.currentScore)}\"\n/>\n```\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.leftNumber)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{data.operator}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{String.valueOf(data.rightNumber)}\"\n/>\n```\n\n### 2.5.3 WinFragment 和 LoseFragment 页面\n\n- 在分数对应的 TextView 中分别添加属性：\n```xml\n<TextView\n        android:text=\"@{@string/win_score_message(data.currentScore)}\"\n/>\n```\n```xml\n<TextView\n        android:text=\"@{@string/lose_score_message(data.currentScore)}\"\n/>\n```\n- 大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。\n\n## 2.6 功能完善\n\n- 接下来将各个页面的剩余功能完成。\n- TitleFragment：\n```kotlin\nclass TitleFragment : Fragment() {\n    private lateinit var binding: FragmentTitleBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentTitleBinding.inflate(inflater, container, false)\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        //去答题界面\n        binding.btnBegin.setOnClickListener {\n            val navController = Navigation.findNavController(view)\n            navController.navigate(R.id.action_titleFragment_to_questionFragment)\n        }\n    }\n}\n```\n\n- QuestionFragment：\n```kotlin\nclass QuestionFragment : Fragment() {\n    private lateinit var binding: FragmentQuestionBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentQuestionBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        //生成题目\n        myViewModel.generator()\n\n        //当前分数置0\n        myViewModel.getCurrentScore().value = 0\n\n        //显示输入的内容或者提示信息\n        val builder = StringBuilder()\n\n        val listener = View.OnClickListener {\n            when (it.id) {\n                R.id.button0 -> builder.append(\"0\")\n                R.id.button1 -> builder.append(\"1\")\n                R.id.button2 -> builder.append(\"2\")\n                R.id.button3 -> builder.append(\"3\")\n                R.id.button4 -> builder.append(\"4\")\n                R.id.button5 -> builder.append(\"5\")\n                R.id.button6 -> builder.append(\"6\")\n                R.id.button7 -> builder.append(\"7\")\n                R.id.button8 -> builder.append(\"8\")\n                R.id.button9 -> builder.append(\"9\")\n                R.id.button_clear -> builder.setLength(0)\n            }\n\n            if (builder.isEmpty()) {\n                binding.textView10.text = getString(R.string.input_indicator)\n            } else {\n                binding.textView10.text = builder.toString()\n            }\n        }\n        //提交答案\n        binding.buttonSubmit.setOnClickListener {\n            if (builder.isNotEmpty()) {\n                //计算正确\n                if (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) {\n                    myViewModel.answerCorrect()\n                    builder.setLength(0)\n                    binding.textView10.text = getString(R.string.answer_correct)\n                } else {//计算错误\n                    val navController = Navigation.findNavController(it)\n                    if (myViewModel.winFlag) {\n                        navController.navigate(R.id.action_questionFragment_to_winFragment)\n                        myViewModel.winFlag = false\n                        myViewModel.save()\n                    } else {\n                        navController.navigate(R.id.action_questionFragment_to_loseFragment)\n                    }\n                }\n            }\n        }\n        binding.button0.setOnClickListener(listener)\n        binding.button1.setOnClickListener(listener)\n        binding.button2.setOnClickListener(listener)\n        binding.button3.setOnClickListener(listener)\n        binding.button4.setOnClickListener(listener)\n        binding.button5.setOnClickListener(listener)\n        binding.button6.setOnClickListener(listener)\n        binding.button7.setOnClickListener(listener)\n        binding.button8.setOnClickListener(listener)\n        binding.button9.setOnClickListener(listener)\n        binding.buttonClear.setOnClickListener(listener)\n    }\n}\n```\n\n- WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：\n```kotlin\nclass WinFragment : Fragment() {\n\n    private lateinit var binding: FragmentWinBinding\n\n    //快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致\n    private val myViewModel: MyViewModel by activityViewModels()\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        binding = FragmentWinBinding.inflate(inflater, container, false)\n\n        //将 ViewModel 中的数据与布局文件进行绑定\n        binding.data = myViewModel\n        //设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。\n        binding.lifecycleOwner = this\n\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.btnBack.setOnClickListener {\n            val navController = Navigation.findNavController(it)\n            navController.navigate(R.id.action_winFragment_to_titleFragment)\n        }\n    }\n}\n```\n\n# 三、总结\n\n- 通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。\n- 在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！\n","slug":"安卓_05_Jetpack组件联合使用示例","published":1,"updated":"2023-07-19T09:23:44.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyud0011m7hohyhpf6hu","content":"<blockquote>\n<p>目前学过的 Jetpack 组件有 ViewModel、Navigation以及DataBinding，今天汇总一下这三个重要的组件，包括概念和实际运用，并使用他们来完成一个简单的口算练习app。</p>\n</blockquote>\n<h1 id=\"一、概念汇总\"><a href=\"#一、概念汇总\" class=\"headerlink\" title=\"一、概念汇总\"></a>一、概念汇总</h1><h2 id=\"1-1-ViewModel\"><a href=\"#1-1-ViewModel\" class=\"headerlink\" title=\"1.1 ViewModel\"></a>1.1 ViewModel</h2><ul>\n<li>官方定义：<a href=\"https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn\">官方文档</a>中并没有明确的定义。</li>\n<li>按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。</li>\n<li>简而言之，就是<code>帮我们管理数据，让数据变得清晰明白，知根知底。</code></li>\n</ul>\n<h2 id=\"1-2-Navigation\"><a href=\"#1-2-Navigation\" class=\"headerlink\" title=\"1.2 Navigation\"></a>1.2 Navigation</h2><ul>\n<li>官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。</li>\n<li>之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。</li>\n<li>简而言之，就是<code>让界面之间的跳转变得更统一、更清晰（可视化）。</code></li>\n</ul>\n<h2 id=\"1-3-DataBinding\"><a href=\"#1-3-DataBinding\" class=\"headerlink\" title=\"1.3 DataBinding\"></a>1.3 DataBinding</h2><ul>\n<li>官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。</li>\n<li>通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。</li>\n<li>简而言之，就是<code>让你不需要写很多重复的代码来更新界面上的数据。</code></li>\n</ul>\n<h1 id=\"二、实际运用\"><a href=\"#二、实际运用\" class=\"headerlink\" title=\"二、实际运用\"></a>二、实际运用</h1><ul>\n<li>目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个<code>口算练习App</code>案例来实际运用一下他们。</li>\n</ul>\n<h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的<code>app</code>级别的<code>build.gradle</code>文件中添加：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开启DataBinding</span></span><br><span class=\"line\">        dataBinding = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 DataBinding 的依赖项</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.databinding:databinding-runtime:7.3.1&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-创建页面\"><a href=\"#2-2-创建页面\" class=\"headerlink\" title=\"2.2 创建页面\"></a>2.2 创建页面</h2><h3 id=\"2-2-1-文件\"><a href=\"#2-2-1-文件\" class=\"headerlink\" title=\"2.2.1 文件\"></a>2.2.1 文件</h3><ul>\n<li>创建一个 Activity 页面，作为我们的 Fragment 容器。</li>\n<li>创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。</li>\n<li>创建好之后结构如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41vaQ.png\">\n\n<h3 id=\"2-2-2-布局\"><a href=\"#2-2-2-布局\" class=\"headerlink\" title=\"2.2.2 布局\"></a>2.2.2 布局</h3><ul>\n<li>这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。</li>\n<li>首先是 TitleFragment（主界面），内容很少，如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41wbt.png\" width=\"30%\">\n\n<ul>\n<li>然后是 QuestionFragment（答题界面），主要用于答题，界面如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o410Du.png\" width=\"30%\">\n\n<ul>\n<li>最后是成功（超过最高分）和失败（未超过最高分）的界面，二者布局几乎一样：</li>\n</ul>\n<p><img src=\"https://www.helloimg.com/images/2023/06/27/o41QGv.png\" width=\"30%\"> <img src=\"https://www.helloimg.com/images/2023/06/27/o41pAE.png\" width=\"30%\"></p>\n<h2 id=\"2-3-设置导航图-navGraph\"><a href=\"#2-3-设置导航图-navGraph\" class=\"headerlink\" title=\"2.3 设置导航图(navGraph)\"></a>2.3 设置导航图(navGraph)</h2><h3 id=\"2-3-1-新建导航图\"><a href=\"#2-3-1-新建导航图\" class=\"headerlink\" title=\"2.3.1 新建导航图\"></a>2.3.1 新建导航图</h3><ul>\n<li>点击 res 资源路径，右键 -&gt; new -&gt; Android Resource File -&gt; 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o417j9.png\">\n\n<h3 id=\"2-3-2-编辑导航图\"><a href=\"#2-3-2-编辑导航图\" class=\"headerlink\" title=\"2.3.2 编辑导航图\"></a>2.3.2 编辑导航图</h3><ul>\n<li>将四个 Fragment 添加进来，并设置 TitleFragment 为<code>Start Destination</code>，然后将所有的跳转逻辑<code>action</code>添加进来，直接在视图中拉箭头指向就可以了。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41U1P.png\">\n\n<ul>\n<li>在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41IEX.png\">\n\n<ul>\n<li>最后的效果如图：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o4169g.png\">\n\n<h2 id=\"2-4-ViewModel\"><a href=\"#2-4-ViewModel\" class=\"headerlink\" title=\"2.4 ViewModel\"></a>2.4 ViewModel</h2><ul>\n<li>在项目目录下新建 MyViewModel 类，继承自<code>AndroidViewModel</code>，代码如下（有其他需求修改对应部分即可）：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span>(application: Application, savedStateHandle: SavedStateHandle) :</span><br><span class=\"line\">    AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handle: SavedStateHandle</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> spf: SharedPreferences</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_HIGH_SCORE = <span class=\"string\">&quot;key_high_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_LEFT_NUMBER = <span class=\"string\">&quot;key_left_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_RIGHT_NUMBER = <span class=\"string\">&quot;key_right_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_OPERATOR = <span class=\"string\">&quot;key_operator&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_ANSWER = <span class=\"string\">&quot;key_answer&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_CURRENT_SCORE = <span class=\"string\">&quot;key_current_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> SAVE_SHP_DATA_NAME = <span class=\"string\">&quot;save_shp_data_name&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = savedStateHandle</span><br><span class=\"line\">        spf = getApplication&lt;Application&gt;().getSharedPreferences(</span><br><span class=\"line\">            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!handle.contains(KEY_HIGH_SCORE)) &#123;</span><br><span class=\"line\">            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, <span class=\"number\">0</span>)</span><br><span class=\"line\">            handle[KEY_LEFT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_RIGHT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_ANSWER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_CURRENT_SCORE] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getLeftNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_LEFT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRightNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_RIGHT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getOperator</span><span class=\"params\">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_OPERATOR)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getHighScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_HIGH_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCurrentScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_CURRENT_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAnswer</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_ANSWER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成算式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generator</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> level = <span class=\"number\">100</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> random = Random()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> x = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> y = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x - y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y - x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x - y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y - x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保存新纪录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">save</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> edit = spf.edit()</span><br><span class=\"line\">        getHighScore().value?.let &#123; edit.putInt(KEY_HIGH_SCORE, it) &#125;</span><br><span class=\"line\">        edit.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//答对处理</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">answerCorrect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentScore = getCurrentScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> highScore = getHighScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> updatedCurrentScore = currentScore + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值最新得分结果</span></span><br><span class=\"line\">        getCurrentScore().value = updatedCurrentScore</span><br><span class=\"line\">        <span class=\"comment\">//如果超过最高分，就更新记录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (updatedCurrentScore &gt; highScore) &#123;</span><br><span class=\"line\">            getHighScore().value = updatedCurrentScore</span><br><span class=\"line\">            winFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generator()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>注：</code>AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。</li>\n</ul>\n<h2 id=\"2-5-DataBinding\"><a href=\"#2-5-DataBinding\" class=\"headerlink\" title=\"2.5 DataBinding\"></a>2.5 DataBinding</h2><ul>\n<li>首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o418kM.png\">\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">&quot;data&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.leihao.kotlinapp.calculation.viewmodel.MyViewModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-1-TitleFragment-页面\"><a href=\"#2-5-1-TitleFragment-页面\" class=\"headerlink\" title=\"2.5.1 TitleFragment 页面\"></a>2.5.1 TitleFragment 页面</h3><ul>\n<li>只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/high_score(data.highScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;high_score&quot;</span>&gt;</span>历史最高分：%d<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br></pre></td></tr></table></figure>\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。</li>\n</ul>\n<h3 id=\"2-5-2-Question-页面\"><a href=\"#2-5-2-Question-页面\" class=\"headerlink\" title=\"2.5.2 Question 页面\"></a>2.5.2 Question 页面</h3><ul>\n<li>当前得分的 TextView 添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/current_score(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.leftNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;data.operator&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.rightNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-5-3-WinFragment-和-LoseFragment-页面\"><a href=\"#2-5-3-WinFragment-和-LoseFragment-页面\" class=\"headerlink\" title=\"2.5.3 WinFragment 和 LoseFragment 页面\"></a>2.5.3 WinFragment 和 LoseFragment 页面</h3><ul>\n<li>在分数对应的 TextView 中分别添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/win_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/lose_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。</li>\n</ul>\n<h2 id=\"2-6-功能完善\"><a href=\"#2-6-功能完善\" class=\"headerlink\" title=\"2.6 功能完善\"></a>2.6 功能完善</h2><ul>\n<li><p>接下来将各个页面的剩余功能完成。</p>\n</li>\n<li><p>TitleFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TitleFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentTitleBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentTitleBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//去答题界面</span></span><br><span class=\"line\">        binding.btnBegin.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(view)</span><br><span class=\"line\">            navController.navigate(R.id.action_titleFragment_to_questionFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>QuestionFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QuestionFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentQuestionBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentQuestionBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成题目</span></span><br><span class=\"line\">        myViewModel.generator()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前分数置0</span></span><br><span class=\"line\">        myViewModel.getCurrentScore().value = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//显示输入的内容或者提示信息</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> builder = StringBuilder()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> listener = View.OnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (it.id) &#123;</span><br><span class=\"line\">                R.id.button0 -&gt; builder.append(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">                R.id.button1 -&gt; builder.append(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">                R.id.button2 -&gt; builder.append(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">                R.id.button3 -&gt; builder.append(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">                R.id.button4 -&gt; builder.append(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">                R.id.button5 -&gt; builder.append(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">                R.id.button6 -&gt; builder.append(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">                R.id.button7 -&gt; builder.append(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">                R.id.button8 -&gt; builder.append(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">                R.id.button9 -&gt; builder.append(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">                R.id.button_clear -&gt; builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isEmpty()) &#123;</span><br><span class=\"line\">                binding.textView10.text = getString(R.string.input_indicator)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                binding.textView10.text = builder.toString()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//提交答案</span></span><br><span class=\"line\">        binding.buttonSubmit.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isNotEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算正确</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) &#123;</span><br><span class=\"line\">                    myViewModel.answerCorrect()</span><br><span class=\"line\">                    builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">                    binding.textView10.text = getString(R.string.answer_correct)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//计算错误</span></span><br><span class=\"line\">                    <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (myViewModel.winFlag) &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_winFragment)</span><br><span class=\"line\">                        myViewModel.winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">                        myViewModel.save()</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_loseFragment)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        binding.button0.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button1.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button2.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button3.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button4.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button5.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button6.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button7.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button8.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button9.setOnClickListener(listener)</span><br><span class=\"line\">        binding.buttonClear.setOnClickListener(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WinFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentWinBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentWinBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.btnBack.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">            navController.navigate(R.id.action_winFragment_to_titleFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。</li>\n<li>在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>目前学过的 Jetpack 组件有 ViewModel、Navigation以及DataBinding，今天汇总一下这三个重要的组件，包括概念和实际运用，并使用他们来完成一个简单的口算练习app。</p>\n</blockquote>\n<h1 id=\"一、概念汇总\"><a href=\"#一、概念汇总\" class=\"headerlink\" title=\"一、概念汇总\"></a>一、概念汇总</h1><h2 id=\"1-1-ViewModel\"><a href=\"#1-1-ViewModel\" class=\"headerlink\" title=\"1.1 ViewModel\"></a>1.1 ViewModel</h2><ul>\n<li>官方定义：<a href=\"https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn\">官方文档</a>中并没有明确的定义。</li>\n<li>按我的理解它就是用于存储和管理与用户界面相关的数据的，通过将数据与 UI 控制器（如 Activity 或 Fragment）分离，以更好地支持应用程序的生命周期管理。</li>\n<li>简而言之，就是<code>帮我们管理数据，让数据变得清晰明白，知根知底。</code></li>\n</ul>\n<h2 id=\"1-2-Navigation\"><a href=\"#1-2-Navigation\" class=\"headerlink\" title=\"1.2 Navigation\"></a>1.2 Navigation</h2><ul>\n<li>官方定义：构建和组织应用内界面，处理深层链接以及在屏幕之间导航。</li>\n<li>之前使用传统的 FragmentManager 和 FragmentTransaction 进行 Fragment 切换时，存在一些问题，如 Fragment 堆栈管理困难、Fragment 之间通信复杂等。Navigation 组件提供了更简单且一致的方式来管理 Fragment，处理这些问题更加容易。</li>\n<li>简而言之，就是<code>让界面之间的跳转变得更统一、更清晰（可视化）。</code></li>\n</ul>\n<h2 id=\"1-3-DataBinding\"><a href=\"#1-3-DataBinding\" class=\"headerlink\" title=\"1.3 DataBinding\"></a>1.3 DataBinding</h2><ul>\n<li>官方定义：使用声明性格式将布局中的界面组件绑定到应用中的数据源。</li>\n<li>通过使用 DataBinding，我们可以在布局文件中直接引用应用程序的数据，并通过特定的语法将数据与界面元素进行绑定。这样，在数据发生变化时，布局中绑定的视图会自动更新，无需手动编写大量的 findViewById()、setText()、setOnClickListener() 等操作。</li>\n<li>简而言之，就是<code>让你不需要写很多重复的代码来更新界面上的数据。</code></li>\n</ul>\n<h1 id=\"二、实际运用\"><a href=\"#二、实际运用\" class=\"headerlink\" title=\"二、实际运用\"></a>二、实际运用</h1><ul>\n<li>目前，管理数据的、管理页面的、绑定页面和数据的组件我们都有了，那么他们如何组合使用呢？我们通过一个<code>口算练习App</code>案例来实际运用一下他们。</li>\n</ul>\n<h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>我们要添加的只有一个 DataBinding 的依赖（navGraph 的依赖在创建导航图时会自动帮我们添加），在我们新建项目的的<code>app</code>级别的<code>build.gradle</code>文件中添加：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildFeatures &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开启DataBinding</span></span><br><span class=\"line\">        dataBinding = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 DataBinding 的依赖项</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.databinding:databinding-runtime:7.3.1&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-创建页面\"><a href=\"#2-2-创建页面\" class=\"headerlink\" title=\"2.2 创建页面\"></a>2.2 创建页面</h2><h3 id=\"2-2-1-文件\"><a href=\"#2-2-1-文件\" class=\"headerlink\" title=\"2.2.1 文件\"></a>2.2.1 文件</h3><ul>\n<li>创建一个 Activity 页面，作为我们的 Fragment 容器。</li>\n<li>创建四个 Fragment 页面，分别是 TitleFragment（主界面）、QuestionFragment（答题界面）、WinFragment（胜利界面）、LoseFragment（失败界面）。</li>\n<li>创建好之后结构如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41vaQ.png\">\n\n<h3 id=\"2-2-2-布局\"><a href=\"#2-2-2-布局\" class=\"headerlink\" title=\"2.2.2 布局\"></a>2.2.2 布局</h3><ul>\n<li>这里不给出具体的布局文本，因为本身布局很简单，并且这并不是这次的重点，这里只提供一下预览视图，具体布局可以任意变化。</li>\n<li>首先是 TitleFragment（主界面），内容很少，如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41wbt.png\" width=\"30%\">\n\n<ul>\n<li>然后是 QuestionFragment（答题界面），主要用于答题，界面如下：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o410Du.png\" width=\"30%\">\n\n<ul>\n<li>最后是成功（超过最高分）和失败（未超过最高分）的界面，二者布局几乎一样：</li>\n</ul>\n<p><img src=\"https://www.helloimg.com/images/2023/06/27/o41QGv.png\" width=\"30%\"> <img src=\"https://www.helloimg.com/images/2023/06/27/o41pAE.png\" width=\"30%\"></p>\n<h2 id=\"2-3-设置导航图-navGraph\"><a href=\"#2-3-设置导航图-navGraph\" class=\"headerlink\" title=\"2.3 设置导航图(navGraph)\"></a>2.3 设置导航图(navGraph)</h2><h3 id=\"2-3-1-新建导航图\"><a href=\"#2-3-1-新建导航图\" class=\"headerlink\" title=\"2.3.1 新建导航图\"></a>2.3.1 新建导航图</h3><ul>\n<li>点击 res 资源路径，右键 -&gt; new -&gt; Android Resource File -&gt; 类型选择 Navigation(这一步会提示导入依赖，如果失败多试几次)</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o417j9.png\">\n\n<h3 id=\"2-3-2-编辑导航图\"><a href=\"#2-3-2-编辑导航图\" class=\"headerlink\" title=\"2.3.2 编辑导航图\"></a>2.3.2 编辑导航图</h3><ul>\n<li>将四个 Fragment 添加进来，并设置 TitleFragment 为<code>Start Destination</code>，然后将所有的跳转逻辑<code>action</code>添加进来，直接在视图中拉箭头指向就可以了。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41U1P.png\">\n\n<ul>\n<li>在 CalculationActivity 的布局文件中添加一个 NavHostFragment 控件，选择我们刚才创建的 nav_calc，将控件命名为fragment（也可以不改，都行）。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o41IEX.png\">\n\n<ul>\n<li>最后的效果如图：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o4169g.png\">\n\n<h2 id=\"2-4-ViewModel\"><a href=\"#2-4-ViewModel\" class=\"headerlink\" title=\"2.4 ViewModel\"></a>2.4 ViewModel</h2><ul>\n<li>在项目目录下新建 MyViewModel 类，继承自<code>AndroidViewModel</code>，代码如下（有其他需求修改对应部分即可）：<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyViewModel</span>(application: Application, savedStateHandle: SavedStateHandle) :</span><br><span class=\"line\">    AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handle: SavedStateHandle</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> spf: SharedPreferences</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_HIGH_SCORE = <span class=\"string\">&quot;key_high_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_LEFT_NUMBER = <span class=\"string\">&quot;key_left_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_RIGHT_NUMBER = <span class=\"string\">&quot;key_right_number&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_OPERATOR = <span class=\"string\">&quot;key_operator&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_ANSWER = <span class=\"string\">&quot;key_answer&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> KEY_CURRENT_SCORE = <span class=\"string\">&quot;key_current_score&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> SAVE_SHP_DATA_NAME = <span class=\"string\">&quot;save_shp_data_name&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = savedStateHandle</span><br><span class=\"line\">        spf = getApplication&lt;Application&gt;().getSharedPreferences(</span><br><span class=\"line\">            SAVE_SHP_DATA_NAME, Context.MODE_PRIVATE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!handle.contains(KEY_HIGH_SCORE)) &#123;</span><br><span class=\"line\">            handle[KEY_HIGH_SCORE] = spf.getInt(KEY_HIGH_SCORE, <span class=\"number\">0</span>)</span><br><span class=\"line\">            handle[KEY_LEFT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_RIGHT_NUMBER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_OPERATOR] = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            handle[KEY_ANSWER] = <span class=\"number\">0</span></span><br><span class=\"line\">            handle[KEY_CURRENT_SCORE] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getLeftNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_LEFT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRightNumber</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_RIGHT_NUMBER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getOperator</span><span class=\"params\">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_OPERATOR)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getHighScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_HIGH_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCurrentScore</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_CURRENT_SCORE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAnswer</span><span class=\"params\">()</span></span>: MutableLiveData&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle.getLiveData(KEY_ANSWER)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成算式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generator</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> level = <span class=\"number\">100</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> random = Random()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> x = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> y = random.nextInt(level) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;+&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x - y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y - x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getOperator().value = <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                getAnswer().value = x - y</span><br><span class=\"line\">                getLeftNumber().value = x</span><br><span class=\"line\">                getRightNumber().value = y</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                getAnswer().value = y - x</span><br><span class=\"line\">                getLeftNumber().value = y</span><br><span class=\"line\">                getRightNumber().value = x</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保存新纪录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">save</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> edit = spf.edit()</span><br><span class=\"line\">        getHighScore().value?.let &#123; edit.putInt(KEY_HIGH_SCORE, it) &#125;</span><br><span class=\"line\">        edit.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//答对处理</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">answerCorrect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentScore = getCurrentScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> highScore = getHighScore().value ?: <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> updatedCurrentScore = currentScore + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值最新得分结果</span></span><br><span class=\"line\">        getCurrentScore().value = updatedCurrentScore</span><br><span class=\"line\">        <span class=\"comment\">//如果超过最高分，就更新记录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (updatedCurrentScore &gt; highScore) &#123;</span><br><span class=\"line\">            getHighScore().value = updatedCurrentScore</span><br><span class=\"line\">            winFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generator()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>注：</code>AndroidViewModel 是 ViewModel 的一个子类，它专门用于与 Android 系统相关的操作，如访问 Application 的上下文（Context）和共享数据。通过继承 AndroidViewModel，我们可以在 MyViewModel 中获取到 Application 对象，并使用它来获取 SharedPreferences，实现数据的持久化存储。这里主要是保存最高纪录使用。</li>\n</ul>\n<h2 id=\"2-5-DataBinding\"><a href=\"#2-5-DataBinding\" class=\"headerlink\" title=\"2.5 DataBinding\"></a>2.5 DataBinding</h2><ul>\n<li>首先，将四个Fragment的布局界面都转化为 DataBinding 界面，并绑定ViewModel。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/27/o418kM.png\">\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">&quot;data&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.leihao.kotlinapp.calculation.viewmodel.MyViewModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-1-TitleFragment-页面\"><a href=\"#2-5-1-TitleFragment-页面\" class=\"headerlink\" title=\"2.5.1 TitleFragment 页面\"></a>2.5.1 TitleFragment 页面</h3><ul>\n<li>只有最高分需要用到 DataBinding，在布局文件对应最高分 TextView 控件中添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/high_score(data.highScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n其中，@string/high_score(data.highScore)的写法是为了和 strings.xml 中的：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;high_score&quot;</span>&gt;</span>历史最高分：%d<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br></pre></td></tr></table></figure>\n进行一个匹配，这样就无需关注字符串的拼接问题了，后面类似的地方也是这样处理的。</li>\n</ul>\n<h3 id=\"2-5-2-Question-页面\"><a href=\"#2-5-2-Question-页面\" class=\"headerlink\" title=\"2.5.2 Question 页面\"></a>2.5.2 Question 页面</h3><ul>\n<li>当前得分的 TextView 添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/current_score(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n右边数字，运算符，右边数字对应的 TextView 分别添加下面三项：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.leftNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;data.operator&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;String.valueOf(data.rightNumber)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-5-3-WinFragment-和-LoseFragment-页面\"><a href=\"#2-5-3-WinFragment-和-LoseFragment-页面\" class=\"headerlink\" title=\"2.5.3 WinFragment 和 LoseFragment 页面\"></a>2.5.3 WinFragment 和 LoseFragment 页面</h3><ul>\n<li>在分数对应的 TextView 中分别添加属性：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/win_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;@&#123;@string/lose_score_message(data.currentScore)&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>大功告成！现在就已经将界面和视图进行了一个绑定，当数据变化时，界面会自动观察到数据变化并做相应的更新。</li>\n</ul>\n<h2 id=\"2-6-功能完善\"><a href=\"#2-6-功能完善\" class=\"headerlink\" title=\"2.6 功能完善\"></a>2.6 功能完善</h2><ul>\n<li><p>接下来将各个页面的剩余功能完成。</p>\n</li>\n<li><p>TitleFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TitleFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentTitleBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentTitleBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        <span class=\"comment\">//去答题界面</span></span><br><span class=\"line\">        binding.btnBegin.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(view)</span><br><span class=\"line\">            navController.navigate(R.id.action_titleFragment_to_questionFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>QuestionFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QuestionFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentQuestionBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentQuestionBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成题目</span></span><br><span class=\"line\">        myViewModel.generator()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前分数置0</span></span><br><span class=\"line\">        myViewModel.getCurrentScore().value = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//显示输入的内容或者提示信息</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> builder = StringBuilder()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> listener = View.OnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (it.id) &#123;</span><br><span class=\"line\">                R.id.button0 -&gt; builder.append(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">                R.id.button1 -&gt; builder.append(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">                R.id.button2 -&gt; builder.append(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">                R.id.button3 -&gt; builder.append(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">                R.id.button4 -&gt; builder.append(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">                R.id.button5 -&gt; builder.append(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">                R.id.button6 -&gt; builder.append(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">                R.id.button7 -&gt; builder.append(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">                R.id.button8 -&gt; builder.append(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">                R.id.button9 -&gt; builder.append(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">                R.id.button_clear -&gt; builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isEmpty()) &#123;</span><br><span class=\"line\">                binding.textView10.text = getString(R.string.input_indicator)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                binding.textView10.text = builder.toString()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//提交答案</span></span><br><span class=\"line\">        binding.buttonSubmit.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (builder.isNotEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算正确</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.valueOf(builder.toString()).equals(myViewModel.getAnswer().value)) &#123;</span><br><span class=\"line\">                    myViewModel.answerCorrect()</span><br><span class=\"line\">                    builder.setLength(<span class=\"number\">0</span>)</span><br><span class=\"line\">                    binding.textView10.text = getString(R.string.answer_correct)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//计算错误</span></span><br><span class=\"line\">                    <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (myViewModel.winFlag) &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_winFragment)</span><br><span class=\"line\">                        myViewModel.winFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">                        myViewModel.save()</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        navController.navigate(R.id.action_questionFragment_to_loseFragment)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        binding.button0.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button1.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button2.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button3.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button4.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button5.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button6.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button7.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button8.setOnClickListener(listener)</span><br><span class=\"line\">        binding.button9.setOnClickListener(listener)</span><br><span class=\"line\">        binding.buttonClear.setOnClickListener(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>WinFragment 和 LoseFragment，二者几乎完全一致，所以只展示 WinFragment：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WinFragment</span> : <span class=\"type\">Fragment</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> binding: FragmentWinBinding</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//快速绑定ViewModel，如果是Fragment需要绑定activity级别的viewModel，避免使用了不同的viewModel导致数据不一致</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> myViewModel: MyViewModel <span class=\"keyword\">by</span> activityViewModels()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        inflater: <span class=\"type\">LayoutInflater</span>, container: <span class=\"type\">ViewGroup</span>?, savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: View &#123;</span><br><span class=\"line\">        binding = FragmentWinBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将 ViewModel 中的数据与布局文件进行绑定</span></span><br><span class=\"line\">        binding.<span class=\"keyword\">data</span> = myViewModel</span><br><span class=\"line\">        <span class=\"comment\">//设置 binding.lifecycleOwner，这样当 myViewModel 中的数据改变时就能及时更新到视图上。</span></span><br><span class=\"line\">        binding.lifecycleOwner = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binding.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.btnBack.setOnClickListener &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> navController = Navigation.findNavController(it)</span><br><span class=\"line\">            navController.navigate(R.id.action_winFragment_to_titleFragment)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>通过使用 ViewModel 帮我们管理数据，Navigation 帮我们管理页面，DataBinding 帮我们绑定视图和数据，我们很轻松的就实现了一个较为符合开发规范的应用。</li>\n<li>在 NavGraph 中，我们一眼就能看出整个应用的骨架，这对 Debug 或者新人熟悉项目都有非常大的益处！</li>\n</ul>\n"},{"title":"Room 组件使用示例","date":"2023-07-22T00:00:00.000Z","description":"Room 是 Android 中的一个持久性库，用于简化数据库的访问和管理。","cover":"https://www.helloimg.com/images/2023/07/22/oAQU7o.png","_content":"\n> Room 是 Jetpack 库中的组件之一，用于创建、存储和管理由 SQLite 数据库支持的持久性数据。\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- 为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。\n- 今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。\n- 简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","source":"_posts/安卓_06_Room.md","raw":"---\ntitle: 'Room 组件使用示例'\ndate: '2023-07-22'\ndescription: 'Room 是 Android 中的一个持久性库，用于简化数据库的访问和管理。'\ncover: 'https://www.helloimg.com/images/2023/07/22/oAQU7o.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Android\n- Jetpack\n- 数据库\n\n---\n\n> Room 是 Jetpack 库中的组件之一，用于创建、存储和管理由 SQLite 数据库支持的持久性数据。\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- 为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。\n- 今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。\n- 简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","slug":"安卓_06_Room","published":1,"updated":"2023-07-25T02:43:27.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyuf0014m7hohdza4o41","content":"<blockquote>\n<p>Room 是 Jetpack 库中的组件之一，用于创建、存储和管理由 SQLite 数据库支持的持久性数据。</p>\n</blockquote>\n<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。</li>\n<li>今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。</li>\n<li>简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>Room 是 Jetpack 库中的组件之一，用于创建、存储和管理由 SQLite 数据库支持的持久性数据。</p>\n</blockquote>\n<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>为了更简单的管理 SQLite 数据库，网上出现了很多持久层框架，比如最著名的 GreenDao；还有我前面文章讲过的 Ormlite，还有 SugarORM、ActiveAndroid 等等。</li>\n<li>今天要讲的这个 Room，目前安卓开发群体中用得相对较少，原因是他要和其他 Jetpack 组件一起使用才能发挥其最大优势，而现在 Jetpack 并未完全普及开来，也就导致了 Room 并未变得十分流行。</li>\n<li>简而言之，Room 提供了一个抽象层，使得使用 SQLite 数据库变得更简单、更可靠，并且提供了与其他 Jetpack 组件（如 LiveData 和 ViewModel）的集成。项目如果使用了大量的 Jetpack 组件进行开发，那么数据库管理这一块儿，使用 Room 再好不过。</li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n"},{"title":"搭建一个属于自己的 ChatGPT 镜像网站","date":"2023-06-08T00:00:00.000Z","description":"教程 - 如何部署自己的私人 ChatGPT 网站","cover":"https://www.helloimg.com/images/2023/06/09/osdDQu.webp","_content":"\n> 经过三周半的头脑风暴，前几天终于把工作任务做完了，也好久没写博客了，实在是不太想动脑。今天随便写个搭网站的教程吧，我也是跟着别人的教程一步一步走搭建完成的，其实还挺有趣，就当记录一下了。\n\n# 一、准备工作\n\n本教程选用 ChatGPT-Next-Web 项目，Vercel 部署，CloudFlare 进行域名管理与加速，所以需要提前准备好：\n 1. Github 账号。\n 2. Vercel 账号。\n 3. CloudFlare 账号。\n 4. OpenAI API KEY。\n 5. 一个域名。\n\n# 二、项目部署\n\n## 2.1 ChatGPT-Next-Web\n\n- 目前我接触过的比较好的两个开源项目，一个是[chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，一个是[ChatGPT-Next-Web](https://github.com/Yidadaa/ChatGPT-Next-Web)。\n- 两个项目我都尝试搭建过，chatgpt-web 的搭建相对更方便，使用 docker 一键部署，但是需要一台国外的云服务器。这就有点尴尬了，囊中羞涩，最后只能放弃了。\nchatgpt-web： \n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdIyv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\nChatGPT-Next-Web：\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osd8mE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- ChatGPT-Next-Web 流程相对复杂一丢丢，但相对更\"实惠\"一些，我们项目部署交给免费的 Vercel ，域名解析交给免费的 CloudFlare，这样一套乞丐级流程下来，全程只需要花一个买域名的钱，总花费7快多一点。\n\n<img src=\"https://www.helloimg.com/images/2023/06/08/oslmMu.jpg\"  width=\"30%\">\n\n## 2.2 Fork 项目\n\n- 从 GitHub 上 Fork [ChatGPT-Next-Web](https://github.com/Yidadaa/ChatGPT-Next-Web) 项目到个人仓库\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTOiv.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n## 2.3 Vercel 部署\n\n- [Vercel](https://vercel.com/) 可以直接以 GitHub 账号登录，然后点击`Add New Project`，选择 Project 从 Github 部署项目。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTws9.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 选择刚刚 Fork 的项目进行导入。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT0vX.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 配置参数，选择 Environment Variables 并添加两个环境变量参数：\n  1. `CODE` 代表网站的访问控制密码，密码不要忘了。\n  2. `OPENAI_API_KEY` 你的 OpenAI 账户的 Key。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT7K6.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 部署，点击`Deploy`按钮，等待部署成功即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdKcY.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 点击`Continue to DashBoard`按钮，查看部署信息。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdV8M.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n## 2.4 域名购买\n\n- 其实按道理说 Velcel 部署完成后就OK了。但是使用自动为我们分配好的域名 [chat-gpt-next-web-six-gold-73.vercel.app](https://chat-gpt-next-web-six-gold-73.vercel.app/) 被墙了，访问不了，所以我们得配置一下单独的域名解析。\n\n- 选择购买渠道。可以任意找一个域名供应商进行购买，这里推荐 [Namesilo](https://www.namesilo.com/) ，便宜没有坑，支付也非常方便。\n\n- 注册登录网站后，在搜索框搜索你想要申请的域名，点击`Add`添加到购物车(如果域名已经被注册是无法添加的)，点击`Checkout`进入付款页面。\n\n- 这里可以填写推荐码 `tree1024` 获得 1$ 的优惠。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdhS6.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\"> \n\n- 最后填写一些信息，然后选择支付宝付款即可。\n\n## 2.5 CF 域名管理\n\n- 将上面购买到的域名添加到 Cloudflare 中管理，点击`添加站点`按钮，输入域名。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdy5R.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 选择 Free 计划，点击`Continue`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvBdA.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 回到 [Namesilo](https://www.namesilo.com/)，右上角点`Manage My Domains`，然后会看到下图，先勾选你要解析的域名，再点`change Nameservers`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvPoc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 把 CloudFlare 中的名称服务器地址（athena.ns.cloudflare.com、jake.ns.cloudflare.com）填到 Namesilo 里然后保存，解析生效官方的说法是24小时，但一般半个小时之内就OK了。\n\n- 回到 [Vercel](https://vercel.com/) 中，点击项目右上角的`Domains`。添加我们刚才的购买的域名，会提示一同添加 www 开头的域名，按推荐添加即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvZ2m.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 最后回到 CloudFlare 中，点击检查名称服务器，检查通过会发一封邮件。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osves1.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 配置 SSL，点击左侧导航栏的`SSL/TSL`，选择`full`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvJeo.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 添加A 记录（可选）和 CNAME 记录，如果你想用根域名访问你的站点，比如 https://leihaochat.top，需要添加一条 A 记录，直接将根域名解析到 Vercel 的服务器地址（76.76.21.21）即可！\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvi5u.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 大功告成！试着访问一下你的网址(收到 CloudFlare 检查通过邮件之后)，可以顺利访问就代表你成功了！\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvnsv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n# 三、总结\n\n- 如果无法访问，着重检查自己的 CloudFlare 对`DNS`以及`SSL`的配置。\n- 总的来说步骤虽然多一点，但是都不复杂，也不会有什么奇奇怪怪的坑，只用花不到一顿饭钱的价格就可以拥有一个自己的ChatGPT网站，还是非常爽的！\n- 在部署好的网站的设置里面，有一个访问密码和API Key，访问密码即之前`2.3 Vercel 部署`中`CODE`的值，如果访问密码验证成功，就会消耗你配置的那个API Key，否则会优先使用下方配置的API Key。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvHvE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">","source":"_posts/杂谈_01_搭建一个属于自己的ChatGPT镜像网站.md","raw":"---\ntitle: '搭建一个属于自己的 ChatGPT 镜像网站'\ndate: '2023-06-08'\ndescription: '教程 - 如何部署自己的私人 ChatGPT 网站'\ncover: 'https://www.helloimg.com/images/2023/06/09/osdDQu.webp'\ncategories:\n\n- 杂谈\n\ntags:\n\n- ChatGPT\n\n---\n\n> 经过三周半的头脑风暴，前几天终于把工作任务做完了，也好久没写博客了，实在是不太想动脑。今天随便写个搭网站的教程吧，我也是跟着别人的教程一步一步走搭建完成的，其实还挺有趣，就当记录一下了。\n\n# 一、准备工作\n\n本教程选用 ChatGPT-Next-Web 项目，Vercel 部署，CloudFlare 进行域名管理与加速，所以需要提前准备好：\n 1. Github 账号。\n 2. Vercel 账号。\n 3. CloudFlare 账号。\n 4. OpenAI API KEY。\n 5. 一个域名。\n\n# 二、项目部署\n\n## 2.1 ChatGPT-Next-Web\n\n- 目前我接触过的比较好的两个开源项目，一个是[chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，一个是[ChatGPT-Next-Web](https://github.com/Yidadaa/ChatGPT-Next-Web)。\n- 两个项目我都尝试搭建过，chatgpt-web 的搭建相对更方便，使用 docker 一键部署，但是需要一台国外的云服务器。这就有点尴尬了，囊中羞涩，最后只能放弃了。\nchatgpt-web： \n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdIyv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\nChatGPT-Next-Web：\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osd8mE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- ChatGPT-Next-Web 流程相对复杂一丢丢，但相对更\"实惠\"一些，我们项目部署交给免费的 Vercel ，域名解析交给免费的 CloudFlare，这样一套乞丐级流程下来，全程只需要花一个买域名的钱，总花费7快多一点。\n\n<img src=\"https://www.helloimg.com/images/2023/06/08/oslmMu.jpg\"  width=\"30%\">\n\n## 2.2 Fork 项目\n\n- 从 GitHub 上 Fork [ChatGPT-Next-Web](https://github.com/Yidadaa/ChatGPT-Next-Web) 项目到个人仓库\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTOiv.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n## 2.3 Vercel 部署\n\n- [Vercel](https://vercel.com/) 可以直接以 GitHub 账号登录，然后点击`Add New Project`，选择 Project 从 Github 部署项目。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTws9.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 选择刚刚 Fork 的项目进行导入。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT0vX.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 配置参数，选择 Environment Variables 并添加两个环境变量参数：\n  1. `CODE` 代表网站的访问控制密码，密码不要忘了。\n  2. `OPENAI_API_KEY` 你的 OpenAI 账户的 Key。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT7K6.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 部署，点击`Deploy`按钮，等待部署成功即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdKcY.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 点击`Continue to DashBoard`按钮，查看部署信息。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdV8M.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n## 2.4 域名购买\n\n- 其实按道理说 Velcel 部署完成后就OK了。但是使用自动为我们分配好的域名 [chat-gpt-next-web-six-gold-73.vercel.app](https://chat-gpt-next-web-six-gold-73.vercel.app/) 被墙了，访问不了，所以我们得配置一下单独的域名解析。\n\n- 选择购买渠道。可以任意找一个域名供应商进行购买，这里推荐 [Namesilo](https://www.namesilo.com/) ，便宜没有坑，支付也非常方便。\n\n- 注册登录网站后，在搜索框搜索你想要申请的域名，点击`Add`添加到购物车(如果域名已经被注册是无法添加的)，点击`Checkout`进入付款页面。\n\n- 这里可以填写推荐码 `tree1024` 获得 1$ 的优惠。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdhS6.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\"> \n\n- 最后填写一些信息，然后选择支付宝付款即可。\n\n## 2.5 CF 域名管理\n\n- 将上面购买到的域名添加到 Cloudflare 中管理，点击`添加站点`按钮，输入域名。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdy5R.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 选择 Free 计划，点击`Continue`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvBdA.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 回到 [Namesilo](https://www.namesilo.com/)，右上角点`Manage My Domains`，然后会看到下图，先勾选你要解析的域名，再点`change Nameservers`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvPoc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 把 CloudFlare 中的名称服务器地址（athena.ns.cloudflare.com、jake.ns.cloudflare.com）填到 Namesilo 里然后保存，解析生效官方的说法是24小时，但一般半个小时之内就OK了。\n\n- 回到 [Vercel](https://vercel.com/) 中，点击项目右上角的`Domains`。添加我们刚才的购买的域名，会提示一同添加 www 开头的域名，按推荐添加即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvZ2m.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 最后回到 CloudFlare 中，点击检查名称服务器，检查通过会发一封邮件。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osves1.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 配置 SSL，点击左侧导航栏的`SSL/TSL`，选择`full`。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvJeo.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 添加A 记录（可选）和 CNAME 记录，如果你想用根域名访问你的站点，比如 https://leihaochat.top，需要添加一条 A 记录，直接将根域名解析到 Vercel 的服务器地址（76.76.21.21）即可！\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvi5u.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 大功告成！试着访问一下你的网址(收到 CloudFlare 检查通过邮件之后)，可以顺利访问就代表你成功了！\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvnsv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n# 三、总结\n\n- 如果无法访问，着重检查自己的 CloudFlare 对`DNS`以及`SSL`的配置。\n- 总的来说步骤虽然多一点，但是都不复杂，也不会有什么奇奇怪怪的坑，只用花不到一顿饭钱的价格就可以拥有一个自己的ChatGPT网站，还是非常爽的！\n- 在部署好的网站的设置里面，有一个访问密码和API Key，访问密码即之前`2.3 Vercel 部署`中`CODE`的值，如果访问密码验证成功，就会消耗你配置的那个API Key，否则会优先使用下方配置的API Key。\n\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvHvE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">","slug":"杂谈_01_搭建一个属于自己的ChatGPT镜像网站","published":1,"updated":"2023-07-20T01:15:45.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyuh0018m7ho42ac65hm","content":"<blockquote>\n<p>经过三周半的头脑风暴，前几天终于把工作任务做完了，也好久没写博客了，实在是不太想动脑。今天随便写个搭网站的教程吧，我也是跟着别人的教程一步一步走搭建完成的，其实还挺有趣，就当记录一下了。</p>\n</blockquote>\n<h1 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h1><p>本教程选用 ChatGPT-Next-Web 项目，Vercel 部署，CloudFlare 进行域名管理与加速，所以需要提前准备好：</p>\n<ol>\n<li>Github 账号。</li>\n<li>Vercel 账号。</li>\n<li>CloudFlare 账号。</li>\n<li>OpenAI API KEY。</li>\n<li>一个域名。</li>\n</ol>\n<h1 id=\"二、项目部署\"><a href=\"#二、项目部署\" class=\"headerlink\" title=\"二、项目部署\"></a>二、项目部署</h1><h2 id=\"2-1-ChatGPT-Next-Web\"><a href=\"#2-1-ChatGPT-Next-Web\" class=\"headerlink\" title=\"2.1 ChatGPT-Next-Web\"></a>2.1 ChatGPT-Next-Web</h2><ul>\n<li>目前我接触过的比较好的两个开源项目，一个是<a href=\"https://github.com/Chanzhaoyu/chatgpt-web\">chatgpt-web</a>，一个是<a href=\"https://github.com/Yidadaa/ChatGPT-Next-Web\">ChatGPT-Next-Web</a>。</li>\n<li>两个项目我都尝试搭建过，chatgpt-web 的搭建相对更方便，使用 docker 一键部署，但是需要一台国外的云服务器。这就有点尴尬了，囊中羞涩，最后只能放弃了。<br>chatgpt-web： </li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdIyv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<p>ChatGPT-Next-Web：</p>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osd8mE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>ChatGPT-Next-Web 流程相对复杂一丢丢，但相对更”实惠”一些，我们项目部署交给免费的 Vercel ，域名解析交给免费的 CloudFlare，这样一套乞丐级流程下来，全程只需要花一个买域名的钱，总花费7快多一点。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/08/oslmMu.jpg\"  width=\"30%\">\n\n<h2 id=\"2-2-Fork-项目\"><a href=\"#2-2-Fork-项目\" class=\"headerlink\" title=\"2.2 Fork 项目\"></a>2.2 Fork 项目</h2><ul>\n<li>从 GitHub 上 Fork <a href=\"https://github.com/Yidadaa/ChatGPT-Next-Web\">ChatGPT-Next-Web</a> 项目到个人仓库</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTOiv.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h2 id=\"2-3-Vercel-部署\"><a href=\"#2-3-Vercel-部署\" class=\"headerlink\" title=\"2.3 Vercel 部署\"></a>2.3 Vercel 部署</h2><ul>\n<li><a href=\"https://vercel.com/\">Vercel</a> 可以直接以 GitHub 账号登录，然后点击<code>Add New Project</code>，选择 Project 从 Github 部署项目。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTws9.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>选择刚刚 Fork 的项目进行导入。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT0vX.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>配置参数，选择 Environment Variables 并添加两个环境变量参数：<ol>\n<li><code>CODE</code> 代表网站的访问控制密码，密码不要忘了。</li>\n<li><code>OPENAI_API_KEY</code> 你的 OpenAI 账户的 Key。</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT7K6.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>部署，点击<code>Deploy</code>按钮，等待部署成功即可。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdKcY.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>点击<code>Continue to DashBoard</code>按钮，查看部署信息。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdV8M.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h2 id=\"2-4-域名购买\"><a href=\"#2-4-域名购买\" class=\"headerlink\" title=\"2.4 域名购买\"></a>2.4 域名购买</h2><ul>\n<li><p>其实按道理说 Velcel 部署完成后就OK了。但是使用自动为我们分配好的域名 <a href=\"https://chat-gpt-next-web-six-gold-73.vercel.app/\">chat-gpt-next-web-six-gold-73.vercel.app</a> 被墙了，访问不了，所以我们得配置一下单独的域名解析。</p>\n</li>\n<li><p>选择购买渠道。可以任意找一个域名供应商进行购买，这里推荐 <a href=\"https://www.namesilo.com/\">Namesilo</a> ，便宜没有坑，支付也非常方便。</p>\n</li>\n<li><p>注册登录网站后，在搜索框搜索你想要申请的域名，点击<code>Add</code>添加到购物车(如果域名已经被注册是无法添加的)，点击<code>Checkout</code>进入付款页面。</p>\n</li>\n<li><p>这里可以填写推荐码 <code>tree1024</code> 获得 1$ 的优惠。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdhS6.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\"> \n\n<ul>\n<li>最后填写一些信息，然后选择支付宝付款即可。</li>\n</ul>\n<h2 id=\"2-5-CF-域名管理\"><a href=\"#2-5-CF-域名管理\" class=\"headerlink\" title=\"2.5 CF 域名管理\"></a>2.5 CF 域名管理</h2><ul>\n<li>将上面购买到的域名添加到 Cloudflare 中管理，点击<code>添加站点</code>按钮，输入域名。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdy5R.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>选择 Free 计划，点击<code>Continue</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvBdA.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>回到 <a href=\"https://www.namesilo.com/\">Namesilo</a>，右上角点<code>Manage My Domains</code>，然后会看到下图，先勾选你要解析的域名，再点<code>change Nameservers</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvPoc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li><p>把 CloudFlare 中的名称服务器地址（athena.ns.cloudflare.com、jake.ns.cloudflare.com）填到 Namesilo 里然后保存，解析生效官方的说法是24小时，但一般半个小时之内就OK了。</p>\n</li>\n<li><p>回到 <a href=\"https://vercel.com/\">Vercel</a> 中，点击项目右上角的<code>Domains</code>。添加我们刚才的购买的域名，会提示一同添加 www 开头的域名，按推荐添加即可。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvZ2m.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>最后回到 CloudFlare 中，点击检查名称服务器，检查通过会发一封邮件。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osves1.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>配置 SSL，点击左侧导航栏的<code>SSL/TSL</code>，选择<code>full</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvJeo.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>添加A 记录（可选）和 CNAME 记录，如果你想用根域名访问你的站点，比如 <a href=\"https://leihaochat.top,需要添加一条/\">https://leihaochat.top，需要添加一条</a> A 记录，直接将根域名解析到 Vercel 的服务器地址（76.76.21.21）即可！</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvi5u.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>大功告成！试着访问一下你的网址(收到 CloudFlare 检查通过邮件之后)，可以顺利访问就代表你成功了！</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvnsv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>如果无法访问，着重检查自己的 CloudFlare 对<code>DNS</code>以及<code>SSL</code>的配置。</li>\n<li>总的来说步骤虽然多一点，但是都不复杂，也不会有什么奇奇怪怪的坑，只用花不到一顿饭钱的价格就可以拥有一个自己的ChatGPT网站，还是非常爽的！</li>\n<li>在部署好的网站的设置里面，有一个访问密码和API Key，访问密码即之前<code>2.3 Vercel 部署</code>中<code>CODE</code>的值，如果访问密码验证成功，就会消耗你配置的那个API Key，否则会优先使用下方配置的API Key。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvHvE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>经过三周半的头脑风暴，前几天终于把工作任务做完了，也好久没写博客了，实在是不太想动脑。今天随便写个搭网站的教程吧，我也是跟着别人的教程一步一步走搭建完成的，其实还挺有趣，就当记录一下了。</p>\n</blockquote>\n<h1 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h1><p>本教程选用 ChatGPT-Next-Web 项目，Vercel 部署，CloudFlare 进行域名管理与加速，所以需要提前准备好：</p>\n<ol>\n<li>Github 账号。</li>\n<li>Vercel 账号。</li>\n<li>CloudFlare 账号。</li>\n<li>OpenAI API KEY。</li>\n<li>一个域名。</li>\n</ol>\n<h1 id=\"二、项目部署\"><a href=\"#二、项目部署\" class=\"headerlink\" title=\"二、项目部署\"></a>二、项目部署</h1><h2 id=\"2-1-ChatGPT-Next-Web\"><a href=\"#2-1-ChatGPT-Next-Web\" class=\"headerlink\" title=\"2.1 ChatGPT-Next-Web\"></a>2.1 ChatGPT-Next-Web</h2><ul>\n<li>目前我接触过的比较好的两个开源项目，一个是<a href=\"https://github.com/Chanzhaoyu/chatgpt-web\">chatgpt-web</a>，一个是<a href=\"https://github.com/Yidadaa/ChatGPT-Next-Web\">ChatGPT-Next-Web</a>。</li>\n<li>两个项目我都尝试搭建过，chatgpt-web 的搭建相对更方便，使用 docker 一键部署，但是需要一台国外的云服务器。这就有点尴尬了，囊中羞涩，最后只能放弃了。<br>chatgpt-web： </li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdIyv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<p>ChatGPT-Next-Web：</p>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osd8mE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>ChatGPT-Next-Web 流程相对复杂一丢丢，但相对更”实惠”一些，我们项目部署交给免费的 Vercel ，域名解析交给免费的 CloudFlare，这样一套乞丐级流程下来，全程只需要花一个买域名的钱，总花费7快多一点。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/08/oslmMu.jpg\"  width=\"30%\">\n\n<h2 id=\"2-2-Fork-项目\"><a href=\"#2-2-Fork-项目\" class=\"headerlink\" title=\"2.2 Fork 项目\"></a>2.2 Fork 项目</h2><ul>\n<li>从 GitHub 上 Fork <a href=\"https://github.com/Yidadaa/ChatGPT-Next-Web\">ChatGPT-Next-Web</a> 项目到个人仓库</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTOiv.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h2 id=\"2-3-Vercel-部署\"><a href=\"#2-3-Vercel-部署\" class=\"headerlink\" title=\"2.3 Vercel 部署\"></a>2.3 Vercel 部署</h2><ul>\n<li><a href=\"https://vercel.com/\">Vercel</a> 可以直接以 GitHub 账号登录，然后点击<code>Add New Project</code>，选择 Project 从 Github 部署项目。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osTws9.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>选择刚刚 Fork 的项目进行导入。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT0vX.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>配置参数，选择 Environment Variables 并添加两个环境变量参数：<ol>\n<li><code>CODE</code> 代表网站的访问控制密码，密码不要忘了。</li>\n<li><code>OPENAI_API_KEY</code> 你的 OpenAI 账户的 Key。</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osT7K6.jpg\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>部署，点击<code>Deploy</code>按钮，等待部署成功即可。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdKcY.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>点击<code>Continue to DashBoard</code>按钮，查看部署信息。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdV8M.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h2 id=\"2-4-域名购买\"><a href=\"#2-4-域名购买\" class=\"headerlink\" title=\"2.4 域名购买\"></a>2.4 域名购买</h2><ul>\n<li><p>其实按道理说 Velcel 部署完成后就OK了。但是使用自动为我们分配好的域名 <a href=\"https://chat-gpt-next-web-six-gold-73.vercel.app/\">chat-gpt-next-web-six-gold-73.vercel.app</a> 被墙了，访问不了，所以我们得配置一下单独的域名解析。</p>\n</li>\n<li><p>选择购买渠道。可以任意找一个域名供应商进行购买，这里推荐 <a href=\"https://www.namesilo.com/\">Namesilo</a> ，便宜没有坑，支付也非常方便。</p>\n</li>\n<li><p>注册登录网站后，在搜索框搜索你想要申请的域名，点击<code>Add</code>添加到购物车(如果域名已经被注册是无法添加的)，点击<code>Checkout</code>进入付款页面。</p>\n</li>\n<li><p>这里可以填写推荐码 <code>tree1024</code> 获得 1$ 的优惠。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdhS6.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\"> \n\n<ul>\n<li>最后填写一些信息，然后选择支付宝付款即可。</li>\n</ul>\n<h2 id=\"2-5-CF-域名管理\"><a href=\"#2-5-CF-域名管理\" class=\"headerlink\" title=\"2.5 CF 域名管理\"></a>2.5 CF 域名管理</h2><ul>\n<li>将上面购买到的域名添加到 Cloudflare 中管理，点击<code>添加站点</code>按钮，输入域名。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osdy5R.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>选择 Free 计划，点击<code>Continue</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvBdA.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>回到 <a href=\"https://www.namesilo.com/\">Namesilo</a>，右上角点<code>Manage My Domains</code>，然后会看到下图，先勾选你要解析的域名，再点<code>change Nameservers</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvPoc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li><p>把 CloudFlare 中的名称服务器地址（athena.ns.cloudflare.com、jake.ns.cloudflare.com）填到 Namesilo 里然后保存，解析生效官方的说法是24小时，但一般半个小时之内就OK了。</p>\n</li>\n<li><p>回到 <a href=\"https://vercel.com/\">Vercel</a> 中，点击项目右上角的<code>Domains</code>。添加我们刚才的购买的域名，会提示一同添加 www 开头的域名，按推荐添加即可。</p>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvZ2m.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>最后回到 CloudFlare 中，点击检查名称服务器，检查通过会发一封邮件。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osves1.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>配置 SSL，点击左侧导航栏的<code>SSL/TSL</code>，选择<code>full</code>。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvJeo.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>添加A 记录（可选）和 CNAME 记录，如果你想用根域名访问你的站点，比如 <a href=\"https://leihaochat.top,需要添加一条/\">https://leihaochat.top，需要添加一条</a> A 记录，直接将根域名解析到 Vercel 的服务器地址（76.76.21.21）即可！</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvi5u.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>大功告成！试着访问一下你的网址(收到 CloudFlare 检查通过邮件之后)，可以顺利访问就代表你成功了！</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvnsv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><ul>\n<li>如果无法访问，着重检查自己的 CloudFlare 对<code>DNS</code>以及<code>SSL</code>的配置。</li>\n<li>总的来说步骤虽然多一点，但是都不复杂，也不会有什么奇奇怪怪的坑，只用花不到一顿饭钱的价格就可以拥有一个自己的ChatGPT网站，还是非常爽的！</li>\n<li>在部署好的网站的设置里面，有一个访问密码和API Key，访问密码即之前<code>2.3 Vercel 部署</code>中<code>CODE</code>的值，如果访问密码验证成功，就会消耗你配置的那个API Key，否则会优先使用下方配置的API Key。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/09/osvHvE.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">"},{"title":"如何使用 Vercel 部署自己的 Hexo 博客","date":"2023-06-10T00:00:00.000Z","description":"教程 - 将自己的 Blog 使用Velcel进行部署，告别 Github Pages 的卡顿","cover":"https://www.helloimg.com/images/2023/06/10/osNX56.png","_content":"\n> 这几天摆弄 ChatGPT 的镜像站，时常接触到 Vercel，发现这玩意儿真挺好用，至少访问速度方面来说是绝对优于 Github Pages的，因此，我也打算将 Blog 重新部署一下，换到 Vercel 上。\n\n# 一、GitHub Pages 部署回顾\n\n- 先看一下之前是怎样部署的，首先在 Hexo 的配置文件`_config.yml`中，修改 deploy 项，type 填写 git，repo 即你的博客仓库地址，branch 是你要部署博客的分支\n- 以我的为例：\n```text\ndeploy:\n  type: git\n  repo: https://github.com/leihaogit/leihaogit\n  branch: gh-pages\n```\n- 分支名字其实无所谓，但是为了统一规范一般都叫这个名字。\n- `说明`：博客实体就是 hexo generate 生成的内容，长这样：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNAih.jpg\"  width=\"50%\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 其实就是博客项目生成的`public`文件夹，里面包括了我们这个静态网站的所有内容。\n- 我们在执行`hexo generate`时，会生成当前项目对应的 public 文件夹，然后执行`hexo deploy`时，会将生成的 public 文件夹推送至你配置文件配置的那个仓库的指定分支。\n- 最后在 Github Pages 管理页面选择`gh-pages`分支进行部署即可。\n\n# 二、Vercel 部署 - 直接部署\n\n- 通过上面的说明，可以看出，其实我们需要的只有`public`文件夹而已。因此我们可以删除配置文件中的 gh-pages 和对应的仓库分支。这样的话部署完成后，仓库里面是这样的：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNMeK.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 然后直接像部署一个普通的静态网站一样，部署到 Vercel 就行了。\n步骤如下：\n  1. 在 Vercel 中点击`Add New Project`，选择 Project 从 Github 部署项目，然后导入你的博客仓库：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  2. `Framework Preset`就选择`Other`即可。`Root Directory`默认，不用更改。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNNfv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  3. 点击`Deploy`，等待部署完成即可。\n  4. 其实到这里就可以访问`仓库名.vercel.app`了，但是由于 vercel.app 被墙，所以我们需要配置一下 Domains 了，这个留在后面一起说。\n- 我个人不太喜欢这种部署方式，万一哪天电脑坏了，你没有将项目上传到仓库，你就只剩下一个博客了，想再编辑就很麻烦，所以最好还是使用下面介绍的方式进行部署。\n\n# 三、Vercel 部署 - 使用预设框架\n\n- 在上面直接部署的步骤2中，`Framework Preset`其实有个选项就是 Hexo，也就是说，其实 Vercel 是能够直接使用 Hexo 的预设模板进行项目部署的。\n步骤如下：\n  1. 在 Vercel 中点击`Add New Project`，选择 Project 从 Github 部署项目，然后导入你的博客仓库：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  2. `Framework Preset`选择`Hexo`。`Root Directory`默认，不用更改。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNyHm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  3. 点击`Deploy`，等待部署完成即可。\n  4. 部署完成后，点击`Continue to DashBoard`按钮，查看部署信息。再点击右上角`Domains`，输入自己的域名，点击`Add`。点击之后会提示一同添加带 www 的域名，按推荐添加即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQagb.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  5. 之后会提示你去 DNS 提供商上设置 A 记录或者 CNAME 记录：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQwIm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  6. 直接按他提示的，我们前往域名提供商，添加一个 A 记录即可，CNAME 记录当然也是可以的。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQQAc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  7. 回到 Vercel，发现重定向成功！访问网站也没有问题。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQpNq.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n# 四、总结\n\n- 总的来说，部署是很简单的，告别了之前卡顿的GitHub Pages，体验也会好上不少！\n- 除了访问更流畅，现在我们每次写完博客，也不需要再执行`Hexo deploy`了，只要我们将代码上传至仓库，Vercel 就会自动帮我们完成更新部署工作。","source":"_posts/杂谈_02_如何使用Vercel部署自己的Hexo博客.md","raw":"---\ntitle: '如何使用 Vercel 部署自己的 Hexo 博客'\ndate: '2023-06-10'\ndescription: '教程 - 将自己的 Blog 使用Velcel进行部署，告别 Github Pages 的卡顿'\ncover: 'https://www.helloimg.com/images/2023/06/10/osNX56.png'\ncategories:\n\n- 杂谈\n\ntags:\n\n- Blog\n\n---\n\n> 这几天摆弄 ChatGPT 的镜像站，时常接触到 Vercel，发现这玩意儿真挺好用，至少访问速度方面来说是绝对优于 Github Pages的，因此，我也打算将 Blog 重新部署一下，换到 Vercel 上。\n\n# 一、GitHub Pages 部署回顾\n\n- 先看一下之前是怎样部署的，首先在 Hexo 的配置文件`_config.yml`中，修改 deploy 项，type 填写 git，repo 即你的博客仓库地址，branch 是你要部署博客的分支\n- 以我的为例：\n```text\ndeploy:\n  type: git\n  repo: https://github.com/leihaogit/leihaogit\n  branch: gh-pages\n```\n- 分支名字其实无所谓，但是为了统一规范一般都叫这个名字。\n- `说明`：博客实体就是 hexo generate 生成的内容，长这样：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNAih.jpg\"  width=\"50%\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 其实就是博客项目生成的`public`文件夹，里面包括了我们这个静态网站的所有内容。\n- 我们在执行`hexo generate`时，会生成当前项目对应的 public 文件夹，然后执行`hexo deploy`时，会将生成的 public 文件夹推送至你配置文件配置的那个仓库的指定分支。\n- 最后在 Github Pages 管理页面选择`gh-pages`分支进行部署即可。\n\n# 二、Vercel 部署 - 直接部署\n\n- 通过上面的说明，可以看出，其实我们需要的只有`public`文件夹而已。因此我们可以删除配置文件中的 gh-pages 和对应的仓库分支。这样的话部署完成后，仓库里面是这样的：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNMeK.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n- 然后直接像部署一个普通的静态网站一样，部署到 Vercel 就行了。\n步骤如下：\n  1. 在 Vercel 中点击`Add New Project`，选择 Project 从 Github 部署项目，然后导入你的博客仓库：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  2. `Framework Preset`就选择`Other`即可。`Root Directory`默认，不用更改。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNNfv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  3. 点击`Deploy`，等待部署完成即可。\n  4. 其实到这里就可以访问`仓库名.vercel.app`了，但是由于 vercel.app 被墙，所以我们需要配置一下 Domains 了，这个留在后面一起说。\n- 我个人不太喜欢这种部署方式，万一哪天电脑坏了，你没有将项目上传到仓库，你就只剩下一个博客了，想再编辑就很麻烦，所以最好还是使用下面介绍的方式进行部署。\n\n# 三、Vercel 部署 - 使用预设框架\n\n- 在上面直接部署的步骤2中，`Framework Preset`其实有个选项就是 Hexo，也就是说，其实 Vercel 是能够直接使用 Hexo 的预设模板进行项目部署的。\n步骤如下：\n  1. 在 Vercel 中点击`Add New Project`，选择 Project 从 Github 部署项目，然后导入你的博客仓库：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  2. `Framework Preset`选择`Hexo`。`Root Directory`默认，不用更改。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNyHm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  3. 点击`Deploy`，等待部署完成即可。\n  4. 部署完成后，点击`Continue to DashBoard`按钮，查看部署信息。再点击右上角`Domains`，输入自己的域名，点击`Add`。点击之后会提示一同添加带 www 的域名，按推荐添加即可。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQagb.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  5. 之后会提示你去 DNS 提供商上设置 A 记录或者 CNAME 记录：\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQwIm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  6. 直接按他提示的，我们前往域名提供商，添加一个 A 记录即可，CNAME 记录当然也是可以的。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQQAc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n  7. 回到 Vercel，发现重定向成功！访问网站也没有问题。\n\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQpNq.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n# 四、总结\n\n- 总的来说，部署是很简单的，告别了之前卡顿的GitHub Pages，体验也会好上不少！\n- 除了访问更流畅，现在我们每次写完博客，也不需要再执行`Hexo deploy`了，只要我们将代码上传至仓库，Vercel 就会自动帮我们完成更新部署工作。","slug":"杂谈_02_如何使用Vercel部署自己的Hexo博客","published":1,"updated":"2023-07-20T01:15:27.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyui001am7hoga4c73iz","content":"<blockquote>\n<p>这几天摆弄 ChatGPT 的镜像站，时常接触到 Vercel，发现这玩意儿真挺好用，至少访问速度方面来说是绝对优于 Github Pages的，因此，我也打算将 Blog 重新部署一下，换到 Vercel 上。</p>\n</blockquote>\n<h1 id=\"一、GitHub-Pages-部署回顾\"><a href=\"#一、GitHub-Pages-部署回顾\" class=\"headerlink\" title=\"一、GitHub Pages 部署回顾\"></a>一、GitHub Pages 部署回顾</h1><ul>\n<li>先看一下之前是怎样部署的，首先在 Hexo 的配置文件<code>_config.yml</code>中，修改 deploy 项，type 填写 git，repo 即你的博客仓库地址，branch 是你要部署博客的分支</li>\n<li>以我的为例：<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/leihaogit/leihaogit</span><br><span class=\"line\">  branch: gh-pages</span><br></pre></td></tr></table></figure></li>\n<li>分支名字其实无所谓，但是为了统一规范一般都叫这个名字。</li>\n<li><code>说明</code>：博客实体就是 hexo generate 生成的内容，长这样：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNAih.jpg\"  width=\"50%\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>其实就是博客项目生成的<code>public</code>文件夹，里面包括了我们这个静态网站的所有内容。</li>\n<li>我们在执行<code>hexo generate</code>时，会生成当前项目对应的 public 文件夹，然后执行<code>hexo deploy</code>时，会将生成的 public 文件夹推送至你配置文件配置的那个仓库的指定分支。</li>\n<li>最后在 Github Pages 管理页面选择<code>gh-pages</code>分支进行部署即可。</li>\n</ul>\n<h1 id=\"二、Vercel-部署-直接部署\"><a href=\"#二、Vercel-部署-直接部署\" class=\"headerlink\" title=\"二、Vercel 部署 - 直接部署\"></a>二、Vercel 部署 - 直接部署</h1><ul>\n<li>通过上面的说明，可以看出，其实我们需要的只有<code>public</code>文件夹而已。因此我们可以删除配置文件中的 gh-pages 和对应的仓库分支。这样的话部署完成后，仓库里面是这样的：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNMeK.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>然后直接像部署一个普通的静态网站一样，部署到 Vercel 就行了。<br>步骤如下：<ol>\n<li>在 Vercel 中点击<code>Add New Project</code>，选择 Project 从 Github 部署项目，然后导入你的博客仓库：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"2\">\n<li><code>Framework Preset</code>就选择<code>Other</code>即可。<code>Root Directory</code>默认，不用更改。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNNfv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"3\">\n<li>点击<code>Deploy</code>，等待部署完成即可。</li>\n<li>其实到这里就可以访问<code>仓库名.vercel.app</code>了，但是由于 vercel.app 被墙，所以我们需要配置一下 Domains 了，这个留在后面一起说。</li>\n</ol>\n<ul>\n<li>我个人不太喜欢这种部署方式，万一哪天电脑坏了，你没有将项目上传到仓库，你就只剩下一个博客了，想再编辑就很麻烦，所以最好还是使用下面介绍的方式进行部署。</li>\n</ul>\n<h1 id=\"三、Vercel-部署-使用预设框架\"><a href=\"#三、Vercel-部署-使用预设框架\" class=\"headerlink\" title=\"三、Vercel 部署 - 使用预设框架\"></a>三、Vercel 部署 - 使用预设框架</h1><ul>\n<li>在上面直接部署的步骤2中，<code>Framework Preset</code>其实有个选项就是 Hexo，也就是说，其实 Vercel 是能够直接使用 Hexo 的预设模板进行项目部署的。<br>步骤如下：<ol>\n<li>在 Vercel 中点击<code>Add New Project</code>，选择 Project 从 Github 部署项目，然后导入你的博客仓库：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"2\">\n<li><code>Framework Preset</code>选择<code>Hexo</code>。<code>Root Directory</code>默认，不用更改。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNyHm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"3\">\n<li>点击<code>Deploy</code>，等待部署完成即可。</li>\n<li>部署完成后，点击<code>Continue to DashBoard</code>按钮，查看部署信息。再点击右上角<code>Domains</code>，输入自己的域名，点击<code>Add</code>。点击之后会提示一同添加带 www 的域名，按推荐添加即可。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQagb.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"5\">\n<li>之后会提示你去 DNS 提供商上设置 A 记录或者 CNAME 记录：</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQwIm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"6\">\n<li>直接按他提示的，我们前往域名提供商，添加一个 A 记录即可，CNAME 记录当然也是可以的。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQQAc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"7\">\n<li>回到 Vercel，发现重定向成功！访问网站也没有问题。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQpNq.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总的来说，部署是很简单的，告别了之前卡顿的GitHub Pages，体验也会好上不少！</li>\n<li>除了访问更流畅，现在我们每次写完博客，也不需要再执行<code>Hexo deploy</code>了，只要我们将代码上传至仓库，Vercel 就会自动帮我们完成更新部署工作。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>这几天摆弄 ChatGPT 的镜像站，时常接触到 Vercel，发现这玩意儿真挺好用，至少访问速度方面来说是绝对优于 Github Pages的，因此，我也打算将 Blog 重新部署一下，换到 Vercel 上。</p>\n</blockquote>\n<h1 id=\"一、GitHub-Pages-部署回顾\"><a href=\"#一、GitHub-Pages-部署回顾\" class=\"headerlink\" title=\"一、GitHub Pages 部署回顾\"></a>一、GitHub Pages 部署回顾</h1><ul>\n<li>先看一下之前是怎样部署的，首先在 Hexo 的配置文件<code>_config.yml</code>中，修改 deploy 项，type 填写 git，repo 即你的博客仓库地址，branch 是你要部署博客的分支</li>\n<li>以我的为例：<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/leihaogit/leihaogit</span><br><span class=\"line\">  branch: gh-pages</span><br></pre></td></tr></table></figure></li>\n<li>分支名字其实无所谓，但是为了统一规范一般都叫这个名字。</li>\n<li><code>说明</code>：博客实体就是 hexo generate 生成的内容，长这样：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNAih.jpg\"  width=\"50%\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>其实就是博客项目生成的<code>public</code>文件夹，里面包括了我们这个静态网站的所有内容。</li>\n<li>我们在执行<code>hexo generate</code>时，会生成当前项目对应的 public 文件夹，然后执行<code>hexo deploy</code>时，会将生成的 public 文件夹推送至你配置文件配置的那个仓库的指定分支。</li>\n<li>最后在 Github Pages 管理页面选择<code>gh-pages</code>分支进行部署即可。</li>\n</ul>\n<h1 id=\"二、Vercel-部署-直接部署\"><a href=\"#二、Vercel-部署-直接部署\" class=\"headerlink\" title=\"二、Vercel 部署 - 直接部署\"></a>二、Vercel 部署 - 直接部署</h1><ul>\n<li>通过上面的说明，可以看出，其实我们需要的只有<code>public</code>文件夹而已。因此我们可以删除配置文件中的 gh-pages 和对应的仓库分支。这样的话部署完成后，仓库里面是这样的：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNMeK.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ul>\n<li>然后直接像部署一个普通的静态网站一样，部署到 Vercel 就行了。<br>步骤如下：<ol>\n<li>在 Vercel 中点击<code>Add New Project</code>，选择 Project 从 Github 部署项目，然后导入你的博客仓库：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"2\">\n<li><code>Framework Preset</code>就选择<code>Other</code>即可。<code>Root Directory</code>默认，不用更改。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNNfv.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"3\">\n<li>点击<code>Deploy</code>，等待部署完成即可。</li>\n<li>其实到这里就可以访问<code>仓库名.vercel.app</code>了，但是由于 vercel.app 被墙，所以我们需要配置一下 Domains 了，这个留在后面一起说。</li>\n</ol>\n<ul>\n<li>我个人不太喜欢这种部署方式，万一哪天电脑坏了，你没有将项目上传到仓库，你就只剩下一个博客了，想再编辑就很麻烦，所以最好还是使用下面介绍的方式进行部署。</li>\n</ul>\n<h1 id=\"三、Vercel-部署-使用预设框架\"><a href=\"#三、Vercel-部署-使用预设框架\" class=\"headerlink\" title=\"三、Vercel 部署 - 使用预设框架\"></a>三、Vercel 部署 - 使用预设框架</h1><ul>\n<li>在上面直接部署的步骤2中，<code>Framework Preset</code>其实有个选项就是 Hexo，也就是说，其实 Vercel 是能够直接使用 Hexo 的预设模板进行项目部署的。<br>步骤如下：<ol>\n<li>在 Vercel 中点击<code>Add New Project</code>，选择 Project 从 Github 部署项目，然后导入你的博客仓库：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNvBQ.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"2\">\n<li><code>Framework Preset</code>选择<code>Hexo</code>。<code>Root Directory</code>默认，不用更改。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osNyHm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"3\">\n<li>点击<code>Deploy</code>，等待部署完成即可。</li>\n<li>部署完成后，点击<code>Continue to DashBoard</code>按钮，查看部署信息。再点击右上角<code>Domains</code>，输入自己的域名，点击<code>Add</code>。点击之后会提示一同添加带 www 的域名，按推荐添加即可。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQagb.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"5\">\n<li>之后会提示你去 DNS 提供商上设置 A 记录或者 CNAME 记录：</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQwIm.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"6\">\n<li>直接按他提示的，我们前往域名提供商，添加一个 A 记录即可，CNAME 记录当然也是可以的。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQQAc.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<ol start=\"7\">\n<li>回到 Vercel，发现重定向成功！访问网站也没有问题。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/06/10/osQpNq.png\" style=\"border: 0.1px solid #00BFFF; border-radius: 5px;\">\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总的来说，部署是很简单的，告别了之前卡顿的GitHub Pages，体验也会好上不少！</li>\n<li>除了访问更流畅，现在我们每次写完博客，也不需要再执行<code>Hexo deploy</code>了，只要我们将代码上传至仓库，Vercel 就会自动帮我们完成更新部署工作。</li>\n</ul>\n"},{"title":"ViewPager 与 ViewPager2 的使用示例","date":"2023-08-15T00:00:00.000Z","description":"介绍如何使用 ViewPager + BottomNavigationView 实现底部导航，ViewPager2 + TabLayout 实现顶部导航。","cover":"https://www.helloimg.com/images/2023/08/15/oSFPMc.png","_content":"\n> 当涉及到在 Android 应用中实现页面切换和导航功能时，ViewPager 和 ViewPager2 是非常有用的组件。\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- ViewPager 和 ViewPager2 看名字也知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用，在 JetPack 开发者文档中，是这么描述的：\n\n<img src=\"https://www.helloimg.com/images/2023/08/15/oSFa8q.png\">\n\n- \n\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","source":"_posts/安卓_07_ViewPager和ViewPager2的使用.md","raw":"---\ntitle: 'ViewPager 与 ViewPager2 的使用示例'\ndate: '2023-08-15'\ndescription: '介绍如何使用 ViewPager + BottomNavigationView 实现底部导航，ViewPager2 + TabLayout 实现顶部导航。'\ncover: 'https://www.helloimg.com/images/2023/08/15/oSFPMc.png'\ncategories:\n\n- 编程开发\n\ntags:\n\n- Kotlin\n- Jetpack\n- Android\n\n---\n\n> 当涉及到在 Android 应用中实现页面切换和导航功能时，ViewPager 和 ViewPager2 是非常有用的组件。\n\n# 一、概念及组成部分\n\n## 1.1 概念\n\n- ViewPager 和 ViewPager2 看名字也知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用，在 JetPack 开发者文档中，是这么描述的：\n\n<img src=\"https://www.helloimg.com/images/2023/08/15/oSFa8q.png\">\n\n- \n\n\n## 1.2 组成部分\n\n   1. `实体（Entity）`：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。\n   2. `数据访问对象（DAO）`：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。\n   3. `数据库对象（Database）`：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。\n   4. `仓库（Repository）`：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。\n   5. `视图模型（ViewModel）`：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。\n\n# 二、基本使用\n\n## 2.1 导入依赖\n\n- 在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。\n\n```groovy\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    //添加 kotlin-kapt 插件\n    id 'kotlin-kapt'\n}\ndependencies {\n    //添加主依赖\n    implementation 'androidx.room:room-runtime:2.4.2'\n    //添加处理注解的依赖\n    kapt 'androidx.room:room-compiler:2.4.2'\n}\n```\n- `注：`kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。\n\n## 2.2 创建实体类（Entity）\n\n```kotlin\n@Entity\nclass Word {\n    \n    @PrimaryKey(autoGenerate = true)\n    var id = 0\n\n    @ColumnInfo(name = \"english_word\")\n    var word: String\n    \n    @ColumnInfo(name = \"chinese_meaning\")\n    var chineseMeaning: String\n\n    //根据自己的需求添加构造器\n    constructor(word: String, chineseMeaning: String) {\n        this.word = word\n        this.chineseMeaning = chineseMeaning\n    }\n\n}\n```\n\n- `注：`使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。\n\n## 2.3 创建数据访问对象（DAO）\n\n```kotlin\n@Dao\ninterface WordDao {\n\n    @Insert //vararg  word: Word 这里表示参数数量不定\n    fun insertWords(vararg word: Word)\n\n    @Update\n    fun updateWords(vararg word: Word)\n\n    @Delete\n    fun deleteWords(vararg word: Word)\n\n    @Query(\"delete from word\")\n    fun deleteAllWords()\n\n    @Query(\"select * from word order by id desc\")\n    fun getAllWordsLive(): LiveData<List<Word>>\n\n}\n```\n\n- `注：`@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。\n\n## 2.4 创建数据库对象（Database）\n\n```kotlin\n@Database(entities = [Word::class], version = 1, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- `注：`这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。\n\n## 2.5 创建仓库（Repository）\n\n```kotlin\nclass WordRepository(context: Context) {\n\n    // 获取数据库实例\n    private val wordDatabase = WordDatabase.getInstance(context)\n\n    private val wordDao = wordDatabase.getWordDao()\n\n    val allWordsLive = wordDao.getAllWordsLive()\n\n    fun insertWords(vararg word: Word) {\n        InsertAsyncTask(wordDao).execute(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        UpdateAsyncTask(wordDao).execute(*word)\n    }\n\n\n    fun deleteWords(vararg word: Word) {\n        DeleteAsyncTask(wordDao).execute(*word)\n    }\n\n    fun deleteAllWords() {\n        DeleteAllAsyncTask(wordDao).execute()\n    }\n\n\n    //插入\n    class InsertAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.insertWords(*words)\n            return null\n        }\n\n    }\n\n    //清空\n    class DeleteAllAsyncTask(private val wordDao: WordDao) : AsyncTask<Unit, Unit, Unit>() {\n\n        override fun doInBackground(vararg unit: Unit): Unit? {\n            wordDao.deleteAllWords()\n            return null\n        }\n\n    }\n\n    //删除\n    class DeleteAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.deleteWords(*words)\n            return null\n        }\n\n    }\n\n    //更新\n    class UpdateAsyncTask(private val wordDao: WordDao) : AsyncTask<Word, Unit, Unit>() {\n\n        override fun doInBackground(vararg words: Word): Unit? {\n            wordDao.updateWords(*words)\n            return null\n        }\n\n    }\n\n}\n```\n\n- `注：`上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加`.allowMainThreadQueries()`，即允许在主线程进行数据库操作。\n\n## 2.6 创建视图模型（ViewModel）\n\n```kotlin\nclass WordViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val wordRepository = WordRepository(application)\n\n    fun getAllWordsLive():LiveData<List<Word>> {\n        return wordRepository.allWordsLive\n    }\n\n    fun insertWords(vararg word: Word) {\n        wordRepository.insertWords(*word)\n    }\n\n    fun updateWords(vararg word: Word) {\n        wordRepository.updateWords(*word)\n    }\n\n    fun deleteWords(vararg word: Word) {\n        wordRepository.deleteWords(*word)\n    }\n\n    fun deleteAllWords() {\n        wordRepository.deleteAllWords()\n    }\n\n}\n```\n\n- `注：`这里选择继承`AndroidViewModel`而不是直接继承`ViewModel`是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。\n\n## 2.7 测试\n\n- 在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：\n\n```kotlin\n        //插入\n        binding.btnInsert.setOnClickListener {\n            val english = arrayOf(\"hello\", \"world\", \"google\", \"pear\", \"apple\")\n            val chinese = arrayOf(\"你好\", \"世界\", \"谷歌\", \"梨\", \"苹果\")\n            for (i in english.indices) {\n                wordViewModel.insertWords(Word(english[i], chinese[i]))\n            }\n        }\n\n```\n\n- 这样数据库中就插入了 5 条数据。\n\n# 三、版本迁移\n\n- 由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。\n- 假如我们的数据库 word 表需要新增一个字段`bar_data`（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：\n\n```kotlin\n    @ColumnInfo(name = \"bar_data\")\n    var barData: Boolean = false\n```\n\n- 然后修改我们的 WordDatabase：\n\n```kotlin\n@Database(entities = [Word::class], version = 2, exportSchema = false)\nabstract class WordDatabase : RoomDatabase() {\n\n    //伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性\n    companion object {\n        // 单例实例\n        @Volatile\n        private var INSTANCE: WordDatabase? = null\n\n        // 获取单例实例的方法\n        //.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级\n        fun getInstance(context: Context): WordDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext, WordDatabase::class.java, \"word_database\"\n                )//.fallbackToDestructiveMigration()\n                    .addMigrations(Migration_1_2).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n\n      //自定义迁移逻辑（新增bar_data字段）\n      private val Migration_1_2 = object : Migration(1, 2) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0\")\n        }\n      }\n\n      //自定义迁移逻辑（删除bar_data字段）\n      private val Migration_2_3 = object : Migration(2, 3) {\n        override fun migrate(database: SupportSQLiteDatabase) {\n          database.execSQL(\"create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)\")\n          database.execSQL(\n            \"insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word\"\n          )\n          database.execSQL(\"drop table word\")\n          database.execSQL(\"alter table word_tmp rename to word\")\n        }\n      }\n    }\n\n    abstract fun getWordDao(): WordDao\n    \n}\n```\n\n- 主要注意几点：\n  1. 更改`version = 2`，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。\n  2. 创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。\n  3. 将我们创建好的迁移逻辑通过`.addMigrations()`方法添加进 databaseBuilder。\n- 上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即`破坏式迁移`，这种迁移方式并不推荐，知道就可以了。\n\n# 四、总结\n\n- 总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。","slug":"安卓_07_ViewPager和ViewPager2的使用","published":1,"updated":"2023-08-15T01:00:55.797Z","_id":"cllblkyuk001em7hodcnr2qa6","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>当涉及到在 Android 应用中实现页面切换和导航功能时，ViewPager 和 ViewPager2 是非常有用的组件。</p>\n</blockquote>\n<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>ViewPager 和 ViewPager2 看名字也知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用，在 JetPack 开发者文档中，是这么描述的：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/08/15/oSFa8q.png\">\n\n<ul>\n<li></li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>当涉及到在 Android 应用中实现页面切换和导航功能时，ViewPager 和 ViewPager2 是非常有用的组件。</p>\n</blockquote>\n<h1 id=\"一、概念及组成部分\"><a href=\"#一、概念及组成部分\" class=\"headerlink\" title=\"一、概念及组成部分\"></a>一、概念及组成部分</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ul>\n<li>ViewPager 和 ViewPager2 看名字也知道是一代和二代的关系，他们一同被添加到 JetPack 组件库中，不过一代目前已经不推荐使用，在 JetPack 开发者文档中，是这么描述的：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/08/15/oSFa8q.png\">\n\n<ul>\n<li></li>\n</ul>\n<h2 id=\"1-2-组成部分\"><a href=\"#1-2-组成部分\" class=\"headerlink\" title=\"1.2 组成部分\"></a>1.2 组成部分</h2><ol>\n<li><code>实体（Entity）</code>：实体是数据库表的映射对象。通过在类上添加 @Entity 注解，可以将类声明为一个实体，并指定表名、主键和列等信息。</li>\n<li><code>数据访问对象（DAO）</code>：数据访问对象是用于定义数据库操作方法的接口或抽象类。通过在方法上添加注解（如 @Insert、@Delete、@Query 等），可以指定对数据库的插入、删除和查询等操作。</li>\n<li><code>数据库对象（Database）</code>：数据库对象是 Room 的核心组件，用于管理应用程序的整个数据库。通过创建一个继承自 RoomDatabase 的抽象类，并指定其中的实体和版本等信息，可以定义一个数据库对象。数据库对象还通过提供 DAO 的抽象方法，允许应用程序对数据库执行各种操作。</li>\n<li><code>仓库（Repository）</code>：处理数据源和业务逻辑，Repository 是连接数据访问对象（DAO）和视图模型/用户界面之间的中间层，负责从数据库获取数据并向上层提供数据。</li>\n<li><code>视图模型（ViewModel）</code>：用于管理应用程序的数据和业务逻辑。它通常与 LiveData 一起使用，可以将业务逻辑和 UI 组件进行解耦，使得数据持久性和业务逻辑不受 UI 生命周期的影响。</li>\n</ol>\n<h1 id=\"二、基本使用\"><a href=\"#二、基本使用\" class=\"headerlink\" title=\"二、基本使用\"></a>二、基本使用</h1><h2 id=\"2-1-导入依赖\"><a href=\"#2-1-导入依赖\" class=\"headerlink\" title=\"2.1 导入依赖\"></a>2.1 导入依赖</h2><ul>\n<li>在项目的 build.gradle 文件中添加 Room 的依赖项。并确保你已经在 repositories 部分添加了 Google 仓库。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-android&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加 kotlin-kapt 插件</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;kotlin-kapt&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加主依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;androidx.room:room-runtime:2.4.2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//添加处理注解的依赖</span></span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;androidx.room:room-compiler:2.4.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>注：</code>kotlin-kapt 是 Kotlin 语言中的一个插件，它用于处理 Kotlin 注解处理器（KAPT）。KAPT 允许在编译时生成额外的代码，通常用于自动生成代码、实现依赖注入或数据库操作等。</li>\n</ul>\n<h2 id=\"2-2-创建实体类（Entity）\"><a href=\"#2-2-创建实体类（Entity）\" class=\"headerlink\" title=\"2.2 创建实体类（Entity）\"></a>2.2 创建实体类（Entity）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Word</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PrimaryKey(autoGenerate = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;english_word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> word: String</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;chinese_meaning&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chineseMeaning: String</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据自己的需求添加构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(word: String, chineseMeaning: String) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.word = word</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chineseMeaning = chineseMeaning</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>使用 @Entity 注解创建一个用于映射数据库表的实体类。如果使用 Kotlin 编写不需要写 getter 和 setter 方法。@ColumnInfo 直接使用，这样数据库里面的字段名称就是你定义的变量名称。</li>\n</ul>\n<h2 id=\"2-3-创建数据访问对象（DAO）\"><a href=\"#2-3-创建数据访问对象（DAO）\" class=\"headerlink\" title=\"2.3 创建数据访问对象（DAO）\"></a>2.3 创建数据访问对象（DAO）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Dao</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WordDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span> <span class=\"comment\">//vararg  word: Word 这里表示参数数量不定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;delete from word&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Query(<span class=\"string\">&quot;select * from word order by id desc&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>@Insert、@Update、@Delete 分别用于插入、更新和删除数据库中的数据，这个看名字就能看出来；@Query 用于执行自定义查询语句，用的比较多。</li>\n</ul>\n<h2 id=\"2-4-创建数据库对象（Database）\"><a href=\"#2-4-创建数据库对象（Database）\" class=\"headerlink\" title=\"2.4 创建数据库对象（Database）\"></a>2.4 创建数据库对象（Database）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 1, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                ).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里采用了单例模式，保证全局只有一个 WordDatabase 对象，避免数据库资源的浪费和多线程并发访问的问题。如果有多个 Dao 对象，在 @Database 注解的 entities 数组中添加即可。</li>\n</ul>\n<h2 id=\"2-5-创建仓库（Repository）\"><a href=\"#2-5-创建仓库（Repository）\" class=\"headerlink\" title=\"2.5 创建仓库（Repository）\"></a>2.5 创建仓库（Repository）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordRepository</span>(context: Context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据库实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDatabase = WordDatabase.getInstance(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao = wordDatabase.getWordDao()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> allWordsLive = wordDao.getAllWordsLive()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        InsertAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        UpdateAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        DeleteAsyncTask(wordDao).execute(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        DeleteAllAsyncTask(wordDao).execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插入</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">InsertAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.insertWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAllAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;<span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> unit: <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteAllWords()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DeleteAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.deleteWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">UpdateAsyncTask</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordDao: WordDao) : AsyncTask&lt;Word, <span class=\"built_in\">Unit</span>, <span class=\"built_in\">Unit</span>&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doInBackground</span><span class=\"params\">(<span class=\"keyword\">vararg</span> words: <span class=\"type\">Word</span>)</span></span>: <span class=\"built_in\">Unit</span>? &#123;</span><br><span class=\"line\">            wordDao.updateWords(*words)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>上面对于数据库的操作全部放在了异步子线程中，这是 Room 默认的规定，如果直接在主线程进行数据库操作会直接异常。但如果你确实想直接在主线程中进行操作，需要在创建 Database 的 databaseBuilder 处添加<code>.allowMainThreadQueries()</code>，即允许在主线程进行数据库操作。</li>\n</ul>\n<h2 id=\"2-6-创建视图模型（ViewModel）\"><a href=\"#2-6-创建视图模型（ViewModel）\" class=\"headerlink\" title=\"2.6 创建视图模型（ViewModel）\"></a>2.6 创建视图模型（ViewModel）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WordViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wordRepository = WordRepository(application)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllWordsLive</span><span class=\"params\">()</span></span>:LiveData&lt;List&lt;Word&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordRepository.allWordsLive</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insertWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.insertWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">updateWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.updateWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteWords</span><span class=\"params\">(<span class=\"keyword\">vararg</span> word: <span class=\"type\">Word</span>)</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteWords(*word)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deleteAllWords</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wordRepository.deleteAllWords()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>注：</code>这里选择继承<code>AndroidViewModel</code>而不是直接继承<code>ViewModel</code>是因为我们需要用到上下文对象 application，同时，AndroidViewModel 与 Activity 或 Fragment 的生命周期无关，可以避免内存泄漏。</li>\n</ul>\n<h2 id=\"2-7-测试\"><a href=\"#2-7-测试\" class=\"headerlink\" title=\"2.7 测试\"></a>2.7 测试</h2><ul>\n<li>在 Activity 或者 Fragment 中，我们直接调用 ViewModel 中的相关方法即可，比如我要插入几条数据：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\">binding.btnInsert.setOnClickListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> english = arrayOf(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;google&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> chinese = arrayOf(<span class=\"string\">&quot;你好&quot;</span>, <span class=\"string\">&quot;世界&quot;</span>, <span class=\"string\">&quot;谷歌&quot;</span>, <span class=\"string\">&quot;梨&quot;</span>, <span class=\"string\">&quot;苹果&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> english.indices) &#123;</span><br><span class=\"line\">        wordViewModel.insertWords(Word(english[i], chinese[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这样数据库中就插入了 5 条数据。</li>\n</ul>\n<h1 id=\"三、版本迁移\"><a href=\"#三、版本迁移\" class=\"headerlink\" title=\"三、版本迁移\"></a>三、版本迁移</h1><ul>\n<li>由于数据库的结构变化，导致需要进行数据库版本升级和数据迁移，而这两件事一直以来都是比较麻烦的。这里我们演示一下在 Room 如何进行一个简单的数据库升级操作。</li>\n<li>假如我们的数据库 word 表需要新增一个字段<code>bar_data</code>（删除字段所做的操作会复杂一些，代码中也有示例），我们首先需要做的是在 Word 实体类中增加一个属性：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ColumnInfo(name = <span class=\"string\">&quot;bar_data&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> barData: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后修改我们的 WordDatabase：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = [Word::class], version = 2, exportSchema = false)</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WordDatabase</span> : <span class=\"type\">RoomDatabase</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//伴生对象，里面的方法可以视为Java中的静态方法，属性可以视为静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单例实例</span></span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> INSTANCE: WordDatabase? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取单例实例的方法</span></span><br><span class=\"line\">        <span class=\"comment\">//.fallbackToDestructiveMigration()表示破坏式迁移，不会保留以前的数据，更改数据库结构及版本号后添加这个可以实现版本升级</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getInstance</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: WordDatabase &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> INSTANCE ?: synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> instance = Room.databaseBuilder(</span><br><span class=\"line\">                    context.applicationContext, WordDatabase::<span class=\"keyword\">class</span>.java, <span class=\"string\">&quot;word_database&quot;</span></span><br><span class=\"line\">                )<span class=\"comment\">//.fallbackToDestructiveMigration()</span></span><br><span class=\"line\">                    .addMigrations(Migration_1_2).build()</span><br><span class=\"line\">                INSTANCE = instance</span><br><span class=\"line\">                instance</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（新增bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_1_2 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;Alter table word ADD COLUMN bar_data INTEGER NOT null Default 0&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//自定义迁移逻辑（删除bar_data字段）</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> Migration_2_3 = <span class=\"keyword\">object</span> : Migration(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">migrate</span><span class=\"params\">(database: <span class=\"type\">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;create table word_tmp (id INTEGER primary key not null,english_word TEXT not null,chinese_meaning TEXT not null)&quot;</span>)</span><br><span class=\"line\">          database.execSQL(</span><br><span class=\"line\">            <span class=\"string\">&quot;insert into word_tmp (id,english_word,chinese_meaning) select id,english_word,chinese_meaning from word&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;drop table word&quot;</span>)</span><br><span class=\"line\">          database.execSQL(<span class=\"string\">&quot;alter table word_tmp rename to word&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getWordDao</span><span class=\"params\">()</span></span>: WordDao</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要注意几点：<ol>\n<li>更改<code>version = 2</code>，如果实体类出现变化，必须更改数据库版本号，否则会出现异常。</li>\n<li>创建一个 Migration_1_2 对象，也就是我们的自定义迁移逻辑，在里面执行我们的数据库相关操作。</li>\n<li>将我们创建好的迁移逻辑通过<code>.addMigrations()</code>方法添加进 databaseBuilder。</li>\n</ol>\n</li>\n<li>上面就实现了一个最简单的数据库升级方法，可以不销毁目前用户数据的情况下进行数据库版本升级，可以看到代码中还有另一种方式，即<code>破坏式迁移</code>，这种迁移方式并不推荐，知道就可以了。</li>\n</ul>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>总之，Room 数据库是一个优秀的工具，帮助开发人员有效地管理和操作本地数据，从而提升应用程序的性能和用户体验。无论是小型应用还是大型项目，使用 Room 数据库都是一个值得考虑的选择。</li>\n</ul>\n"},{"title":"下一个更大元素","date":"2023-04-28T00:00:00.000Z","description":"使用单调栈辅助解决 Next Greater Element 问题","cover":"https://www.helloimg.com/images/2023/05/03/oqwbMt.webp","_content":"\n> 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍一个基于栈数据结构的算法——单调栈。\n\n# 一、栈和单调栈\n\n## 1.1 栈\n\n- 定义：栈就是一种只允许在一端进行插入或删除操作的线性表。\n- 特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。\n- stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。\n- 与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。\n\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n## 1.2 单调栈\n\n- 定义：单调栈（Monotonic Stack）是一种特殊的栈，它具有保持栈内元素单调递增或递减的特点。在使用单调栈解决算法问题时，往往需要先将数据压入栈中，然后进行适当的操作来维护栈的单调性。\n- 特点：与普通的栈不同的是，单调栈在插入和删除时，需要先判断是否需要将栈内元素进行弹出，以维护栈的单调性质。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWUzt.webp\">\n\n# 二、问题与思路\n\n## 2.1 题目\n\n**下一个更大元素 I**\n\n- nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\n  给你两个没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。\n  对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，\n  并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是-1。\n  返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/next-greater-element-i\n\n例子：\n\n- 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n  输出：[-1,3,-1]\n  解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,**4**,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [**1**,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,**2**]。不存在下一个更大元素，所以答案是 -1 。\n\n我觉得原题目描述得很混乱，我们重新捋一下题目：\n\n- 给定两个数组 nums1 和 nums2，其中 nums1 是 nums2 的子集，且两个数组均不包含重复元素。\n- 对于 nums1 中的每个元素 x，在 nums2 中找到其右侧第一个比它大的元素，将这个下一个更大元素存储在数组 ans 中返回。如果不存在这样的下一个更大元素，则将 -1 存储在 ans 中的相应位置。\n\n## 2.2 思路一：暴力法\n\n- 首先，清楚题意之后会觉得题目并不难，看起来两次遍历就能解决问题，正所谓暴力法能解决的问题那都不是问题。\n- 所以这里直接放出来暴力模拟算法的代码：\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int[] ans = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            ans[i] = -1;//先假设不存在后一个最大元素\n            boolean b = false;//判断是否找到了目标元素\n            for (int j = 0; j < nums2.length; j++) {\n                if (nums2[j] == nums1[i]) {//到达了目标元素位置\n                    b = true;\n                }\n                if (b && (nums2[j] > nums1[i])) {//存在后一个最大元素，将答案数组对应位置赋值\n                    ans[i] = nums2[j];\n                    break;//结束本次循环\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n时间复杂度不用说肯定是 **O(n^2)** 了，在数据量大的时候，效率是很差的。\n\n## 2.3 思路二：单调栈\n\n有没有复杂度不那么高的算法呢？如果是 **O(n) 或者 O(m + n)** 级别那就再好不过了。\n答案是有的，不过需要一个家伙来辅助我们 —— `单调栈`。\n\n- 在前面已经提到过单调栈的概念，即：一种单调递增或递减的特殊栈。\n- 单调栈非常适合用来解决这道题目。主要步骤如下：\n    1. 创建一个哈希表 map，用于存储每个元素的下一个更大元素。\n    2. 创建一个单调栈 stack。\n    3. 从 nums2 的尾部开始遍历，对于遍历到的每个元素 num，执行以下操作：\n       a. 如果栈顶元素比当前元素 num 小或等于 num，则弹出栈顶元素，直到栈顶元素比 num 大或者栈为空。\n       b. 将当前元素 num 加入栈中。\n       c. 如果栈为空，则说明当前元素没有下一个更大元素，将其对应的 value 设为 -1；否则，取出栈顶元素，将其作为当前元素的下一个更大元素。\n    4. 遍历 nums1 数组，使用哈希表 map 找到 nums1 中每个元素的下一个更大元素。\n\n我们来举个例子走完上面的步骤，这样更有助于理解：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n`假设 nums1 = [4, 1, 2]，nums2 = [1, 3, 4, 2]，我们想找到 nums1 中每个元素的下一个更大元素。`\n\n- 第一步：创建哈希表和单调栈\n\n```java\n        map={}\n        stack=[]\n```\n\n- 第二步：遍历 nums2，从 nums2 的尾部开始遍历。\n    - i = 3，num = 2，当前 stack 为空，map 设为 {2: -1}，stack 变成 [2]\n    - i = 2，num = 4，当前 stack 为 [2]，4 比栈顶元素 2 大，因此弹出 2，并将 map 设为 {2: -1, 4: -1}，stack 变成 [4]\n    - i = 1，num = 3，当前 stack 为 [4]，3 比栈顶元素 4 小，因此将 3 加入栈中，map 设为 {2: -1, 4: 3, 3: 4}，stack 变成 [4, 3]\n    - i = 0，num = 1，当前 stack 为 [4, 3]，1 比栈顶元素 3 小，因此将 1 加入栈中，map 设为 {1: 3, 2: -1, 4: 3, 3: 4}，stack 变成 [4, 3, 1]\n      最终得到的 map 为 {1: 3, 2: -1, 4: 3, 3: 4}，表示 nums2 中每个元素的下一个更大元素。\n\n- 第三步：遍历 nums1\n    - 对于 4，map 中对应的是 3\n    - 对于 1，map 中对应的是 3\n    - 对于 2，map 中对应的是 -1\n      因此，最终得到的 res 数组为 [3, 3, -1]，即 nums1 中每个元素的下一个更大元素。\n\n# 三、题解\n\n有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // 创建哈希表，用于存储每个元素的下一个更大元素\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        // 创建单调栈\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        // 从 nums2 的尾部开始遍历\n        for (int i = nums2.length - 1; i >= 0; --i) {\n            int num = nums2[i];\n            // 如果当前元素比栈顶元素大，则栈顶元素的下一个更大元素就是当前元素\n            while (!stack.isEmpty() && num >= stack.peek()) {\n                stack.pop();\n            }\n            // 将当前元素加入栈中\n            // 如果栈为空，说明当前元素没有下一个更大元素，将其对应的 value 设为 -1\n            map.put(num, stack.isEmpty() ? -1 : stack.peek());\n            stack.push(num);\n        }\n        // 遍历 nums1，使用哈希表找到 nums1 中每个元素的下一个更大元素\n        int[] res = new int[nums1.length];\n        for (int i = 0; i < nums1.length; ++i) {\n            res[i] = map.get(nums1[i]);\n        }\n        return res;\n    }\n}\n```\n\n# 四、总结\n\n- 本文介绍了一个基于栈数据结构的算法——单调栈，并使用 LeetCode 上的一道题目来说明了单调栈的使用场景和实现方法。通过对暴力枚举算法和单调栈算法的对比，我们可以看出单调栈算法在时间复杂度上有较大优势（O(m + n)）。\n- 在实际编程中，如果遇到类似\"Next Greater Element\"这样的问题时，可以优先考虑单调栈算法的使用。","source":"_posts/栈_01_下一个更大元素.md","raw":"---\ntitle: '下一个更大元素'\ndate: '2023-04-28'\ndescription: '使用单调栈辅助解决 Next Greater Element 问题'\ncover: 'https://www.helloimg.com/images/2023/05/03/oqwbMt.webp'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 栈\n\n---\n\n> 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍一个基于栈数据结构的算法——单调栈。\n\n# 一、栈和单调栈\n\n## 1.1 栈\n\n- 定义：栈就是一种只允许在一端进行插入或删除操作的线性表。\n- 特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。\n- stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。\n- 与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。\n\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n## 1.2 单调栈\n\n- 定义：单调栈（Monotonic Stack）是一种特殊的栈，它具有保持栈内元素单调递增或递减的特点。在使用单调栈解决算法问题时，往往需要先将数据压入栈中，然后进行适当的操作来维护栈的单调性。\n- 特点：与普通的栈不同的是，单调栈在插入和删除时，需要先判断是否需要将栈内元素进行弹出，以维护栈的单调性质。\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWUzt.webp\">\n\n# 二、问题与思路\n\n## 2.1 题目\n\n**下一个更大元素 I**\n\n- nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\n  给你两个没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。\n  对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，\n  并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是-1。\n  返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/next-greater-element-i\n\n例子：\n\n- 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n  输出：[-1,3,-1]\n  解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,**4**,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [**1**,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,**2**]。不存在下一个更大元素，所以答案是 -1 。\n\n我觉得原题目描述得很混乱，我们重新捋一下题目：\n\n- 给定两个数组 nums1 和 nums2，其中 nums1 是 nums2 的子集，且两个数组均不包含重复元素。\n- 对于 nums1 中的每个元素 x，在 nums2 中找到其右侧第一个比它大的元素，将这个下一个更大元素存储在数组 ans 中返回。如果不存在这样的下一个更大元素，则将 -1 存储在 ans 中的相应位置。\n\n## 2.2 思路一：暴力法\n\n- 首先，清楚题意之后会觉得题目并不难，看起来两次遍历就能解决问题，正所谓暴力法能解决的问题那都不是问题。\n- 所以这里直接放出来暴力模拟算法的代码：\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int[] ans = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            ans[i] = -1;//先假设不存在后一个最大元素\n            boolean b = false;//判断是否找到了目标元素\n            for (int j = 0; j < nums2.length; j++) {\n                if (nums2[j] == nums1[i]) {//到达了目标元素位置\n                    b = true;\n                }\n                if (b && (nums2[j] > nums1[i])) {//存在后一个最大元素，将答案数组对应位置赋值\n                    ans[i] = nums2[j];\n                    break;//结束本次循环\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n时间复杂度不用说肯定是 **O(n^2)** 了，在数据量大的时候，效率是很差的。\n\n## 2.3 思路二：单调栈\n\n有没有复杂度不那么高的算法呢？如果是 **O(n) 或者 O(m + n)** 级别那就再好不过了。\n答案是有的，不过需要一个家伙来辅助我们 —— `单调栈`。\n\n- 在前面已经提到过单调栈的概念，即：一种单调递增或递减的特殊栈。\n- 单调栈非常适合用来解决这道题目。主要步骤如下：\n    1. 创建一个哈希表 map，用于存储每个元素的下一个更大元素。\n    2. 创建一个单调栈 stack。\n    3. 从 nums2 的尾部开始遍历，对于遍历到的每个元素 num，执行以下操作：\n       a. 如果栈顶元素比当前元素 num 小或等于 num，则弹出栈顶元素，直到栈顶元素比 num 大或者栈为空。\n       b. 将当前元素 num 加入栈中。\n       c. 如果栈为空，则说明当前元素没有下一个更大元素，将其对应的 value 设为 -1；否则，取出栈顶元素，将其作为当前元素的下一个更大元素。\n    4. 遍历 nums1 数组，使用哈希表 map 找到 nums1 中每个元素的下一个更大元素。\n\n我们来举个例子走完上面的步骤，这样更有助于理解：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n`假设 nums1 = [4, 1, 2]，nums2 = [1, 3, 4, 2]，我们想找到 nums1 中每个元素的下一个更大元素。`\n\n- 第一步：创建哈希表和单调栈\n\n```java\n        map={}\n        stack=[]\n```\n\n- 第二步：遍历 nums2，从 nums2 的尾部开始遍历。\n    - i = 3，num = 2，当前 stack 为空，map 设为 {2: -1}，stack 变成 [2]\n    - i = 2，num = 4，当前 stack 为 [2]，4 比栈顶元素 2 大，因此弹出 2，并将 map 设为 {2: -1, 4: -1}，stack 变成 [4]\n    - i = 1，num = 3，当前 stack 为 [4]，3 比栈顶元素 4 小，因此将 3 加入栈中，map 设为 {2: -1, 4: 3, 3: 4}，stack 变成 [4, 3]\n    - i = 0，num = 1，当前 stack 为 [4, 3]，1 比栈顶元素 3 小，因此将 1 加入栈中，map 设为 {1: 3, 2: -1, 4: 3, 3: 4}，stack 变成 [4, 3, 1]\n      最终得到的 map 为 {1: 3, 2: -1, 4: 3, 3: 4}，表示 nums2 中每个元素的下一个更大元素。\n\n- 第三步：遍历 nums1\n    - 对于 4，map 中对应的是 3\n    - 对于 1，map 中对应的是 3\n    - 对于 2，map 中对应的是 -1\n      因此，最终得到的 res 数组为 [3, 3, -1]，即 nums1 中每个元素的下一个更大元素。\n\n# 三、题解\n\n有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // 创建哈希表，用于存储每个元素的下一个更大元素\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        // 创建单调栈\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        // 从 nums2 的尾部开始遍历\n        for (int i = nums2.length - 1; i >= 0; --i) {\n            int num = nums2[i];\n            // 如果当前元素比栈顶元素大，则栈顶元素的下一个更大元素就是当前元素\n            while (!stack.isEmpty() && num >= stack.peek()) {\n                stack.pop();\n            }\n            // 将当前元素加入栈中\n            // 如果栈为空，说明当前元素没有下一个更大元素，将其对应的 value 设为 -1\n            map.put(num, stack.isEmpty() ? -1 : stack.peek());\n            stack.push(num);\n        }\n        // 遍历 nums1，使用哈希表找到 nums1 中每个元素的下一个更大元素\n        int[] res = new int[nums1.length];\n        for (int i = 0; i < nums1.length; ++i) {\n            res[i] = map.get(nums1[i]);\n        }\n        return res;\n    }\n}\n```\n\n# 四、总结\n\n- 本文介绍了一个基于栈数据结构的算法——单调栈，并使用 LeetCode 上的一道题目来说明了单调栈的使用场景和实现方法。通过对暴力枚举算法和单调栈算法的对比，我们可以看出单调栈算法在时间复杂度上有较大优势（O(m + n)）。\n- 在实际编程中，如果遇到类似\"Next Greater Element\"这样的问题时，可以优先考虑单调栈算法的使用。","slug":"栈_01_下一个更大元素","published":1,"updated":"2023-07-20T00:26:40.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyul001hm7hod81k0se5","content":"<blockquote>\n<p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍一个基于栈数据结构的算法——单调栈。</p>\n</blockquote>\n<h1 id=\"一、栈和单调栈\"><a href=\"#一、栈和单调栈\" class=\"headerlink\" title=\"一、栈和单调栈\"></a>一、栈和单调栈</h1><h2 id=\"1-1-栈\"><a href=\"#1-1-栈\" class=\"headerlink\" title=\"1.1 栈\"></a>1.1 栈</h2><ul>\n<li>定义：栈就是一种只允许在一端进行插入或删除操作的线性表。</li>\n<li>特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。</li>\n<li>stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。</li>\n<li>与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n<h2 id=\"1-2-单调栈\"><a href=\"#1-2-单调栈\" class=\"headerlink\" title=\"1.2 单调栈\"></a>1.2 单调栈</h2><ul>\n<li>定义：单调栈（Monotonic Stack）是一种特殊的栈，它具有保持栈内元素单调递增或递减的特点。在使用单调栈解决算法问题时，往往需要先将数据压入栈中，然后进行适当的操作来维护栈的单调性。</li>\n<li>特点：与普通的栈不同的是，单调栈在插入和删除时，需要先判断是否需要将栈内元素进行弹出，以维护栈的单调性质。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWUzt.webp\">\n\n<h1 id=\"二、问题与思路\"><a href=\"#二、问题与思路\" class=\"headerlink\" title=\"二、问题与思路\"></a>二、问题与思路</h1><h2 id=\"2-1-题目\"><a href=\"#2-1-题目\" class=\"headerlink\" title=\"2.1 题目\"></a>2.1 题目</h2><p><strong>下一个更大元素 I</strong></p>\n<ul>\n<li>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。<br>给你两个没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。<br>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，<br>并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是-1。<br>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/next-greater-element-i\">https://leetcode.cn/problems/next-greater-element-i</a></p>\n<p>例子：</p>\n<ul>\n<li>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：</li>\n<li>4 ，用加粗斜体标识，nums2 = [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。</li>\n<li>1 ，用加粗斜体标识，nums2 = [<strong>1</strong>,3,4,2]。下一个更大元素是 3 。</li>\n<li>2 ，用加粗斜体标识，nums2 = [1,3,4,<strong>2</strong>]。不存在下一个更大元素，所以答案是 -1 。</li>\n</ul>\n<p>我觉得原题目描述得很混乱，我们重新捋一下题目：</p>\n<ul>\n<li>给定两个数组 nums1 和 nums2，其中 nums1 是 nums2 的子集，且两个数组均不包含重复元素。</li>\n<li>对于 nums1 中的每个元素 x，在 nums2 中找到其右侧第一个比它大的元素，将这个下一个更大元素存储在数组 ans 中返回。如果不存在这样的下一个更大元素，则将 -1 存储在 ans 中的相应位置。</li>\n</ul>\n<h2 id=\"2-2-思路一：暴力法\"><a href=\"#2-2-思路一：暴力法\" class=\"headerlink\" title=\"2.2 思路一：暴力法\"></a>2.2 思路一：暴力法</h2><ul>\n<li>首先，清楚题意之后会觉得题目并不难，看起来两次遍历就能解决问题，正所谓暴力法能解决的问题那都不是问题。</li>\n<li>所以这里直接放出来暴力模拟算法的代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class=\"line\">            ans[i] = -<span class=\"number\">1</span>;<span class=\"comment\">//先假设不存在后一个最大元素</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;<span class=\"comment\">//判断是否找到了目标元素</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums2[j] == nums1[i]) &#123;<span class=\"comment\">//到达了目标元素位置</span></span><br><span class=\"line\">                    b = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b &amp;&amp; (nums2[j] &gt; nums1[i])) &#123;<span class=\"comment\">//存在后一个最大元素，将答案数组对应位置赋值</span></span><br><span class=\"line\">                    ans[i] = nums2[j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//结束本次循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度不用说肯定是 <strong>O(n^2)</strong> 了，在数据量大的时候，效率是很差的。</p>\n<h2 id=\"2-3-思路二：单调栈\"><a href=\"#2-3-思路二：单调栈\" class=\"headerlink\" title=\"2.3 思路二：单调栈\"></a>2.3 思路二：单调栈</h2><p>有没有复杂度不那么高的算法呢？如果是 <strong>O(n) 或者 O(m + n)</strong> 级别那就再好不过了。<br>答案是有的，不过需要一个家伙来辅助我们 —— <code>单调栈</code>。</p>\n<ul>\n<li>在前面已经提到过单调栈的概念，即：一种单调递增或递减的特殊栈。</li>\n<li>单调栈非常适合用来解决这道题目。主要步骤如下：<ol>\n<li>创建一个哈希表 map，用于存储每个元素的下一个更大元素。</li>\n<li>创建一个单调栈 stack。</li>\n<li>从 nums2 的尾部开始遍历，对于遍历到的每个元素 num，执行以下操作：<br>a. 如果栈顶元素比当前元素 num 小或等于 num，则弹出栈顶元素，直到栈顶元素比 num 大或者栈为空。<br>b. 将当前元素 num 加入栈中。<br>c. 如果栈为空，则说明当前元素没有下一个更大元素，将其对应的 value 设为 -1；否则，取出栈顶元素，将其作为当前元素的下一个更大元素。</li>\n<li>遍历 nums1 数组，使用哈希表 map 找到 nums1 中每个元素的下一个更大元素。</li>\n</ol>\n</li>\n</ul>\n<p>我们来举个例子走完上面的步骤，这样更有助于理解：</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n<p><code>假设 nums1 = [4, 1, 2]，nums2 = [1, 3, 4, 2]，我们想找到 nums1 中每个元素的下一个更大元素。</code></p>\n<ul>\n<li>第一步：创建哈希表和单调栈</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map=&#123;&#125;</span><br><span class=\"line\">stack=[]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第二步：遍历 nums2，从 nums2 的尾部开始遍历。</p>\n<ul>\n<li>i = 3，num = 2，当前 stack 为空，map 设为 {2: -1}，stack 变成 [2]</li>\n<li>i = 2，num = 4，当前 stack 为 [2]，4 比栈顶元素 2 大，因此弹出 2，并将 map 设为 {2: -1, 4: -1}，stack 变成 [4]</li>\n<li>i = 1，num = 3，当前 stack 为 [4]，3 比栈顶元素 4 小，因此将 3 加入栈中，map 设为 {2: -1, 4: 3, 3: 4}，stack 变成 [4, 3]</li>\n<li>i = 0，num = 1，当前 stack 为 [4, 3]，1 比栈顶元素 3 小，因此将 1 加入栈中，map 设为 {1: 3, 2: -1, 4: 3, 3: 4}，stack 变成 [4, 3, 1]<br>最终得到的 map 为 {1: 3, 2: -1, 4: 3, 3: 4}，表示 nums2 中每个元素的下一个更大元素。</li>\n</ul>\n</li>\n<li><p>第三步：遍历 nums1</p>\n<ul>\n<li>对于 4，map 中对应的是 3</li>\n<li>对于 1，map 中对应的是 3</li>\n<li>对于 2，map 中对应的是 -1<br>因此，最终得到的 res 数组为 [3, 3, -1]，即 nums1 中每个元素的下一个更大元素。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><p>有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建哈希表，用于存储每个元素的下一个更大元素</span></span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 创建单调栈</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 从 nums2 的尾部开始遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> nums2.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> nums2[i];</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前元素比栈顶元素大，则栈顶元素的下一个更大元素就是当前元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将当前元素加入栈中</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果栈为空，说明当前元素没有下一个更大元素，将其对应的 value 设为 -1</span></span><br><span class=\"line\">            map.put(num, stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek());</span><br><span class=\"line\">            stack.push(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历 nums1，使用哈希表找到 nums1 中每个元素的下一个更大元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; ++i) &#123;</span><br><span class=\"line\">            res[i] = map.get(nums1[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>本文介绍了一个基于栈数据结构的算法——单调栈，并使用 LeetCode 上的一道题目来说明了单调栈的使用场景和实现方法。通过对暴力枚举算法和单调栈算法的对比，我们可以看出单调栈算法在时间复杂度上有较大优势（O(m + n)）。</li>\n<li>在实际编程中，如果遇到类似”Next Greater Element”这样的问题时，可以优先考虑单调栈算法的使用。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍一个基于栈数据结构的算法——单调栈。</p>\n</blockquote>\n<h1 id=\"一、栈和单调栈\"><a href=\"#一、栈和单调栈\" class=\"headerlink\" title=\"一、栈和单调栈\"></a>一、栈和单调栈</h1><h2 id=\"1-1-栈\"><a href=\"#1-1-栈\" class=\"headerlink\" title=\"1.1 栈\"></a>1.1 栈</h2><ul>\n<li>定义：栈就是一种只允许在一端进行插入或删除操作的线性表。</li>\n<li>特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。</li>\n<li>stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。</li>\n<li>与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n<h2 id=\"1-2-单调栈\"><a href=\"#1-2-单调栈\" class=\"headerlink\" title=\"1.2 单调栈\"></a>1.2 单调栈</h2><ul>\n<li>定义：单调栈（Monotonic Stack）是一种特殊的栈，它具有保持栈内元素单调递增或递减的特点。在使用单调栈解决算法问题时，往往需要先将数据压入栈中，然后进行适当的操作来维护栈的单调性。</li>\n<li>特点：与普通的栈不同的是，单调栈在插入和删除时，需要先判断是否需要将栈内元素进行弹出，以维护栈的单调性质。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWUzt.webp\">\n\n<h1 id=\"二、问题与思路\"><a href=\"#二、问题与思路\" class=\"headerlink\" title=\"二、问题与思路\"></a>二、问题与思路</h1><h2 id=\"2-1-题目\"><a href=\"#2-1-题目\" class=\"headerlink\" title=\"2.1 题目\"></a>2.1 题目</h2><p><strong>下一个更大元素 I</strong></p>\n<ul>\n<li>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。<br>给你两个没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。<br>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，<br>并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是-1。<br>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/next-greater-element-i\">https://leetcode.cn/problems/next-greater-element-i</a></p>\n<p>例子：</p>\n<ul>\n<li>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：</li>\n<li>4 ，用加粗斜体标识，nums2 = [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。</li>\n<li>1 ，用加粗斜体标识，nums2 = [<strong>1</strong>,3,4,2]。下一个更大元素是 3 。</li>\n<li>2 ，用加粗斜体标识，nums2 = [1,3,4,<strong>2</strong>]。不存在下一个更大元素，所以答案是 -1 。</li>\n</ul>\n<p>我觉得原题目描述得很混乱，我们重新捋一下题目：</p>\n<ul>\n<li>给定两个数组 nums1 和 nums2，其中 nums1 是 nums2 的子集，且两个数组均不包含重复元素。</li>\n<li>对于 nums1 中的每个元素 x，在 nums2 中找到其右侧第一个比它大的元素，将这个下一个更大元素存储在数组 ans 中返回。如果不存在这样的下一个更大元素，则将 -1 存储在 ans 中的相应位置。</li>\n</ul>\n<h2 id=\"2-2-思路一：暴力法\"><a href=\"#2-2-思路一：暴力法\" class=\"headerlink\" title=\"2.2 思路一：暴力法\"></a>2.2 思路一：暴力法</h2><ul>\n<li>首先，清楚题意之后会觉得题目并不难，看起来两次遍历就能解决问题，正所谓暴力法能解决的问题那都不是问题。</li>\n<li>所以这里直接放出来暴力模拟算法的代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class=\"line\">            ans[i] = -<span class=\"number\">1</span>;<span class=\"comment\">//先假设不存在后一个最大元素</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;<span class=\"comment\">//判断是否找到了目标元素</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums2[j] == nums1[i]) &#123;<span class=\"comment\">//到达了目标元素位置</span></span><br><span class=\"line\">                    b = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b &amp;&amp; (nums2[j] &gt; nums1[i])) &#123;<span class=\"comment\">//存在后一个最大元素，将答案数组对应位置赋值</span></span><br><span class=\"line\">                    ans[i] = nums2[j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//结束本次循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度不用说肯定是 <strong>O(n^2)</strong> 了，在数据量大的时候，效率是很差的。</p>\n<h2 id=\"2-3-思路二：单调栈\"><a href=\"#2-3-思路二：单调栈\" class=\"headerlink\" title=\"2.3 思路二：单调栈\"></a>2.3 思路二：单调栈</h2><p>有没有复杂度不那么高的算法呢？如果是 <strong>O(n) 或者 O(m + n)</strong> 级别那就再好不过了。<br>答案是有的，不过需要一个家伙来辅助我们 —— <code>单调栈</code>。</p>\n<ul>\n<li>在前面已经提到过单调栈的概念，即：一种单调递增或递减的特殊栈。</li>\n<li>单调栈非常适合用来解决这道题目。主要步骤如下：<ol>\n<li>创建一个哈希表 map，用于存储每个元素的下一个更大元素。</li>\n<li>创建一个单调栈 stack。</li>\n<li>从 nums2 的尾部开始遍历，对于遍历到的每个元素 num，执行以下操作：<br>a. 如果栈顶元素比当前元素 num 小或等于 num，则弹出栈顶元素，直到栈顶元素比 num 大或者栈为空。<br>b. 将当前元素 num 加入栈中。<br>c. 如果栈为空，则说明当前元素没有下一个更大元素，将其对应的 value 设为 -1；否则，取出栈顶元素，将其作为当前元素的下一个更大元素。</li>\n<li>遍历 nums1 数组，使用哈希表 map 找到 nums1 中每个元素的下一个更大元素。</li>\n</ol>\n</li>\n</ul>\n<p>我们来举个例子走完上面的步骤，这样更有助于理解：</p>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n<p><code>假设 nums1 = [4, 1, 2]，nums2 = [1, 3, 4, 2]，我们想找到 nums1 中每个元素的下一个更大元素。</code></p>\n<ul>\n<li>第一步：创建哈希表和单调栈</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map=&#123;&#125;</span><br><span class=\"line\">stack=[]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第二步：遍历 nums2，从 nums2 的尾部开始遍历。</p>\n<ul>\n<li>i = 3，num = 2，当前 stack 为空，map 设为 {2: -1}，stack 变成 [2]</li>\n<li>i = 2，num = 4，当前 stack 为 [2]，4 比栈顶元素 2 大，因此弹出 2，并将 map 设为 {2: -1, 4: -1}，stack 变成 [4]</li>\n<li>i = 1，num = 3，当前 stack 为 [4]，3 比栈顶元素 4 小，因此将 3 加入栈中，map 设为 {2: -1, 4: 3, 3: 4}，stack 变成 [4, 3]</li>\n<li>i = 0，num = 1，当前 stack 为 [4, 3]，1 比栈顶元素 3 小，因此将 1 加入栈中，map 设为 {1: 3, 2: -1, 4: 3, 3: 4}，stack 变成 [4, 3, 1]<br>最终得到的 map 为 {1: 3, 2: -1, 4: 3, 3: 4}，表示 nums2 中每个元素的下一个更大元素。</li>\n</ul>\n</li>\n<li><p>第三步：遍历 nums1</p>\n<ul>\n<li>对于 4，map 中对应的是 3</li>\n<li>对于 1，map 中对应的是 3</li>\n<li>对于 2，map 中对应的是 -1<br>因此，最终得到的 res 数组为 [3, 3, -1]，即 nums1 中每个元素的下一个更大元素。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><p>有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建哈希表，用于存储每个元素的下一个更大元素</span></span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 创建单调栈</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 从 nums2 的尾部开始遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> nums2.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> nums2[i];</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前元素比栈顶元素大，则栈顶元素的下一个更大元素就是当前元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将当前元素加入栈中</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果栈为空，说明当前元素没有下一个更大元素，将其对应的 value 设为 -1</span></span><br><span class=\"line\">            map.put(num, stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek());</span><br><span class=\"line\">            stack.push(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历 nums1，使用哈希表找到 nums1 中每个元素的下一个更大元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; ++i) &#123;</span><br><span class=\"line\">            res[i] = map.get(nums1[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>本文介绍了一个基于栈数据结构的算法——单调栈，并使用 LeetCode 上的一道题目来说明了单调栈的使用场景和实现方法。通过对暴力枚举算法和单调栈算法的对比，我们可以看出单调栈算法在时间复杂度上有较大优势（O(m + n)）。</li>\n<li>在实际编程中，如果遇到类似”Next Greater Element”这样的问题时，可以优先考虑单调栈算法的使用。</li>\n</ul>\n"},{"title":"有效的括号","date":"2023-05-03T00:00:00.000Z","description":"使用栈辅助解决括号匹配问题","cover":"https://www.helloimg.com/images/2023/05/03/oqw655.jpg","_content":"\n> 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍如何使用栈来辅助解决字符串的匹配这类问题。\n\n# 一、栈\n\n## 1.1 栈是什么\n\n- 定义：栈就是一种只允许在一端进行插入或删除操作的线性表。\n- 特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。\n- stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。\n- 与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。\n\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n## 1.2 使用场景\n\n在一些算法或数据结构问题中，当涉及到`先进后出、后进先出`的操作时，可以考虑使用栈来解决问题。比如下面三个典型的算法模型：\n\n1. 表达式求值：在计算表达式的值时，可以利用栈来实现计算。具体做法是将表达式中的操作数依次入栈，遇到操作符时弹出相应数量的操作数进行运算，将运算结果重新入栈，直到表达式中的所有元素都被处理完毕，最后栈中只剩下一个元素即为表达式的值。\n2. 括号匹配：在检查括号是否匹配时，可以利用栈来实现。具体做法是遍历字符串中的每个字符，遇到左括号时将其入栈，遇到右括号时弹出栈顶元素进行匹配。如果当前字符是右括号，并且栈为空或者栈顶元素不是对应的左括号，就表示括号不匹配。\n3. 函数调用栈：在编写递归函数时，每次进行函数调用时会将当前函数的状态信息（包括参数、局部变量、返回地址等）压入栈中，等到函数执行完毕后再弹出栈顶元素恢复状态。通过栈来维护函数调用的顺序和状态，可以实现递归函数的正常执行。\n\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwl6u.gif\">\n\n注意：并不是所有涉及到`先进后出、后进先出`的操作都可以使用栈来解决，具体问题要具体分析。今天我们讨论的就是第二种模型，`括号匹配`（也可以叫字符串匹配）问题。\n\n# 二、问题与思路\n\n## 2.1 题目\n\n**有效的括号**\n\n- 给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。\n\n    有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 每个右括号都有一个对应的相同类型的左括号。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/valid-parentheses\n\n示例 1：\n输入：s = \"()\"\n输出：true\n\n示例 2：\n输入：s = \"()[]{}\"\n输出：true\n\n\n## 2.2 思路\n\n- 首先，我们思考一下如何判断一个字符串是否有效：\n   1. 如果字符串中只有一个括号，那么显然不是有效字符串。\n   2. 如果字符串中的左右括号数量不相等，那么也不是有效字符串。\n   3. 如果字符串中的左右括号顺序不正确，那么同样不是有效字符串。\n\n由于是要对左右括号进行匹配，而且**顺序**要正确，考虑使用**栈**来解决。\n具体来说，我们可以遍历字符串，对于每个遇到的左括号，入栈；对于每个遇到的右括号，则需要与栈顶元素进行匹配。如果匹配成功，则弹出栈顶元素；如果匹配失败（即栈为空或栈顶元素不能与当前右括号匹配），则说明该字符串不是有效字符串。最后，如果栈不为空，则说明还有未匹配的左括号，也不是有效字符串。\n\n- 然后，我们对算法进行分析\n    1. 创建一个空栈。\n    2. 遍历字符串s，对于每一个字符c，执行以下操作：\n       - 如果c是左括号`(、{、[`，则将其入栈。\n       - 如果c是右括号`)、}、]`：\n         - 如果栈是空的，则返回false，因为此时没有左括号与之匹配。\n         - 否则弹出栈顶元素，如果和当前的右括号不能匹配，则返回false。\n    3. 如果遍历完整个字符串后，栈不为空，则说明有多余的左括号未被匹配，返回false；否则返回true。\n\n## 2.3 演示\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n- 示例一，对于字符串`(){}[]`，按上述步骤进行处理：\n   1. 创建一个空栈。\n   2. 遍历字符串：\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到'{'，将其入栈。\n       - 遇到'}'，弹出'{'，匹配成功。\n       - 遇到'['，将其入栈。\n       - 遇到']'，弹出'['，匹配成功。\n   3. 遍历完毕，栈为空，返回true。\n<br>\n- 示例二，对于字符串\"{()[()]}\"，按照上述步骤进行处理：\n    1. 创建一个空栈。\n    2. 遍历字符串：\n       - 遇到'{'，将其入栈。\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到'['，将其入栈。\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到']'，弹出'['，匹配成功。\n       - 遇到'}'，弹出'{'，匹配成功。\n       - 当前栈：空。\n    3. 遍历完毕，栈为空，返回true。\n    下面是动画演示：\n\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwDpA.gif\">\n\n# 三、题解\n\n有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>(); // 创建一个空栈，用于存储左括号\n        for (char c : s.toCharArray()) { // 遍历字符串\n            if (c == '(' || c == '{' || c == '[') { // 如果是左括号，则入栈\n                stack.push(c);\n            } else { // 如果是右括号\n                if (stack.isEmpty()) { // 如果栈为空，则返回false\n                    return false;\n                }\n                char left = stack.pop(); // 弹出栈顶元素\n                if ((c == ')' && left != '(') || (c == '}' && left != '{') || (c == ']' && left != '[')) {\n                    // 如果右括号与栈顶元素不匹配，则返回false\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty(); // 如果遍历完整个字符串后栈为空，则说明是有效的括号字符串\n    }\n}\n```\n\n# 四、总结\n\n- 本文主要讲解了栈这种数据结构及其应用场景，以及如何使用栈来解决括号匹配问题。具体来说，栈是一种只允许在一端进行插入或删除操作的线性表，具有后进先出（LIFO）的特点。在算法或数据结构问题中，当需要对元素进行先进后出、后进先出的操作时，可以考虑使用栈来解决问题，例如逆序输出一个字符串、进行表达式求值、括号匹配等问题。括号匹配问题是常见的栈应用之一，其解决思路是遍历字符串，对于每个左括号入栈，对于每个右括号弹出栈顶元素进行匹配，直到遍历完整个字符串。如果栈为空，则说明所有左括号都有对应的右括号与之匹配，字符串是有效的括号序列。\n- 学习栈这种数据结构不仅有助于理解算法和数据结构，还有利于提高代码编写的效率。在实际开发过程中，我们可以根据问题的需求来选择合适的数据结构和算法，从而更加高效地解决问题。","source":"_posts/栈_02_有效的括号.md","raw":"---\ntitle: '有效的括号'\ndate: '2023-05-03'\ndescription: '使用栈辅助解决括号匹配问题'\ncover: 'https://www.helloimg.com/images/2023/05/03/oqw655.jpg'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 栈\n\n---\n\n> 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍如何使用栈来辅助解决字符串的匹配这类问题。\n\n# 一、栈\n\n## 1.1 栈是什么\n\n- 定义：栈就是一种只允许在一端进行插入或删除操作的线性表。\n- 特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。\n- stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。\n- 与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。\n\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n## 1.2 使用场景\n\n在一些算法或数据结构问题中，当涉及到`先进后出、后进先出`的操作时，可以考虑使用栈来解决问题。比如下面三个典型的算法模型：\n\n1. 表达式求值：在计算表达式的值时，可以利用栈来实现计算。具体做法是将表达式中的操作数依次入栈，遇到操作符时弹出相应数量的操作数进行运算，将运算结果重新入栈，直到表达式中的所有元素都被处理完毕，最后栈中只剩下一个元素即为表达式的值。\n2. 括号匹配：在检查括号是否匹配时，可以利用栈来实现。具体做法是遍历字符串中的每个字符，遇到左括号时将其入栈，遇到右括号时弹出栈顶元素进行匹配。如果当前字符是右括号，并且栈为空或者栈顶元素不是对应的左括号，就表示括号不匹配。\n3. 函数调用栈：在编写递归函数时，每次进行函数调用时会将当前函数的状态信息（包括参数、局部变量、返回地址等）压入栈中，等到函数执行完毕后再弹出栈顶元素恢复状态。通过栈来维护函数调用的顺序和状态，可以实现递归函数的正常执行。\n\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwl6u.gif\">\n\n注意：并不是所有涉及到`先进后出、后进先出`的操作都可以使用栈来解决，具体问题要具体分析。今天我们讨论的就是第二种模型，`括号匹配`（也可以叫字符串匹配）问题。\n\n# 二、问题与思路\n\n## 2.1 题目\n\n**有效的括号**\n\n- 给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。\n\n    有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 每个右括号都有一个对应的相同类型的左括号。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/valid-parentheses\n\n示例 1：\n输入：s = \"()\"\n输出：true\n\n示例 2：\n输入：s = \"()[]{}\"\n输出：true\n\n\n## 2.2 思路\n\n- 首先，我们思考一下如何判断一个字符串是否有效：\n   1. 如果字符串中只有一个括号，那么显然不是有效字符串。\n   2. 如果字符串中的左右括号数量不相等，那么也不是有效字符串。\n   3. 如果字符串中的左右括号顺序不正确，那么同样不是有效字符串。\n\n由于是要对左右括号进行匹配，而且**顺序**要正确，考虑使用**栈**来解决。\n具体来说，我们可以遍历字符串，对于每个遇到的左括号，入栈；对于每个遇到的右括号，则需要与栈顶元素进行匹配。如果匹配成功，则弹出栈顶元素；如果匹配失败（即栈为空或栈顶元素不能与当前右括号匹配），则说明该字符串不是有效字符串。最后，如果栈不为空，则说明还有未匹配的左括号，也不是有效字符串。\n\n- 然后，我们对算法进行分析\n    1. 创建一个空栈。\n    2. 遍历字符串s，对于每一个字符c，执行以下操作：\n       - 如果c是左括号`(、{、[`，则将其入栈。\n       - 如果c是右括号`)、}、]`：\n         - 如果栈是空的，则返回false，因为此时没有左括号与之匹配。\n         - 否则弹出栈顶元素，如果和当前的右括号不能匹配，则返回false。\n    3. 如果遍历完整个字符串后，栈不为空，则说明有多余的左括号未被匹配，返回false；否则返回true。\n\n## 2.3 演示\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n- 示例一，对于字符串`(){}[]`，按上述步骤进行处理：\n   1. 创建一个空栈。\n   2. 遍历字符串：\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到'{'，将其入栈。\n       - 遇到'}'，弹出'{'，匹配成功。\n       - 遇到'['，将其入栈。\n       - 遇到']'，弹出'['，匹配成功。\n   3. 遍历完毕，栈为空，返回true。\n<br>\n- 示例二，对于字符串\"{()[()]}\"，按照上述步骤进行处理：\n    1. 创建一个空栈。\n    2. 遍历字符串：\n       - 遇到'{'，将其入栈。\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到'['，将其入栈。\n       - 遇到'('，将其入栈。\n       - 遇到')'，弹出'('，匹配成功。\n       - 遇到']'，弹出'['，匹配成功。\n       - 遇到'}'，弹出'{'，匹配成功。\n       - 当前栈：空。\n    3. 遍历完毕，栈为空，返回true。\n    下面是动画演示：\n\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwDpA.gif\">\n\n# 三、题解\n\n有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>(); // 创建一个空栈，用于存储左括号\n        for (char c : s.toCharArray()) { // 遍历字符串\n            if (c == '(' || c == '{' || c == '[') { // 如果是左括号，则入栈\n                stack.push(c);\n            } else { // 如果是右括号\n                if (stack.isEmpty()) { // 如果栈为空，则返回false\n                    return false;\n                }\n                char left = stack.pop(); // 弹出栈顶元素\n                if ((c == ')' && left != '(') || (c == '}' && left != '{') || (c == ']' && left != '[')) {\n                    // 如果右括号与栈顶元素不匹配，则返回false\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty(); // 如果遍历完整个字符串后栈为空，则说明是有效的括号字符串\n    }\n}\n```\n\n# 四、总结\n\n- 本文主要讲解了栈这种数据结构及其应用场景，以及如何使用栈来解决括号匹配问题。具体来说，栈是一种只允许在一端进行插入或删除操作的线性表，具有后进先出（LIFO）的特点。在算法或数据结构问题中，当需要对元素进行先进后出、后进先出的操作时，可以考虑使用栈来解决问题，例如逆序输出一个字符串、进行表达式求值、括号匹配等问题。括号匹配问题是常见的栈应用之一，其解决思路是遍历字符串，对于每个左括号入栈，对于每个右括号弹出栈顶元素进行匹配，直到遍历完整个字符串。如果栈为空，则说明所有左括号都有对应的右括号与之匹配，字符串是有效的括号序列。\n- 学习栈这种数据结构不仅有助于理解算法和数据结构，还有利于提高代码编写的效率。在实际开发过程中，我们可以根据问题的需求来选择合适的数据结构和算法，从而更加高效地解决问题。","slug":"栈_02_有效的括号","published":1,"updated":"2023-07-20T00:27:42.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyun001mm7hoax6lc9t9","content":"<blockquote>\n<p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍如何使用栈来辅助解决字符串的匹配这类问题。</p>\n</blockquote>\n<h1 id=\"一、栈\"><a href=\"#一、栈\" class=\"headerlink\" title=\"一、栈\"></a>一、栈</h1><h2 id=\"1-1-栈是什么\"><a href=\"#1-1-栈是什么\" class=\"headerlink\" title=\"1.1 栈是什么\"></a>1.1 栈是什么</h2><ul>\n<li>定义：栈就是一种只允许在一端进行插入或删除操作的线性表。</li>\n<li>特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。</li>\n<li>stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。</li>\n<li>与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n<h2 id=\"1-2-使用场景\"><a href=\"#1-2-使用场景\" class=\"headerlink\" title=\"1.2 使用场景\"></a>1.2 使用场景</h2><p>在一些算法或数据结构问题中，当涉及到<code>先进后出、后进先出</code>的操作时，可以考虑使用栈来解决问题。比如下面三个典型的算法模型：</p>\n<ol>\n<li>表达式求值：在计算表达式的值时，可以利用栈来实现计算。具体做法是将表达式中的操作数依次入栈，遇到操作符时弹出相应数量的操作数进行运算，将运算结果重新入栈，直到表达式中的所有元素都被处理完毕，最后栈中只剩下一个元素即为表达式的值。</li>\n<li>括号匹配：在检查括号是否匹配时，可以利用栈来实现。具体做法是遍历字符串中的每个字符，遇到左括号时将其入栈，遇到右括号时弹出栈顶元素进行匹配。如果当前字符是右括号，并且栈为空或者栈顶元素不是对应的左括号，就表示括号不匹配。</li>\n<li>函数调用栈：在编写递归函数时，每次进行函数调用时会将当前函数的状态信息（包括参数、局部变量、返回地址等）压入栈中，等到函数执行完毕后再弹出栈顶元素恢复状态。通过栈来维护函数调用的顺序和状态，可以实现递归函数的正常执行。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwl6u.gif\">\n\n<p>注意：并不是所有涉及到<code>先进后出、后进先出</code>的操作都可以使用栈来解决，具体问题要具体分析。今天我们讨论的就是第二种模型，<code>括号匹配</code>（也可以叫字符串匹配）问题。</p>\n<h1 id=\"二、问题与思路\"><a href=\"#二、问题与思路\" class=\"headerlink\" title=\"二、问题与思路\"></a>二、问题与思路</h1><h2 id=\"2-1-题目\"><a href=\"#2-1-题目\" class=\"headerlink\" title=\"2.1 题目\"></a>2.1 题目</h2><p><strong>有效的括号</strong></p>\n<ul>\n<li><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串 s ，判断字符串是否有效。</p>\n<p>  有效字符串需满足：</p>\n</li>\n</ul>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/valid-parentheses\">https://leetcode.cn/problems/valid-parentheses</a></p>\n<p>示例 1：<br>输入：s = “()”<br>输出：true</p>\n<p>示例 2：<br>输入：s = “()[]{}”<br>输出：true</p>\n<h2 id=\"2-2-思路\"><a href=\"#2-2-思路\" class=\"headerlink\" title=\"2.2 思路\"></a>2.2 思路</h2><ul>\n<li>首先，我们思考一下如何判断一个字符串是否有效：<ol>\n<li>如果字符串中只有一个括号，那么显然不是有效字符串。</li>\n<li>如果字符串中的左右括号数量不相等，那么也不是有效字符串。</li>\n<li>如果字符串中的左右括号顺序不正确，那么同样不是有效字符串。</li>\n</ol>\n</li>\n</ul>\n<p>由于是要对左右括号进行匹配，而且<strong>顺序</strong>要正确，考虑使用<strong>栈</strong>来解决。<br>具体来说，我们可以遍历字符串，对于每个遇到的左括号，入栈；对于每个遇到的右括号，则需要与栈顶元素进行匹配。如果匹配成功，则弹出栈顶元素；如果匹配失败（即栈为空或栈顶元素不能与当前右括号匹配），则说明该字符串不是有效字符串。最后，如果栈不为空，则说明还有未匹配的左括号，也不是有效字符串。</p>\n<ul>\n<li>然后，我们对算法进行分析<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串s，对于每一个字符c，执行以下操作：<ul>\n<li>如果c是左括号<code>(、&#123;、[</code>，则将其入栈。</li>\n<li>如果c是右括号<code>)、&#125;、]</code>：<ul>\n<li>如果栈是空的，则返回false，因为此时没有左括号与之匹配。</li>\n<li>否则弹出栈顶元素，如果和当前的右括号不能匹配，则返回false。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果遍历完整个字符串后，栈不为空，则说明有多余的左括号未被匹配，返回false；否则返回true。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-演示\"><a href=\"#2-3-演示\" class=\"headerlink\" title=\"2.3 演示\"></a>2.3 演示</h2><img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n<ul>\n<li>示例一，对于字符串<code>()&#123;&#125;[]</code>，按上述步骤进行处理：<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串：<ul>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’{‘，将其入栈。</li>\n<li>遇到’}’，弹出’{‘，匹配成功。</li>\n<li>遇到’[‘，将其入栈。</li>\n<li>遇到’]’，弹出’[‘，匹配成功。</li>\n</ul>\n</li>\n<li>遍历完毕，栈为空，返回true。<br></li>\n</ol>\n</li>\n<li>示例二，对于字符串”{()[()]}”，按照上述步骤进行处理：<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串：<ul>\n<li>遇到’{‘，将其入栈。</li>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’[‘，将其入栈。</li>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’]’，弹出’[‘，匹配成功。</li>\n<li>遇到’}’，弹出’{‘，匹配成功。</li>\n<li>当前栈：空。</li>\n</ul>\n</li>\n<li>遍历完毕，栈为空，返回true。<br>下面是动画演示：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwDpA.gif\">\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><p>有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;(); <span class=\"comment\">// 创建一个空栈，用于存储左括号</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s.toCharArray()) &#123; <span class=\"comment\">// 遍历字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span> || c == <span class=\"string\">&#x27;&#123;&#x27;</span> || c == <span class=\"string\">&#x27;[&#x27;</span>) &#123; <span class=\"comment\">// 如果是左括号，则入栈</span></span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果是右括号</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.isEmpty()) &#123; <span class=\"comment\">// 如果栈为空，则返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> stack.pop(); <span class=\"comment\">// 弹出栈顶元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c == <span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;(&#x27;</span>) || (c == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;&#123;&#x27;</span>) || (c == <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;[&#x27;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果右括号与栈顶元素不匹配，则返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty(); <span class=\"comment\">// 如果遍历完整个字符串后栈为空，则说明是有效的括号字符串</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>本文主要讲解了栈这种数据结构及其应用场景，以及如何使用栈来解决括号匹配问题。具体来说，栈是一种只允许在一端进行插入或删除操作的线性表，具有后进先出（LIFO）的特点。在算法或数据结构问题中，当需要对元素进行先进后出、后进先出的操作时，可以考虑使用栈来解决问题，例如逆序输出一个字符串、进行表达式求值、括号匹配等问题。括号匹配问题是常见的栈应用之一，其解决思路是遍历字符串，对于每个左括号入栈，对于每个右括号弹出栈顶元素进行匹配，直到遍历完整个字符串。如果栈为空，则说明所有左括号都有对应的右括号与之匹配，字符串是有效的括号序列。</li>\n<li>学习栈这种数据结构不仅有助于理解算法和数据结构，还有利于提高代码编写的效率。在实际开发过程中，我们可以根据问题的需求来选择合适的数据结构和算法，从而更加高效地解决问题。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍如何使用栈来辅助解决字符串的匹配这类问题。</p>\n</blockquote>\n<h1 id=\"一、栈\"><a href=\"#一、栈\" class=\"headerlink\" title=\"一、栈\"></a>一、栈</h1><h2 id=\"1-1-栈是什么\"><a href=\"#1-1-栈是什么\" class=\"headerlink\" title=\"1.1 栈是什么\"></a>1.1 栈是什么</h2><ul>\n<li>定义：栈就是一种只允许在一端进行插入或删除操作的线性表。</li>\n<li>特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。</li>\n<li>stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。</li>\n<li>与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg\">\n\n<h2 id=\"1-2-使用场景\"><a href=\"#1-2-使用场景\" class=\"headerlink\" title=\"1.2 使用场景\"></a>1.2 使用场景</h2><p>在一些算法或数据结构问题中，当涉及到<code>先进后出、后进先出</code>的操作时，可以考虑使用栈来解决问题。比如下面三个典型的算法模型：</p>\n<ol>\n<li>表达式求值：在计算表达式的值时，可以利用栈来实现计算。具体做法是将表达式中的操作数依次入栈，遇到操作符时弹出相应数量的操作数进行运算，将运算结果重新入栈，直到表达式中的所有元素都被处理完毕，最后栈中只剩下一个元素即为表达式的值。</li>\n<li>括号匹配：在检查括号是否匹配时，可以利用栈来实现。具体做法是遍历字符串中的每个字符，遇到左括号时将其入栈，遇到右括号时弹出栈顶元素进行匹配。如果当前字符是右括号，并且栈为空或者栈顶元素不是对应的左括号，就表示括号不匹配。</li>\n<li>函数调用栈：在编写递归函数时，每次进行函数调用时会将当前函数的状态信息（包括参数、局部变量、返回地址等）压入栈中，等到函数执行完毕后再弹出栈顶元素恢复状态。通过栈来维护函数调用的顺序和状态，可以实现递归函数的正常执行。</li>\n</ol>\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwl6u.gif\">\n\n<p>注意：并不是所有涉及到<code>先进后出、后进先出</code>的操作都可以使用栈来解决，具体问题要具体分析。今天我们讨论的就是第二种模型，<code>括号匹配</code>（也可以叫字符串匹配）问题。</p>\n<h1 id=\"二、问题与思路\"><a href=\"#二、问题与思路\" class=\"headerlink\" title=\"二、问题与思路\"></a>二、问题与思路</h1><h2 id=\"2-1-题目\"><a href=\"#2-1-题目\" class=\"headerlink\" title=\"2.1 题目\"></a>2.1 题目</h2><p><strong>有效的括号</strong></p>\n<ul>\n<li><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串 s ，判断字符串是否有效。</p>\n<p>  有效字符串需满足：</p>\n</li>\n</ul>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/valid-parentheses\">https://leetcode.cn/problems/valid-parentheses</a></p>\n<p>示例 1：<br>输入：s = “()”<br>输出：true</p>\n<p>示例 2：<br>输入：s = “()[]{}”<br>输出：true</p>\n<h2 id=\"2-2-思路\"><a href=\"#2-2-思路\" class=\"headerlink\" title=\"2.2 思路\"></a>2.2 思路</h2><ul>\n<li>首先，我们思考一下如何判断一个字符串是否有效：<ol>\n<li>如果字符串中只有一个括号，那么显然不是有效字符串。</li>\n<li>如果字符串中的左右括号数量不相等，那么也不是有效字符串。</li>\n<li>如果字符串中的左右括号顺序不正确，那么同样不是有效字符串。</li>\n</ol>\n</li>\n</ul>\n<p>由于是要对左右括号进行匹配，而且<strong>顺序</strong>要正确，考虑使用<strong>栈</strong>来解决。<br>具体来说，我们可以遍历字符串，对于每个遇到的左括号，入栈；对于每个遇到的右括号，则需要与栈顶元素进行匹配。如果匹配成功，则弹出栈顶元素；如果匹配失败（即栈为空或栈顶元素不能与当前右括号匹配），则说明该字符串不是有效字符串。最后，如果栈不为空，则说明还有未匹配的左括号，也不是有效字符串。</p>\n<ul>\n<li>然后，我们对算法进行分析<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串s，对于每一个字符c，执行以下操作：<ul>\n<li>如果c是左括号<code>(、&#123;、[</code>，则将其入栈。</li>\n<li>如果c是右括号<code>)、&#125;、]</code>：<ul>\n<li>如果栈是空的，则返回false，因为此时没有左括号与之匹配。</li>\n<li>否则弹出栈顶元素，如果和当前的右括号不能匹配，则返回false。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果遍历完整个字符串后，栈不为空，则说明有多余的左括号未被匹配，返回false；否则返回true。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-3-演示\"><a href=\"#2-3-演示\" class=\"headerlink\" title=\"2.3 演示\"></a>2.3 演示</h2><img src=\"https://www.helloimg.com/images/2023/07/20/oAWk5u.jpg\">\n\n<ul>\n<li>示例一，对于字符串<code>()&#123;&#125;[]</code>，按上述步骤进行处理：<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串：<ul>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’{‘，将其入栈。</li>\n<li>遇到’}’，弹出’{‘，匹配成功。</li>\n<li>遇到’[‘，将其入栈。</li>\n<li>遇到’]’，弹出’[‘，匹配成功。</li>\n</ul>\n</li>\n<li>遍历完毕，栈为空，返回true。<br></li>\n</ol>\n</li>\n<li>示例二，对于字符串”{()[()]}”，按照上述步骤进行处理：<ol>\n<li>创建一个空栈。</li>\n<li>遍历字符串：<ul>\n<li>遇到’{‘，将其入栈。</li>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’[‘，将其入栈。</li>\n<li>遇到’(‘，将其入栈。</li>\n<li>遇到’)’，弹出’(‘，匹配成功。</li>\n<li>遇到’]’，弹出’[‘，匹配成功。</li>\n<li>遇到’}’，弹出’{‘，匹配成功。</li>\n<li>当前栈：空。</li>\n</ul>\n</li>\n<li>遍历完毕，栈为空，返回true。<br>下面是动画演示：</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/05/03/oqwDpA.gif\">\n\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><p>有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;(); <span class=\"comment\">// 创建一个空栈，用于存储左括号</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s.toCharArray()) &#123; <span class=\"comment\">// 遍历字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span> || c == <span class=\"string\">&#x27;&#123;&#x27;</span> || c == <span class=\"string\">&#x27;[&#x27;</span>) &#123; <span class=\"comment\">// 如果是左括号，则入栈</span></span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果是右括号</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.isEmpty()) &#123; <span class=\"comment\">// 如果栈为空，则返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> stack.pop(); <span class=\"comment\">// 弹出栈顶元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c == <span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;(&#x27;</span>) || (c == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;&#123;&#x27;</span>) || (c == <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; left != <span class=\"string\">&#x27;[&#x27;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果右括号与栈顶元素不匹配，则返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty(); <span class=\"comment\">// 如果遍历完整个字符串后栈为空，则说明是有效的括号字符串</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>本文主要讲解了栈这种数据结构及其应用场景，以及如何使用栈来解决括号匹配问题。具体来说，栈是一种只允许在一端进行插入或删除操作的线性表，具有后进先出（LIFO）的特点。在算法或数据结构问题中，当需要对元素进行先进后出、后进先出的操作时，可以考虑使用栈来解决问题，例如逆序输出一个字符串、进行表达式求值、括号匹配等问题。括号匹配问题是常见的栈应用之一，其解决思路是遍历字符串，对于每个左括号入栈，对于每个右括号弹出栈顶元素进行匹配，直到遍历完整个字符串。如果栈为空，则说明所有左括号都有对应的右括号与之匹配，字符串是有效的括号序列。</li>\n<li>学习栈这种数据结构不仅有助于理解算法和数据结构，还有利于提高代码编写的效率。在实际开发过程中，我们可以根据问题的需求来选择合适的数据结构和算法，从而更加高效地解决问题。</li>\n</ul>\n"},{"title":"拆分成最多数目的正偶数之和","date":"2023-07-06T00:00:00.000Z","description":"贪心算法入门题目 - 拆分成最多数目的正偶数之和","cover":"https://www.helloimg.com/images/2023/07/06/o47s96.jpg","_content":"\n> 贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。\n\n# 一、题目\n\n给你一个整数 `finalSum`。请你将它拆分成若干个`互不相同`的正偶数之和，且拆分出来的正偶数数目`最多`。\n\n比方说，给你 `finalSum = 12`，那么这些拆分是`符合要求`的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意`finalSum`不能拆分成`(2 + 2 + 4 + 4)`，因为拆分出来的整数必须互不相同。\n请你返回一个整数数组，表示将整数拆分成`最多`数目的正偶数数组。如果没有办法将`finalSum`进行拆分，请你返回一个`空`数组。你可以按`任意`顺序返回这些整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/maximum-split-of-positive-even-integers\n\n# 二、思路\n\n## 2.1 贪心算法\n\n- 为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图`当前最优`的选择，即局部最优解，而`不考虑`该选择对后续步骤的影响。\n- 举个非常简单的例子：假设现在有`4`张钞票：1元、5元、10元和20元，现在允许你每次拿`1`张，最多拿`2`张，你会怎么拿才能让自己得到最多的钱？\n\n<img src=\"https://www.helloimg.com/images/2023/07/06/o47tkn.jpg\">\n\n- 一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：`贪图当前最优`。\n\n## 2.2 确定算法\n\n- 回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？\n- 对于贪心算法，我们需要知道一点：`不保证最优解`，什么意思？大白话说就是可能得到的答案是`错误的`！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。\n- 一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：\n  1. 问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。\n  2. 问题的子问题相互独立：当前的选择不会影响后续的选择。\n- 来看本题目：\n  1. 要拆分 finalSum，并取得`最大`的拆分数目，并且拆分出来的偶数`互不相同`。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了`问题具有贪心选择性质`的特点。\n  2. 当前的选择也并不会影响之后的选择，满足了`问题的子问题相互独立`的特点。所以自然而然，我们想到了使用贪心算法进行求解。\n\n# 三、详细算法\n\n## 3.1 算法分析\n\n- 前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。\n  1. 从`最小的偶整数2`开始依次尝试拆分，直到剩余的数值`小于等于`当前被拆分的`最大偶整数`为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。\n  2. 如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。\n- 还是举个例子可能会更清楚一点。比如拿`32`来拆分。\n  1. 取 `2`，此时 finalSum = 30    `ans = [2]`\n  2. 取 `4`，此时 finalSum = 26    `ans = [2,4]`\n  3. 取 `6`，此时 finalSum = 20    `ans = [2,4,6]`\n  4. 取 `8`，此时 finalSum = 12    `ans = [2,4,6,8]`\n  5. 取 `10`，此时 finalSum = 2    `ans = [2,4,6,8,10]` \n  6. 这时，能取的最小偶数已经比剩下的数还大了`(10 > 2)`，自然已经无法进行拆分了，最后将剩下的`2`加在当前的最大值`10`上面，这样可以保证结果不重复。\n  7. 最终我们得到了正确结果(之一)：`[2,4,6,8,12]`\n\n## 3.2 详细题解\n\n```java\nclass Solution {\n    public List<Long> maximumEvenSplit(long finalSum) {\n        //结果集合，用来保存最终结果\n        List<Long> ans = new ArrayList<>();\n        //如果不是偶数，不能被拆分，返回空集合\n        if (finalSum % 2 != 0) {\n            return ans;\n        }\n        //开始遍历，每次将 i 加2\n        for(long i = 2;i <= finalSum;i += 2){\n            //将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合\n            ans.add(i);\n            //finalSum 减去 i\n            finalSum -= i;\n            //如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复\n            //比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i >= finalSum（8） 了，将 8 加到上一个结果中\n            //最终结果变为：2，4，6，8 + 8  即 2，4，6，16\n            if(i >= finalSum){\n                //由于前面已经将 i 放入了集合，主要更改最后放入的值\n                ans.set(ans.size() - 1,finalSum += ans.get(ans.size() - 1));\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 四、总结\n\n- 看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。\n- 贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。\n- 对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。","source":"_posts/贪心_01_拆分成最多数目的正偶数之和.md","raw":"---\ntitle: '拆分成最多数目的正偶数之和'\ndate: '2023-07-06'\ndescription: '贪心算法入门题目 - 拆分成最多数目的正偶数之和'\ncover: 'https://www.helloimg.com/images/2023/07/06/o47s96.jpg'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 贪心\n\n---\n\n> 贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。\n\n# 一、题目\n\n给你一个整数 `finalSum`。请你将它拆分成若干个`互不相同`的正偶数之和，且拆分出来的正偶数数目`最多`。\n\n比方说，给你 `finalSum = 12`，那么这些拆分是`符合要求`的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意`finalSum`不能拆分成`(2 + 2 + 4 + 4)`，因为拆分出来的整数必须互不相同。\n请你返回一个整数数组，表示将整数拆分成`最多`数目的正偶数数组。如果没有办法将`finalSum`进行拆分，请你返回一个`空`数组。你可以按`任意`顺序返回这些整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/maximum-split-of-positive-even-integers\n\n# 二、思路\n\n## 2.1 贪心算法\n\n- 为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图`当前最优`的选择，即局部最优解，而`不考虑`该选择对后续步骤的影响。\n- 举个非常简单的例子：假设现在有`4`张钞票：1元、5元、10元和20元，现在允许你每次拿`1`张，最多拿`2`张，你会怎么拿才能让自己得到最多的钱？\n\n<img src=\"https://www.helloimg.com/images/2023/07/06/o47tkn.jpg\">\n\n- 一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：`贪图当前最优`。\n\n## 2.2 确定算法\n\n- 回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？\n- 对于贪心算法，我们需要知道一点：`不保证最优解`，什么意思？大白话说就是可能得到的答案是`错误的`！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。\n- 一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：\n  1. 问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。\n  2. 问题的子问题相互独立：当前的选择不会影响后续的选择。\n- 来看本题目：\n  1. 要拆分 finalSum，并取得`最大`的拆分数目，并且拆分出来的偶数`互不相同`。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了`问题具有贪心选择性质`的特点。\n  2. 当前的选择也并不会影响之后的选择，满足了`问题的子问题相互独立`的特点。所以自然而然，我们想到了使用贪心算法进行求解。\n\n# 三、详细算法\n\n## 3.1 算法分析\n\n- 前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。\n  1. 从`最小的偶整数2`开始依次尝试拆分，直到剩余的数值`小于等于`当前被拆分的`最大偶整数`为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。\n  2. 如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。\n- 还是举个例子可能会更清楚一点。比如拿`32`来拆分。\n  1. 取 `2`，此时 finalSum = 30    `ans = [2]`\n  2. 取 `4`，此时 finalSum = 26    `ans = [2,4]`\n  3. 取 `6`，此时 finalSum = 20    `ans = [2,4,6]`\n  4. 取 `8`，此时 finalSum = 12    `ans = [2,4,6,8]`\n  5. 取 `10`，此时 finalSum = 2    `ans = [2,4,6,8,10]` \n  6. 这时，能取的最小偶数已经比剩下的数还大了`(10 > 2)`，自然已经无法进行拆分了，最后将剩下的`2`加在当前的最大值`10`上面，这样可以保证结果不重复。\n  7. 最终我们得到了正确结果(之一)：`[2,4,6,8,12]`\n\n## 3.2 详细题解\n\n```java\nclass Solution {\n    public List<Long> maximumEvenSplit(long finalSum) {\n        //结果集合，用来保存最终结果\n        List<Long> ans = new ArrayList<>();\n        //如果不是偶数，不能被拆分，返回空集合\n        if (finalSum % 2 != 0) {\n            return ans;\n        }\n        //开始遍历，每次将 i 加2\n        for(long i = 2;i <= finalSum;i += 2){\n            //将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合\n            ans.add(i);\n            //finalSum 减去 i\n            finalSum -= i;\n            //如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复\n            //比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i >= finalSum（8） 了，将 8 加到上一个结果中\n            //最终结果变为：2，4，6，8 + 8  即 2，4，6，16\n            if(i >= finalSum){\n                //由于前面已经将 i 放入了集合，主要更改最后放入的值\n                ans.set(ans.size() - 1,finalSum += ans.get(ans.size() - 1));\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 四、总结\n\n- 看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。\n- 贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。\n- 对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。","slug":"贪心_01_拆分成最多数目的正偶数之和","published":1,"updated":"2023-07-19T09:23:44.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyuo001pm7hod0s2ceck","content":"<blockquote>\n<p>贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你一个整数 <code>finalSum</code>。请你将它拆分成若干个<code>互不相同</code>的正偶数之和，且拆分出来的正偶数数目<code>最多</code>。</p>\n<p>比方说，给你 <code>finalSum = 12</code>，那么这些拆分是<code>符合要求</code>的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意<code>finalSum</code>不能拆分成<code>(2 + 2 + 4 + 4)</code>，因为拆分出来的整数必须互不相同。<br>请你返回一个整数数组，表示将整数拆分成<code>最多</code>数目的正偶数数组。如果没有办法将<code>finalSum</code>进行拆分，请你返回一个<code>空</code>数组。你可以按<code>任意</code>顺序返回这些整数。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/maximum-split-of-positive-even-integers\">https://leetcode.cn/problems/maximum-split-of-positive-even-integers</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-贪心算法\"><a href=\"#2-1-贪心算法\" class=\"headerlink\" title=\"2.1 贪心算法\"></a>2.1 贪心算法</h2><ul>\n<li>为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图<code>当前最优</code>的选择，即局部最优解，而<code>不考虑</code>该选择对后续步骤的影响。</li>\n<li>举个非常简单的例子：假设现在有<code>4</code>张钞票：1元、5元、10元和20元，现在允许你每次拿<code>1</code>张，最多拿<code>2</code>张，你会怎么拿才能让自己得到最多的钱？</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/06/o47tkn.jpg\">\n\n<ul>\n<li>一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：<code>贪图当前最优</code>。</li>\n</ul>\n<h2 id=\"2-2-确定算法\"><a href=\"#2-2-确定算法\" class=\"headerlink\" title=\"2.2 确定算法\"></a>2.2 确定算法</h2><ul>\n<li>回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？</li>\n<li>对于贪心算法，我们需要知道一点：<code>不保证最优解</code>，什么意思？大白话说就是可能得到的答案是<code>错误的</code>！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。</li>\n<li>一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：<ol>\n<li>问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。</li>\n<li>问题的子问题相互独立：当前的选择不会影响后续的选择。</li>\n</ol>\n</li>\n<li>来看本题目：<ol>\n<li>要拆分 finalSum，并取得<code>最大</code>的拆分数目，并且拆分出来的偶数<code>互不相同</code>。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了<code>问题具有贪心选择性质</code>的特点。</li>\n<li>当前的选择也并不会影响之后的选择，满足了<code>问题的子问题相互独立</code>的特点。所以自然而然，我们想到了使用贪心算法进行求解。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、详细算法\"><a href=\"#三、详细算法\" class=\"headerlink\" title=\"三、详细算法\"></a>三、详细算法</h1><h2 id=\"3-1-算法分析\"><a href=\"#3-1-算法分析\" class=\"headerlink\" title=\"3.1 算法分析\"></a>3.1 算法分析</h2><ul>\n<li>前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。<ol>\n<li>从<code>最小的偶整数2</code>开始依次尝试拆分，直到剩余的数值<code>小于等于</code>当前被拆分的<code>最大偶整数</code>为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。</li>\n<li>如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。</li>\n</ol>\n</li>\n<li>还是举个例子可能会更清楚一点。比如拿<code>32</code>来拆分。<ol>\n<li>取 <code>2</code>，此时 finalSum = 30    <code>ans = [2]</code></li>\n<li>取 <code>4</code>，此时 finalSum = 26    <code>ans = [2,4]</code></li>\n<li>取 <code>6</code>，此时 finalSum = 20    <code>ans = [2,4,6]</code></li>\n<li>取 <code>8</code>，此时 finalSum = 12    <code>ans = [2,4,6,8]</code></li>\n<li>取 <code>10</code>，此时 finalSum = 2    <code>ans = [2,4,6,8,10]</code> </li>\n<li>这时，能取的最小偶数已经比剩下的数还大了<code>(10 &gt; 2)</code>，自然已经无法进行拆分了，最后将剩下的<code>2</code>加在当前的最大值<code>10</code>上面，这样可以保证结果不重复。</li>\n<li>最终我们得到了正确结果(之一)：<code>[2,4,6,8,12]</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-详细题解\"><a href=\"#3-2-详细题解\" class=\"headerlink\" title=\"3.2 详细题解\"></a>3.2 详细题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">maximumEvenSplit</span><span class=\"params\">(<span class=\"type\">long</span> finalSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//结果集合，用来保存最终结果</span></span><br><span class=\"line\">        List&lt;Long&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//如果不是偶数，不能被拆分，返回空集合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalSum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开始遍历，每次将 i 加2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;i &lt;= finalSum;i += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合</span></span><br><span class=\"line\">            ans.add(i);</span><br><span class=\"line\">            <span class=\"comment\">//finalSum 减去 i</span></span><br><span class=\"line\">            finalSum -= i;</span><br><span class=\"line\">            <span class=\"comment\">//如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复</span></span><br><span class=\"line\">            <span class=\"comment\">//比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i &gt;= finalSum（8） 了，将 8 加到上一个结果中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终结果变为：2，4，6，8 + 8  即 2，4，6，16</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= finalSum)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//由于前面已经将 i 放入了集合，主要更改最后放入的值</span></span><br><span class=\"line\">                ans.set(ans.size() - <span class=\"number\">1</span>,finalSum += ans.get(ans.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。</li>\n<li>贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。</li>\n<li>对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你一个整数 <code>finalSum</code>。请你将它拆分成若干个<code>互不相同</code>的正偶数之和，且拆分出来的正偶数数目<code>最多</code>。</p>\n<p>比方说，给你 <code>finalSum = 12</code>，那么这些拆分是<code>符合要求</code>的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意<code>finalSum</code>不能拆分成<code>(2 + 2 + 4 + 4)</code>，因为拆分出来的整数必须互不相同。<br>请你返回一个整数数组，表示将整数拆分成<code>最多</code>数目的正偶数数组。如果没有办法将<code>finalSum</code>进行拆分，请你返回一个<code>空</code>数组。你可以按<code>任意</code>顺序返回这些整数。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/maximum-split-of-positive-even-integers\">https://leetcode.cn/problems/maximum-split-of-positive-even-integers</a></p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-贪心算法\"><a href=\"#2-1-贪心算法\" class=\"headerlink\" title=\"2.1 贪心算法\"></a>2.1 贪心算法</h2><ul>\n<li>为什么贪心算法要叫这个名字？本来贪心是用来形容欲望大，不知足。这里，贪心是指每一步都贪图<code>当前最优</code>的选择，即局部最优解，而<code>不考虑</code>该选择对后续步骤的影响。</li>\n<li>举个非常简单的例子：假设现在有<code>4</code>张钞票：1元、5元、10元和20元，现在允许你每次拿<code>1</code>张，最多拿<code>2</code>张，你会怎么拿才能让自己得到最多的钱？</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/06/o47tkn.jpg\">\n\n<ul>\n<li>一年级的小朋友都知道，肯定要从大的面值开始拿，也就是先拿20元，再拿10元。最后就能得到30元巨款。其实这就是贪心算法的核心思想：<code>贪图当前最优</code>。</li>\n</ul>\n<h2 id=\"2-2-确定算法\"><a href=\"#2-2-确定算法\" class=\"headerlink\" title=\"2.2 确定算法\"></a>2.2 确定算法</h2><ul>\n<li>回到题目，为什么这个题能用贪心算法进行求解？或者往大了说，我们什么时候应该想到使用贪心算法进行求解？</li>\n<li>对于贪心算法，我们需要知道一点：<code>不保证最优解</code>，什么意思？大白话说就是可能得到的答案是<code>错误的</code>！所以在应用贪心算法之前，我们要仔细分析问题，并判断是否适合使用贪心算法。</li>\n<li>一般来说，如果题目满足下面的条件，我们可以选取贪心算法求解：<ol>\n<li>问题具有贪心选择性质：通过局部最优的选择达到全局最优，也就是说最优解不需要进行全局考虑。</li>\n<li>问题的子问题相互独立：当前的选择不会影响后续的选择。</li>\n</ol>\n</li>\n<li>来看本题目：<ol>\n<li>要拆分 finalSum，并取得<code>最大</code>的拆分数目，并且拆分出来的偶数<code>互不相同</code>。我们希望拆分成尽可能多的偶数，所以应该尽可能拆份成最小的若干个偶数。这样就满足了<code>问题具有贪心选择性质</code>的特点。</li>\n<li>当前的选择也并不会影响之后的选择，满足了<code>问题的子问题相互独立</code>的特点。所以自然而然，我们想到了使用贪心算法进行求解。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"三、详细算法\"><a href=\"#三、详细算法\" class=\"headerlink\" title=\"三、详细算法\"></a>三、详细算法</h1><h2 id=\"3-1-算法分析\"><a href=\"#3-1-算法分析\" class=\"headerlink\" title=\"3.1 算法分析\"></a>3.1 算法分析</h2><ul>\n<li>前面分析了为什么要使用贪心算法，接下来看一下具体的实现步骤。<ol>\n<li>从<code>最小的偶整数2</code>开始依次尝试拆分，直到剩余的数值<code>小于等于</code>当前被拆分的<code>最大偶整数</code>为止。 此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。</li>\n<li>如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。</li>\n</ol>\n</li>\n<li>还是举个例子可能会更清楚一点。比如拿<code>32</code>来拆分。<ol>\n<li>取 <code>2</code>，此时 finalSum = 30    <code>ans = [2]</code></li>\n<li>取 <code>4</code>，此时 finalSum = 26    <code>ans = [2,4]</code></li>\n<li>取 <code>6</code>，此时 finalSum = 20    <code>ans = [2,4,6]</code></li>\n<li>取 <code>8</code>，此时 finalSum = 12    <code>ans = [2,4,6,8]</code></li>\n<li>取 <code>10</code>，此时 finalSum = 2    <code>ans = [2,4,6,8,10]</code> </li>\n<li>这时，能取的最小偶数已经比剩下的数还大了<code>(10 &gt; 2)</code>，自然已经无法进行拆分了，最后将剩下的<code>2</code>加在当前的最大值<code>10</code>上面，这样可以保证结果不重复。</li>\n<li>最终我们得到了正确结果(之一)：<code>[2,4,6,8,12]</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-2-详细题解\"><a href=\"#3-2-详细题解\" class=\"headerlink\" title=\"3.2 详细题解\"></a>3.2 详细题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">maximumEvenSplit</span><span class=\"params\">(<span class=\"type\">long</span> finalSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//结果集合，用来保存最终结果</span></span><br><span class=\"line\">        List&lt;Long&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//如果不是偶数，不能被拆分，返回空集合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalSum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开始遍历，每次将 i 加2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;i &lt;= finalSum;i += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将 i 放入结果集合。即按照 2，4，6...的顺序添加进集合</span></span><br><span class=\"line\">            ans.add(i);</span><br><span class=\"line\">            <span class=\"comment\">//finalSum 减去 i</span></span><br><span class=\"line\">            finalSum -= i;</span><br><span class=\"line\">            <span class=\"comment\">//如果遇到剩下的数比 i 还小了，说明分不下去了，将最后一个数加在 ans 倒数的第二个数上面，以免重复</span></span><br><span class=\"line\">            <span class=\"comment\">//比如 28 的拆分过程：i = 2，4，6，8   finalSum = 26，22，16，8   此时 i &gt;= finalSum（8） 了，将 8 加到上一个结果中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终结果变为：2，4，6，8 + 8  即 2，4，6，16</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= finalSum)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//由于前面已经将 i 放入了集合，主要更改最后放入的值</span></span><br><span class=\"line\">                ans.set(ans.size() - <span class=\"number\">1</span>,finalSum += ans.get(ans.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>看得出来贪心算法并不是很难，因为在相对较难(限制较多)的题目中，由于贪心算法无法保证最优解，是不能使用的。</li>\n<li>贪心算法虽然简单，但它仍然是一种重要的算法思想，它有简单易实现、效率高等特点。并且在某些不需要追求最优解只需要近似最优解的情况下，贪心算法可以发挥其优势。</li>\n<li>对于贪心算法受限的问题，通常需要考虑其他算法，如动态规划、回溯法等，来找到最优解。这些算法可能更加复杂，但它们可以解决那些贪心算法无法处理的问题。</li>\n</ul>\n"},{"title":"相交链表","date":"2023-04-08T00:00:00.000Z","description":"一个有意思的链表相关算法题目 - 相交链表","cover":"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png","_content":"\n> 链表（Linked List）是一种用于存储元素的线性数据结构，不同于数组，链表中的元素并不是在内存中连续存储的。链表通过使用指针来连接每个元素，使其成为一个链式结构。相比于数组，链表具有更好的插入和删除效率，适用于需要频繁进行插入和删除操作的场景。在今天的博客中，我们将详细介绍链表的基本概念、操作及常见算法应用，希望能够对读者加深对链表的理解和认识。\n\n# 一、题目\n\n给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n\n图示两个链表在节点 c1 开始相交：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n题目数据保证整个链式结构中不存在环。\n注意，函数返回结果后，链表必须保持其原始结构。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/intersection-of-two-linked-lists\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么样的算法来求解此题。\n\n### 2.1.1 哈希集合\n\n- 我第一眼看到这个题目的时候，想到的是使用**哈希集合**来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。\n- 然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：\n    1. 如果当前节点不在哈希集合中，则继续遍历下一个节点；\n    2. 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。\n\n- 如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。\n\n上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。\n\n### 2.1.2 双指针\n\n- 今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。\n- 有些同学可能不知道双指针是啥，或者还是第一次听到**指针**这个概念。\n    - 指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。\n- 学过C语言的都知道，指针是个相对麻烦的东西。但是**双指针**中的'指针'并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）\n    - 使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。\n    - 一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。\n\n举个例子可能更有利于理解，下面是一个使用双指针技巧[判断字符串是否为回文字符串](https://leetcode.cn/problems/valid-palindrome/)的算法：\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        StringBuffer sgood = new StringBuffer();\n        int length = s.length();\n        for (int i = 0; i < length; i++) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) {\n                sgood.append(Character.toLowerCase(ch));\n            }\n        }\n        int n = sgood.length();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n}\n```\n\n## 2.2 算法分析\n\n可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。\n\n### 2.2.1 定义指针\n\n- 再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n- 我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们**保持原始的链表结构！** 所以不建议直接使用链表的头结点。\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        ListNode pA = headA;\n        ListNode pB = headB;\n        /*  省略  */\n    }\n}\n```\n\n### 2.2.2 核心算法\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        /*  省略  */\n    }\n}\n```\n\n- 上面的代码就是整个算法的灵魂，解释一下：\n- pA = pA == null ? headB : pA.next;\n    - 这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。\n- pB = pB == null ? headA : pB.next;\n    - 这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。\n\n  自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。\n\n### 2.2.3 思路总结\n\n- Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWrsv.png\">\n\n- 做个大白话分析：\n    1. 首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；\n    2. 然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；\n    3. 如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；\n    4. 如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和\n       pB 相遇时，它们所遍历的路程长度相等；\n    5. 最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA\n       遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB\n       相遇为止，此时它们指向的节点就是链表的交点。\n\n  时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {//排除特殊情况\n            return null;\n        }\n        ListNode pA = headA, pB = headB;//定义双指针\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;//return pB当然也一样，并且不会漏掉为null的情况\n    }\n}\n```\n\n# 四、总结\n\n- 我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种\" 我去！还能这样！\"的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。","source":"_posts/链表_01_相交链表.md","raw":"---\ntitle: '相交链表'\ndate: '2023-04-08'\ndescription: '一个有意思的链表相关算法题目 - 相交链表'\ncover: 'https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png'\ncategories:\n\n- 数据结构与算法\n\ntags:\n\n- Java\n- 数据结构与算法\n- 链表\n- 双指针\n\n---\n\n> 链表（Linked List）是一种用于存储元素的线性数据结构，不同于数组，链表中的元素并不是在内存中连续存储的。链表通过使用指针来连接每个元素，使其成为一个链式结构。相比于数组，链表具有更好的插入和删除效率，适用于需要频繁进行插入和删除操作的场景。在今天的博客中，我们将详细介绍链表的基本概念、操作及常见算法应用，希望能够对读者加深对链表的理解和认识。\n\n# 一、题目\n\n给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n\n图示两个链表在节点 c1 开始相交：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n题目数据保证整个链式结构中不存在环。\n注意，函数返回结果后，链表必须保持其原始结构。\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/intersection-of-two-linked-lists\n\n读者可以先暂停思考一下，看看自己自己有没有解题的思路。\n\n# 二、思路\n\n## 2.1 确定算法\n\n首先，我们先选择使用什么样的算法来求解此题。\n\n### 2.1.1 哈希集合\n\n- 我第一眼看到这个题目的时候，想到的是使用**哈希集合**来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。\n- 然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：\n    1. 如果当前节点不在哈希集合中，则继续遍历下一个节点；\n    2. 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。\n\n- 如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。\n\n上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。\n\n### 2.1.2 双指针\n\n- 今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。\n- 有些同学可能不知道双指针是啥，或者还是第一次听到**指针**这个概念。\n    - 指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。\n- 学过C语言的都知道，指针是个相对麻烦的东西。但是**双指针**中的'指针'并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）\n    - 使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。\n    - 一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。\n\n举个例子可能更有利于理解，下面是一个使用双指针技巧[判断字符串是否为回文字符串](https://leetcode.cn/problems/valid-palindrome/)的算法：\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        StringBuffer sgood = new StringBuffer();\n        int length = s.length();\n        for (int i = 0; i < length; i++) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) {\n                sgood.append(Character.toLowerCase(ch));\n            }\n        }\n        int n = sgood.length();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n}\n```\n\n## 2.2 算法分析\n\n可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。\n\n### 2.2.1 定义指针\n\n- 再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。\n- 我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们**保持原始的链表结构！** 所以不建议直接使用链表的头结点。\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        ListNode pA = headA;\n        ListNode pB = headB;\n        /*  省略  */\n    }\n}\n```\n\n### 2.2.2 核心算法\n\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /*  省略  */\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        /*  省略  */\n    }\n}\n```\n\n- 上面的代码就是整个算法的灵魂，解释一下：\n- pA = pA == null ? headB : pA.next;\n    - 这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。\n- pB = pB == null ? headA : pB.next;\n    - 这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。\n\n  自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。\n\n### 2.2.3 思路总结\n\n- Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：\n\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWrsv.png\">\n\n- 做个大白话分析：\n    1. 首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；\n    2. 然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；\n    3. 如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；\n    4. 如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和\n       pB 相遇时，它们所遍历的路程长度相等；\n    5. 最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA\n       遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB\n       相遇为止，此时它们指向的节点就是链表的交点。\n\n  时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。\n\n# 三、题解\n\n- 下面就是一个完整的解题算法：\n\n```Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {//排除特殊情况\n            return null;\n        }\n        ListNode pA = headA, pB = headB;//定义双指针\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;//return pB当然也一样，并且不会漏掉为null的情况\n    }\n}\n```\n\n# 四、总结\n\n- 我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种\" 我去！还能这样！\"的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。","slug":"链表_01_相交链表","published":1,"updated":"2023-07-20T00:28:57.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllblkyup001tm7hoa2n80gb1","content":"<blockquote>\n<p>链表（Linked List）是一种用于存储元素的线性数据结构，不同于数组，链表中的元素并不是在内存中连续存储的。链表通过使用指针来连接每个元素，使其成为一个链式结构。相比于数组，链表具有更好的插入和删除效率，适用于需要频繁进行插入和删除操作的场景。在今天的博客中，我们将详细介绍链表的基本概念、操作及常见算法应用，希望能够对读者加深对链表的理解和认识。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n<p>题目数据保证整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须保持其原始结构。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists\">https://leetcode.cn/problems/intersection-of-two-linked-lists</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么样的算法来求解此题。</p>\n<h3 id=\"2-1-1-哈希集合\"><a href=\"#2-1-1-哈希集合\" class=\"headerlink\" title=\"2.1.1 哈希集合\"></a>2.1.1 哈希集合</h3><ul>\n<li><p>我第一眼看到这个题目的时候，想到的是使用<strong>哈希集合</strong>来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。</p>\n</li>\n<li><p>然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：</p>\n<ol>\n<li>如果当前节点不在哈希集合中，则继续遍历下一个节点；</li>\n<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。</li>\n</ol>\n</li>\n<li><p>如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。</p>\n</li>\n</ul>\n<p>上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。</p>\n<h3 id=\"2-1-2-双指针\"><a href=\"#2-1-2-双指针\" class=\"headerlink\" title=\"2.1.2 双指针\"></a>2.1.2 双指针</h3><ul>\n<li>今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。</li>\n<li>有些同学可能不知道双指针是啥，或者还是第一次听到<strong>指针</strong>这个概念。<ul>\n<li>指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。</li>\n</ul>\n</li>\n<li>学过C语言的都知道，指针是个相对麻烦的东西。但是<strong>双指针</strong>中的’指针’并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）<ul>\n<li>使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。</li>\n<li>一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子可能更有利于理解，下面是一个使用双指针技巧<a href=\"https://leetcode.cn/problems/valid-palindrome/\">判断字符串是否为回文字符串</a>的算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">sgood</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class=\"line\">                sgood.append(Character.toLowerCase(ch));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sgood.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++left;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。</p>\n<h3 id=\"2-2-1-定义指针\"><a href=\"#2-2-1-定义指针\" class=\"headerlink\" title=\"2.2.1 定义指针\"></a>2.2.1 定义指针</h3><ul>\n<li>再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</li>\n<li>我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们<strong>保持原始的链表结构！</strong> 所以不建议直接使用链表的头结点。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pB</span> <span class=\"operator\">=</span> headB;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-核心算法\"><a href=\"#2-2-2-核心算法\" class=\"headerlink\" title=\"2.2.2 核心算法\"></a>2.2.2 核心算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面的代码就是整个算法的灵魂，解释一下：</p>\n</li>\n<li><p>pA = pA == null ? headB : pA.next;</p>\n<ul>\n<li>这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。</li>\n</ul>\n</li>\n<li><p>pB = pB == null ? headA : pB.next;</p>\n<ul>\n<li>这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。</li>\n</ul>\n<p>自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-3-思路总结\"><a href=\"#2-2-3-思路总结\" class=\"headerlink\" title=\"2.2.3 思路总结\"></a>2.2.3 思路总结</h3><ul>\n<li>Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWrsv.png\">\n\n<ul>\n<li><p>做个大白话分析：</p>\n<ol>\n<li>首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；</li>\n<li>然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；</li>\n<li>如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；</li>\n<li>如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和<br>pB 相遇时，它们所遍历的路程长度相等；</li>\n<li>最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA<br>遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB<br>相遇为止，此时它们指向的节点就是链表的交点。</li>\n</ol>\n<p>时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。</p>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">null</span> || headB == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA, pB = headB;<span class=\"comment\">//定义双指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pA;<span class=\"comment\">//return pB当然也一样，并且不会漏掉为null的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种” 我去！还能这样！”的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"静态网站生成器","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、灵活、简单易用"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>链表（Linked List）是一种用于存储元素的线性数据结构，不同于数组，链表中的元素并不是在内存中连续存储的。链表通过使用指针来连接每个元素，使其成为一个链式结构。相比于数组，链表具有更好的插入和删除效率，适用于需要频繁进行插入和删除操作的场景。在今天的博客中，我们将详细介绍链表的基本概念、操作及常见算法应用，希望能够对读者加深对链表的理解和认识。</p>\n</blockquote>\n<h1 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h1><p>给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\">\n\n<p>题目数据保证整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须保持其原始结构。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists\">https://leetcode.cn/problems/intersection-of-two-linked-lists</a></p>\n<p>读者可以先暂停思考一下，看看自己自己有没有解题的思路。</p>\n<h1 id=\"二、思路\"><a href=\"#二、思路\" class=\"headerlink\" title=\"二、思路\"></a>二、思路</h1><h2 id=\"2-1-确定算法\"><a href=\"#2-1-确定算法\" class=\"headerlink\" title=\"2.1 确定算法\"></a>2.1 确定算法</h2><p>首先，我们先选择使用什么样的算法来求解此题。</p>\n<h3 id=\"2-1-1-哈希集合\"><a href=\"#2-1-1-哈希集合\" class=\"headerlink\" title=\"2.1.1 哈希集合\"></a>2.1.1 哈希集合</h3><ul>\n<li><p>我第一眼看到这个题目的时候，想到的是使用<strong>哈希集合</strong>来辅助解决这个问题，首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。</p>\n</li>\n<li><p>然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中，两种情况：</p>\n<ol>\n<li>如果当前节点不在哈希集合中，则继续遍历下一个节点；</li>\n<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，则该节点就是我们要的答案，返回该节点。</li>\n</ol>\n</li>\n<li><p>如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。</p>\n</li>\n</ul>\n<p>上面就是使用哈希集合来进行求解的一个思路分析，并不难理解，感兴趣的同学可以自己尝试写一下对应的算法代码。</p>\n<h3 id=\"2-1-2-双指针\"><a href=\"#2-1-2-双指针\" class=\"headerlink\" title=\"2.1.2 双指针\"></a>2.1.2 双指针</h3><ul>\n<li>今天我们不谈使用哈希集合的解法，而是选择使用双指针技巧来进行求解。</li>\n<li>有些同学可能不知道双指针是啥，或者还是第一次听到<strong>指针</strong>这个概念。<ul>\n<li>指针：一种用于存储和访问内存地址的数据类型，可以指向任何数据类型（如int、float、double等）的内存地址。指针变量可以用来间接访问存储在该地址上的值。指针常常被用于动态内存管理、传递参数和数据结构中，特别是链表和树等。</li>\n</ul>\n</li>\n<li>学过C语言的都知道，指针是个相对麻烦的东西。但是<strong>双指针</strong>中的’指针’并不一定指向某个内存地址，它可以是数组的索引、可以是字符串的某个字符的索引、可以是某个链表节点等等（虽然索引在根本上也是内存地址，这里不深究）<ul>\n<li>使用双指针可以很好的帮我们解决一些数组和链表方面的问题，并且使用起来也很方便，经过后面的算法分析后相信你会有一个比较深的感悟。</li>\n<li>一般来说，如果问题需要定位两个指针在数组或链表上的位置，并要求这两个指针相互配合，分别从两端向中间遍历以达到某种目的，就可以考虑使用双指针算法。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子可能更有利于理解，下面是一个使用双指针技巧<a href=\"https://leetcode.cn/problems/valid-palindrome/\">判断字符串是否为回文字符串</a>的算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">sgood</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class=\"line\">                sgood.append(Character.toLowerCase(ch));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sgood.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++left;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h2><p>可能现在你对双指针依然只有个模糊的概念，没关系，进行算法分析将有助于我们进一步理解双指针的含义。</p>\n<h3 id=\"2-2-1-定义指针\"><a href=\"#2-2-1-定义指针\" class=\"headerlink\" title=\"2.2.1 定义指针\"></a>2.2.1 定义指针</h3><ul>\n<li>再看一下题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</li>\n<li>我们先来定义两个指针：分别指向headA和headB。需要注意，大多数链表的题目都要求我们<strong>保持原始的链表结构！</strong> 所以不建议直接使用链表的头结点。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pB</span> <span class=\"operator\">=</span> headB;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-核心算法\"><a href=\"#2-2-2-核心算法\" class=\"headerlink\" title=\"2.2.2 核心算法\"></a>2.2.2 核心算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*  省略  */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面的代码就是整个算法的灵魂，解释一下：</p>\n</li>\n<li><p>pA = pA == null ? headB : pA.next;</p>\n<ul>\n<li>这段代码翻译一下：先判断pA是否为null，如果为null，则pA指向headB的头节点，否则，pA指向pA的下一个节点。</li>\n</ul>\n</li>\n<li><p>pB = pB == null ? headA : pB.next;</p>\n<ul>\n<li>这段代码同理：先判断pB是否为null，如果为null，则pB指向headA的头节点，否则，pB指向pB的下一个节点。</li>\n</ul>\n<p>自始至终，没有改变headA和headB中任意一个节点的指向，即保留了原始的链表结构。同时，解决了问题，直接return pA或者pB就得到了我们需要的那个相交节点（如果存在），否则会返回null（此时pA和pB也都为null）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-3-思路总结\"><a href=\"#2-2-3-思路总结\" class=\"headerlink\" title=\"2.2.3 思路总结\"></a>2.2.3 思路总结</h3><ul>\n<li>Amazing！怎么回事呢？这个要用文字解释起来有一点点麻烦，我们直接看图（图是评论区的，我觉得画的挺好）：</li>\n</ul>\n<img src=\"https://www.helloimg.com/images/2023/07/20/oAWrsv.png\">\n\n<ul>\n<li><p>做个大白话分析：</p>\n<ol>\n<li>首先，我们维护两个指针 pA 和 pB，分别指向链表 A 和链表 B 的头节点；</li>\n<li>然后，同时遍历链表 A 和链表 B，每次让 pA 和 pB 分别向后移动一个节点，直到其中一个链表到达链表尾部（即为 null）为止；</li>\n<li>如果两个链表不相交，则 pA 和 pB 会同时到达各自链表的尾节点，此时返回 null；</li>\n<li>如果两个链表相交，则在某个节点处 pA 和 pB 会相遇。此时，pA 移动的距离等于链表 B 头部到交点的距离加上从交点到相遇点的距离，pB 移动的距离等于链表 A 头部到交点的距离加上从交点到相遇点的距离。所以，当 pA 和<br>pB 相遇时，它们所遍历的路程长度相等；</li>\n<li>最后，让 pA 和 pB 分别指向另一个链表的头节点，然后再次遍历两个链表，直到它们相遇。这样做可以使 pA 和 pB 在第二次遍历时同步，继续前进直到到达交点。具体来说，在第一次遍历时，如果 pA<br>遍历完了自己的链表但还没有找到交点，则将 pA 指向另一个链表的头节点；同理，如果 pB 遍历完了自己的链表但还没有找到交点，则将 pB 指向另一个链表的头节点。然后，继续遍历两个链表，直到 pA 和 pB<br>相遇为止，此时它们指向的节点就是链表的交点。</li>\n</ol>\n<p>时间复杂度为 O(m+n)，空间复杂度为 O(1)。在实际工程中，双指针相遇法还可以用于解决其他的链表问题，如判断链表是否成环并找到环的起点等。</p>\n</li>\n</ul>\n<h1 id=\"三、题解\"><a href=\"#三、题解\" class=\"headerlink\" title=\"三、题解\"></a>三、题解</h1><ul>\n<li>下面就是一个完整的解题算法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">null</span> || headB == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//排除特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pA</span> <span class=\"operator\">=</span> headA, pB = headB;<span class=\"comment\">//定义双指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">            pA = pA == <span class=\"literal\">null</span> ? headB : pA.next;</span><br><span class=\"line\">            pB = pB == <span class=\"literal\">null</span> ? headA : pB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pA;<span class=\"comment\">//return pB当然也一样，并且不会漏掉为null的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><ul>\n<li>我最开始确实没有想出这种解法，但在看懂这个双指针解法后，有种” 我去！还能这样！”的感觉，所以我就想把这道题记录一下，希望下次遇到类似的题目也能想出这样巧妙的写法。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllblkyrt0008m7hodd3mdsca","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkytk000fm7ho70154ehh"},{"post_id":"cllblkyri0001m7ho7cpig417","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkytm000jm7ho9z2xcye3"},{"post_id":"cllblkyrm0003m7ho9db6fj8u","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkytn000mm7hode7t0kfi"},{"post_id":"cllblkytj000em7hob5otar2w","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyu7000pm7ho017hg0iz"},{"post_id":"cllblkyrr0007m7ho4jwtc3m8","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyu8000rm7ho1rvqgdwh"},{"post_id":"cllblkyto000om7ho20pl0si9","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyuc000xm7ho7p6eb8ou"},{"post_id":"cllblkyrv0009m7ho6uz26t7y","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyue0012m7hobu7s5qxu"},{"post_id":"cllblkyu8000qm7hogbalazqo","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyuf0015m7hogha6hcua"},{"post_id":"cllblkyti000dm7ho0yxldi9e","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyuh0019m7ho1a4td780"},{"post_id":"cllblkyub000wm7hocrzwewlz","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyuj001bm7hohgcg3bls"},{"post_id":"cllblkyud0011m7hohyhpf6hu","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyuk001fm7hogmkjfyic"},{"post_id":"cllblkytl000im7hoe9125wan","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyum001im7hodaro45pb"},{"post_id":"cllblkyuf0014m7hohdza4o41","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyun001nm7hodelvefqi"},{"post_id":"cllblkytm000km7ho26ze0yy4","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyup001qm7ho1l87ajsc"},{"post_id":"cllblkyuk001em7hodcnr2qa6","category_id":"cllblkyro0004m7ho83ykhzuw","_id":"cllblkyuq001um7hoeawh4keq"},{"post_id":"cllblkyu9000um7hohmuq9q49","category_id":"cllblkyuj001cm7hoabpq2522","_id":"cllblkyur001vm7ho3wmkhe4k"},{"post_id":"cllblkyul001hm7hod81k0se5","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyvf001xm7ho9pjoamuz"},{"post_id":"cllblkyun001mm7hoax6lc9t9","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyvg001zm7ho1qpaacsk"},{"post_id":"cllblkyuh0018m7ho42ac65hm","category_id":"cllblkyum001jm7hoe2ubecxy","_id":"cllblkyvg0021m7ho7zcj7zun"},{"post_id":"cllblkyuo001pm7hod0s2ceck","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyvg0024m7hocrnrgdep"},{"post_id":"cllblkyup001tm7hoa2n80gb1","category_id":"cllblkytn000lm7ho9dbk0vc7","_id":"cllblkyvg0025m7ho82rlbb1a"},{"post_id":"cllblkyui001am7hoga4c73iz","category_id":"cllblkyum001jm7hoe2ubecxy","_id":"cllblkyvh0027m7hoetac035n"}],"PostTag":[{"post_id":"cllblkyri0001m7ho7cpig417","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyth000cm7hoc256cst6"},{"post_id":"cllblkyrm0003m7ho9db6fj8u","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyub000vm7hoar0j8cqq"},{"post_id":"cllblkyrm0003m7ho9db6fj8u","tag_id":"cllblkytl000hm7hogz2l5fya","_id":"cllblkyuc000zm7ho1e1b5fsy"},{"post_id":"cllblkyrm0003m7ho9db6fj8u","tag_id":"cllblkyto000nm7ho852j33de","_id":"cllblkyue0013m7hofcu72yrd"},{"post_id":"cllblkyrr0007m7ho4jwtc3m8","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyul001gm7ho4se7gmjh"},{"post_id":"cllblkyrr0007m7ho4jwtc3m8","tag_id":"cllblkytl000hm7hogz2l5fya","_id":"cllblkyum001km7hoeyog8tqv"},{"post_id":"cllblkyrr0007m7ho4jwtc3m8","tag_id":"cllblkyto000nm7ho852j33de","_id":"cllblkyuo001om7hocic545fh"},{"post_id":"cllblkyrt0008m7hodd3mdsca","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvg001ym7ho7f1c6x3m"},{"post_id":"cllblkyrt0008m7hodd3mdsca","tag_id":"cllblkytl000hm7hogz2l5fya","_id":"cllblkyvg0020m7ho4be9dcra"},{"post_id":"cllblkyrt0008m7hodd3mdsca","tag_id":"cllblkyto000nm7ho852j33de","_id":"cllblkyvg0023m7ho6d9b5okj"},{"post_id":"cllblkyrv0009m7ho6uz26t7y","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvh0028m7hoberjh3la"},{"post_id":"cllblkyrv0009m7ho6uz26t7y","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvh0029m7hocdcidwla"},{"post_id":"cllblkyrv0009m7ho6uz26t7y","tag_id":"cllblkyvg0022m7ho5in4eof6","_id":"cllblkyvh002bm7hohn3i84vv"},{"post_id":"cllblkyti000dm7ho0yxldi9e","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvi002dm7hoclz6c10f"},{"post_id":"cllblkyti000dm7ho0yxldi9e","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvi002em7ho3b355u98"},{"post_id":"cllblkyti000dm7ho0yxldi9e","tag_id":"cllblkyvh002am7hohkj33g5g","_id":"cllblkyvi002gm7ho8h1w0qw0"},{"post_id":"cllblkytj000em7hob5otar2w","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvj002im7ho5xle9gv7"},{"post_id":"cllblkytj000em7hob5otar2w","tag_id":"cllblkytl000hm7hogz2l5fya","_id":"cllblkyvj002jm7hodw721gpu"},{"post_id":"cllblkytj000em7hob5otar2w","tag_id":"cllblkyto000nm7ho852j33de","_id":"cllblkyvj002lm7ho9p8493n8"},{"post_id":"cllblkytl000im7hoe9125wan","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvk002nm7hob676fjm4"},{"post_id":"cllblkytl000im7hoe9125wan","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvk002om7hocgyo9w16"},{"post_id":"cllblkytl000im7hoe9125wan","tag_id":"cllblkyvh002am7hohkj33g5g","_id":"cllblkyvk002qm7hof2bmgi0v"},{"post_id":"cllblkytm000km7ho26ze0yy4","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvk002sm7hofs2g5yxj"},{"post_id":"cllblkytm000km7ho26ze0yy4","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvk002tm7ho91n92tea"},{"post_id":"cllblkytm000km7ho26ze0yy4","tag_id":"cllblkyvk002pm7ho3nnp3g2j","_id":"cllblkyvl002vm7hoepeoahr9"},{"post_id":"cllblkyto000om7ho20pl0si9","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvl002xm7ho7ygydb4l"},{"post_id":"cllblkyto000om7ho20pl0si9","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvl002ym7hohp3ghwm1"},{"post_id":"cllblkyto000om7ho20pl0si9","tag_id":"cllblkyvk002um7ho91d0fh5y","_id":"cllblkyvl0030m7hogj9qf1rw"},{"post_id":"cllblkyu8000qm7hogbalazqo","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvm0032m7hobkyi7zho"},{"post_id":"cllblkyu8000qm7hogbalazqo","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvm0033m7ho7kcw5j4v"},{"post_id":"cllblkyu8000qm7hogbalazqo","tag_id":"cllblkyvl002zm7ho82a5bos8","_id":"cllblkyvm0035m7hoaztu632j"},{"post_id":"cllblkyu9000um7hohmuq9q49","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvn0038m7hocw1rfw1m"},{"post_id":"cllblkyu9000um7hohmuq9q49","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvn0039m7ho15bm8fnf"},{"post_id":"cllblkyu9000um7hohmuq9q49","tag_id":"cllblkyvm0034m7ho10yw2ez9","_id":"cllblkyvo003bm7hogsp08h61"},{"post_id":"cllblkyu9000um7hohmuq9q49","tag_id":"cllblkyvm0036m7ho5s1w0fhw","_id":"cllblkyvo003cm7hoadk286wn"},{"post_id":"cllblkyub000wm7hocrzwewlz","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvo003em7hoh3lodrpm"},{"post_id":"cllblkyub000wm7hocrzwewlz","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvo003fm7hod8eh7kbe"},{"post_id":"cllblkyub000wm7hocrzwewlz","tag_id":"cllblkyvl002zm7ho82a5bos8","_id":"cllblkyvp003hm7hogzzch13k"},{"post_id":"cllblkyud0011m7hohyhpf6hu","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvp003jm7ho1sb5gvb8"},{"post_id":"cllblkyud0011m7hohyhpf6hu","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvp003km7ho6cbr4eqm"},{"post_id":"cllblkyud0011m7hohyhpf6hu","tag_id":"cllblkyvl002zm7ho82a5bos8","_id":"cllblkyvp003mm7hoa6dc7yks"},{"post_id":"cllblkyuf0014m7hohdza4o41","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvr003pm7hoaaffez35"},{"post_id":"cllblkyuf0014m7hohdza4o41","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvr003qm7hog2dw8u8w"},{"post_id":"cllblkyuf0014m7hohdza4o41","tag_id":"cllblkyvl002zm7ho82a5bos8","_id":"cllblkyvs003sm7ho43kbeycg"},{"post_id":"cllblkyuf0014m7hohdza4o41","tag_id":"cllblkyvm0034m7ho10yw2ez9","_id":"cllblkyvs003tm7hoe2ls6rpv"},{"post_id":"cllblkyuh0018m7ho42ac65hm","tag_id":"cllblkyvr003om7ho3gar14vh","_id":"cllblkyvs003vm7hobo49dazd"},{"post_id":"cllblkyui001am7hoga4c73iz","tag_id":"cllblkyvr003rm7ho087a7ohl","_id":"cllblkyvs003wm7hoakcl9znz"},{"post_id":"cllblkyuk001em7hodcnr2qa6","tag_id":"cllblkyrw000bm7ho5vko8vjf","_id":"cllblkyvt003zm7hoc9cg95y4"},{"post_id":"cllblkyuk001em7hodcnr2qa6","tag_id":"cllblkyvl002zm7ho82a5bos8","_id":"cllblkyvt0040m7ho15wpcata"},{"post_id":"cllblkyuk001em7hodcnr2qa6","tag_id":"cllblkyvk002rm7ho4mcxhlv8","_id":"cllblkyvu0042m7ho91jrbeer"},{"post_id":"cllblkyul001hm7hod81k0se5","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvu0043m7ho951mci0a"},{"post_id":"cllblkyul001hm7hod81k0se5","tag_id":"cllblkyvt003ym7ho3eaqaz75","_id":"cllblkyvu0045m7ho153w303d"},{"post_id":"cllblkyun001mm7hoax6lc9t9","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvu0046m7ho0ehva1q7"},{"post_id":"cllblkyun001mm7hoax6lc9t9","tag_id":"cllblkyvt003ym7ho3eaqaz75","_id":"cllblkyvv0048m7hoeb2a4k9x"},{"post_id":"cllblkyuo001pm7hod0s2ceck","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvw004am7hof5x57sx7"},{"post_id":"cllblkyuo001pm7hod0s2ceck","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvw004bm7ho8s3yhoxs"},{"post_id":"cllblkyuo001pm7hod0s2ceck","tag_id":"cllblkyvv0047m7hog5kx8i23","_id":"cllblkyvw004dm7ho37no9hum"},{"post_id":"cllblkyup001tm7hoa2n80gb1","tag_id":"cllblkyrq0005m7hog6m9h259","_id":"cllblkyvy004fm7ho1e9gflbg"},{"post_id":"cllblkyup001tm7hoa2n80gb1","tag_id":"cllblkyur001wm7ho80zt4z5m","_id":"cllblkyvy004gm7ho8ncc9kbc"},{"post_id":"cllblkyup001tm7hoa2n80gb1","tag_id":"cllblkyvw004cm7ho8lme0z1h","_id":"cllblkyvy004hm7ho6e4g90cn"},{"post_id":"cllblkyup001tm7hoa2n80gb1","tag_id":"cllblkyvw004em7hohbvwagam","_id":"cllblkyvy004im7ho535c41rz"}],"Tag":[{"name":"Java","_id":"cllblkyrq0005m7hog6m9h259"},{"name":"Kotlin","_id":"cllblkyrw000bm7ho5vko8vjf"},{"name":"面向对象编程","_id":"cllblkytl000hm7hogz2l5fya"},{"name":"函数式编程","_id":"cllblkyto000nm7ho852j33de"},{"name":"数据结构与算法","_id":"cllblkyur001wm7ho80zt4z5m"},{"name":"二叉树","_id":"cllblkyvg0022m7ho5in4eof6"},{"name":"动态规划","_id":"cllblkyvh002am7hohkj33g5g"},{"name":"回溯","_id":"cllblkyvk002pm7ho3nnp3g2j"},{"name":"Android","_id":"cllblkyvk002rm7ho4mcxhlv8"},{"name":"并发编程","_id":"cllblkyvk002um7ho91d0fh5y"},{"name":"Jetpack","_id":"cllblkyvl002zm7ho82a5bos8"},{"name":"数据库","_id":"cllblkyvm0034m7ho10yw2ez9"},{"name":"SQLite","_id":"cllblkyvm0036m7ho5s1w0fhw"},{"name":"ChatGPT","_id":"cllblkyvr003om7ho3gar14vh"},{"name":"Blog","_id":"cllblkyvr003rm7ho087a7ohl"},{"name":"栈","_id":"cllblkyvt003ym7ho3eaqaz75"},{"name":"贪心","_id":"cllblkyvv0047m7hog5kx8i23"},{"name":"链表","_id":"cllblkyvw004cm7ho8lme0z1h"},{"name":"双指针","_id":"cllblkyvw004em7hohbvwagam"}]}}