---
title: 'Java集合框架体系概述'
date: '2023-07-03'
description: '介绍 Java 编程语言中的集合框架，包括列表、集合、队列、映射等。'
cover: 'https://z1.ax1x.com/2023/09/26/pP7jakQ.png'
categories:

- 编程开发

tags:

- Java

---

# 一、集合的概念及分类

## 1.1 集合的概念

- 在Java中，集合（Collection）是一种用于存储和操作对象的容器。它提供了一组接口和类，可以方便地对一组对象进行处理，包括添加、删除、查找、遍历等操作。
- 在本文中，我们将对 Java 集合体系进行概述和介绍，包括集合的分类、常用的集合类和接口，以及它们的特点和用法。

## 1.2 集合的分类

- 集合有多种分类方式，根据`是否有序`、`是否可变`、`是否线程安全`、`单列集合或者双列集合`、`实现的接口`等等，可以分出很多类别。
- 一般来说，使用较多的分类方式是根据`实现的接口`进行分类：
  1. List(列表)：有序、可重复的集合。允许插入多个相同元素，并按照插入顺序进行访问。
  2. Set(集)：无序、不可重复的集合。不允许插入相同元素，并且没有固定的顺序。
  3. Map(映射)：键值对的集合，每个键都唯一。允许根据键快速访问对应的值。
  4. Queue(队列)：实现包括单端队列和双端队列，可以像栈一样实现先进后出（LIFO），也可以像普通队列一样实现先进先出（FIFO）。

- `List`、`Set`、`Map`、`Queue`四个接口是 Java 集合框架的核心接口，涵盖了最常见的数据结构和操作。

# 二、List 接口

## 2.1 总述

- **概念**：继承自 `Collection` 接口，主要用于存储和操作一组对象。
- **特点**：允许按照元素的插入顺序进行访问，每个元素都有一个对应的索引，可以通过索引来获取、修改、删除元素。这意味着可以在List中插入多个相同的元素，并且它们在列表中的位置是有意义的。
- **常见实现类**：
  1. ArrayList：基于动态数组实现，它具有随机访问的能力，可以快速根据索引获取元素。
  2. LinkedList：基于链表实现，它支持高效的插入和删除操作。
  3. Vector：基于动态数组实现，与 ArrayList 各方面高度相似，但是不同的是 Vector 是线程安全的，而 ArrayList 不是。
  4. Stack：基于 Vector 实现的后进先出（LIFO）的堆栈数据结构。
- **实现类特点**：
  1. 有序
  2. 线程安全/不安全都有
  3. 可以存储 null 元素
  4. 允许重复元素

## 2.2 ArrayList

- **概念**：基于动态数组实现的集合类。
- **特点**：
  1. 是否有序：`有序`，按照插入顺序存储元素。 
  2. 线程安全：线程`不安全`。 
  3. 可否为null：`允许存储null`元素。 
  4. 可否元素重复：`允许重复`元素。 
  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`1.5倍`。
  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。
  7. 应用场景：常用于需要频繁访问和修改集合中的元素，并且对元素的插入顺序有要求的场景，同时也适用于大部分普通的集合操作。
- **常用方法**：
  1. add(E element)：将指定元素添加到ArrayList的末尾。 
  2. remove(Object element)：从ArrayList中移除指定的元素。 
  3. get(int index)：获取指定索引位置的元素。 
  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 
  5. size()：获取ArrayList中元素的数量。 
  6. isEmpty()：检查ArrayList是否为空。 
  7. clear()：清空ArrayList中的所有元素。 
  8. indexOf(Object element)：返回指定元素在ArrayList中第一次出现的索引。 
  9. lastIndexOf(Object element)：返回指定元素在ArrayList中最后一次出现的索引。 
  10. contains(Object element)：判断ArrayList是否包含指定的元素。 
  11. toArray()：将ArrayList转换为数组。

## 2.3 LinkedList

- **概念**：基于链表实现的集合类。
- **特点**：
  1. 是否有序：`有序`，按照插入顺序存储元素。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。
  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。
  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。
- **常用方法**：
  1. add(E element)：将指定元素添加到链表的末尾。
  2. addFirst(E element)：将指定元素添加到链表的头部。
  3. addLast(E element)：将指定元素添加到链表的末尾。
  4. remove()：移除并返回链表的第一个元素。
  5. removeFirst()：移除并返回链表的第一个元素。
  6. removeLast()：移除并返回链表的最后一个元素。
  7. get(int index)：返回链表指定位置处的元素。
  8. getFirst()：返回链表的第一个元素，但不移除。
  9. getLast()：返回链表的最后一个元素，但不移除。
  10. size()：获取链表的大小（元素个数）。

## 2.4 Vector

- **概念**：基于动态数组实现的集合类，与ArrayList类似。
- **特点**：
  1. 是否有序：`有序`，按照插入顺序存储元素。
  2. 线程安全：线程`安全`。
  3. 可否为null：`允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。
  6. 底层原理：使用`数组`作为内部数据结构，通过索引实现快速随机访问。
  7. 应用场景：常用于包括多线程环境下的数据操作和需要线程安全的动态扩容集合需求。
- **常用方法**：
  1. add(E element)：将指定元素添加到Vector的末尾。 
  2. remove(Object element)：从Vector中移除指定的元素。 
  3. get(int index)：获取指定索引位置的元素。 
  4. set(int index, E element)：将指定索引位置的元素替换为新的元素。 
  5. size()：获取Vector中元素的数量。 
  6. isEmpty()：检查Vector是否为空。 
  7. clear()：清空Vector中的所有元素。 
  8. indexOf(Object element)：返回指定元素在Vector中的第一个出现位置的索引。 
  9. lastIndexOf(Object element)：返回指定元素在Vector中的最后一个出现位置的索引。 
  10. contains(Object element)：判断Vector是否包含指定的元素。 
  11. iterator()：返回对Vector中元素进行迭代的迭代器。

## 2.5 Stack

- **概念**：基于Vector实现的后进先出（LIFO）的堆栈数据结构。
- **特点**：
  1. 是否有序：`有序`，按照插入顺序存储元素。
  2. 线程安全：线程`安全`。
  3. 可否为null：`允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。
  6. 底层原理：使用`数组`作为内部数据结构，通过压栈和弹栈操作实现元素的添加和删除。
  7. 应用场景：包括逆序操作、回溯算法、括号匹配和函数调用等需要后进先出（LIFO）的数据结构操作。
- **常用方法**：
  1. push(E element)：将元素推入栈顶。 
  2. pop()：弹出栈顶元素并返回该值。 
  3. peek()：获取栈顶元素的值，但不从栈中移除它。 
  4. empty()：检查栈是否为空。 
  5. search(Object element)：查找元素在栈中的位置，并返回距离栈顶的距离（索引从1开始）

# 三、Set 接口

## 3.1 总述

- **概念**：继承自`Collection`接口，用于存储一组唯一的对象，不允许包含重复元素。
- **特点**：每个元素都必须是唯一的。
- **常见实现类**：
  1. HashSet：基于哈希表实现，利用哈希算法来存储和查找元素，具有较快的插入和查询速度。
  2. TreeSet：基于红黑树实现，可以对元素进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。
  3. LinkedHashSet：基于链表和哈希表实现，它保留元素插入的顺序，并且具有快速的查找性能。
- **实现类特点**：
  1. 无/有序都有
  2. 线程不安全
  3. 可以存储 null 元素（但只能为一个）
  4. 不允许重复元素

## 3.2 HashSet

- **概念**：基于哈希表实现的集合类，通过哈希算法存储和查找元素。
- **特点**：
  1. 是否有序：`无序`，不按照插入顺序存储元素。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`允许存储null`元素（只能储存一个）。
  4. 可否元素重复：`不允许重复`元素。
  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。
  6. 底层原理：使用`哈希表`作为内部数据结构，通过哈希值实现快速查找。
  7. 应用场景：去重操作、查找元素的快速性和判断元素是否存在的效率，适用于需要高效地存储和查询唯一元素的场景。
- **常用方法**：
  1. add(E element)：将指定的元素添加到HashSet中。 
  2. remove(Object element)：从HashSet中移除指定的元素。 
  3. contains(Object element)：判断HashSet是否包含指定的元素。 
  4. size()：获取HashSet中元素的数量。 
  5. isEmpty()：检查HashSet是否为空。 
  6. clear()：清空HashSet中的所有元素。 
  7. iterator()：返回对HashSet中元素进行迭代的迭代器。

## 3.3 TreeSet

- **概念**：基于红黑树实现的有序集合类，可以对元素进行排序。
- **特点**：
  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`不允许存储null`元素。
  4. 可否元素重复：`不允许重复`元素。
  5. 扩容机制：红黑树结构`不需要扩容`。
  6. 底层原理：使用`红黑树`作为内部数据结构，保持有序性。
  7. 应用场景：按照自然顺序或自定义比较器排序元素、范围查找和有序遍历等需要有序集合操作的场景。
- **常用方法**：
  1. add(E element)：将指定的元素添加到TreeSet中。 
  2. remove(Object element)：从TreeSet中移除指定的元素。 
  3. contains(Object element)：判断TreeSet是否包含指定的元素。 
  4. size()：获取TreeSet中元素的数量。 
  5. isEmpty()：检查TreeSet是否为空。 
  6. clear()：清空TreeSet中的所有元素。 
  7. iterator()：返回对TreeSet中元素进行迭代的迭代器。 
  8. first()：获取TreeSet中的第一个元素。 
  9. last()：获取TreeSet中的最后一个元素。 
  10. higher(E element)：获取严格大于指定元素的最小元素。 
  11. lower(E element)：获取严格小于指定元素的最大元素。

## 3.4 LinkedHashSet

- **概念**：基于链表和哈希表实现的集合类，保留元素插入的顺序。
- **特点**：
  1. 是否有序：`有序`，根据元素的自然顺序或者自定义比较器进行排序。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`允许存储null`元素（只能储存一个）。
  4. 可否元素重复：`不允许重复`元素。
  5. 扩容机制：在容量不足时自动进行扩容，默认扩容为当前容量的`2倍`。
  6. 底层原理：使用`链表和哈希表组合实现`，通过哈希值和链表维护插入顺序与查找性能。
  7. 应用场景：需要保持元素插入顺序的同时又不允许重复元素的场景，适用于需要按照插入顺序进行遍历和去重操作的情况。
- **常用方法**：
  1. add(E element)：将指定的元素添加到LinkedHashSet中。 
  2. remove(Object element)：从LinkedHashSet中移除指定的元素。 
  3. contains(Object element)：判断LinkedHashSet是否包含指定的元素。 
  4. size()：获取LinkedHashSet中元素的数量。 
  5. isEmpty()：检查LinkedHashSet是否为空。 
  6. clear()：清空LinkedHashSet中的所有元素。 
  7. iterator()：返回对LinkedHashSet中元素进行迭代的迭代器。 
  8. forEach(Consumer action)：对LinkedHashSet中的每个元素执行指定操作。

# 四、Map 接口

## 4.1 总述

- **概念**：用于保存键值对的集合。
- **特点**：每个键都必须是唯一的，但值可以重复。
- **常见实现类**：
  1. HashMap：基于哈希表实现，利用哈希算法来存储和查找键值对，具有较快的插入和查询速度。
  2. TreeMap：基于红黑树实现，可以对键进行排序，且具有较快的插入、删除和查询速度，但需要额外的排序操作。
  3. LinkedHashMap：基于链表和哈希表实现，它保留键值对的插入顺序，并且具有快速的查找性能。
  4. HashTable：基于哈希表实现，类似于HashMap，但线程安全。
  5. Properties：继承自HashTable类，独特地用于操作配置文件，其中的键和值都是字符串类型。
- **实现类特点**：
  1. 无/有序都有
  2. 线程不安全（可通过 Collections 提供的方法进行同步操作）
  3. 允许键为null（但只能有一个），值可以为null
  4. 键唯一，值可重复

## 4.2 HashMap 

- **概念**：基于哈希表实现的集合类，用于存储键值对。
- **特点**：
  1. 是否有序：`无序`，不保证元素的插入顺序和迭代顺序一致。
  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。
  3. 可否为null：`允许存储null键和null值`（键只能储存一个）。
  4. 可否元素重复：`不允许重复`的键，值可以重复。
  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，但并非每次都会触发扩容操作（需要 HashMap 的大小 < 64，并且桶上的元素个数小于8）
  6. 底层原理：使用`数组和链表`或`红黑树（JDK8+）`作为内部数据结构，通过哈希算法来存储和查找键值对。
  7. 应用场景：常用于需要高效的插入、删除和查找操作，并且对元素的顺序没有要求的场景。
- **常用方法**：
  1. put(K key, V value)：将指定的键值对存储在HashMap中。 
  2. get(Object key)：根据键获取对应的值。 
  3. remove(Object key)：根据键移除键值对。 
  4. containsKey(Object key)：判断HashMap是否包含指定的键。 
  5. containsValue(Object value)：判断HashMap是否包含指定的值。 
  6. size()：获取HashMap中键值对的数量。 
  7. isEmpty()：检查HashMap是否为空。 
  8. keySet()：返回HashMap中所有键的Set集合。 
  9. values()：返回HashMap中所有值的Collection集合。 
  10. entrySet()：返回HashMap中所有键值对的Set集合。

## 4.3 TreeMap

- **概念**：基于红黑树（Red-Black Tree）实现的有序集合类，用于存储键值对。
- **特点**：
  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。
  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。
  3. 可否为null：`不允许存储null键`，但`允许存储null值`。
  4. 可否元素重复：`不允许重复`的键，值可以重复。
  5. 扩容机制：没有固定的扩容机制。
  6. 底层原理：使用`红黑树`作为内部数据结构，通过比较器来存储和查找键值对。红黑树是一种自平衡二叉搜索树，能够保持良好的平衡性能，使得插入、删除和查找等操作的时间复杂度为 O(log n)。
  7. 应用场景：常用于需要有序存储并快速查找、删除、插入操作的场景，例如按键进行范围查询、排序等。
- **常用方法**：
  1. put(K key, V value)：将指定的键值对存储在TreeMap中。 
  2. get(Object key)：根据键获取对应的值。 
  3. remove(Object key)：根据键移除键值对。 
  4. containsKey(Object key)：判断TreeMap是否包含指定的键。 
  5. containsValue(Object value)：判断TreeMap是否包含指定的值。 
  6. size()：获取TreeMap中键值对的数量。 
  7. isEmpty()：检查TreeMap是否为空。 
  8. keySet()：返回TreeMap中所有键的Set集合。 
  9. values()：返回TreeMap中所有值的Collection集合。 
  10. entrySet()：返回TreeMap中所有键值对的Set集合。

## 4.4 LinkedHashMap

- **概念**：基于哈希表和双向链表实现的集合类，用于存储键值对。
- **特点**：
  1. 是否有序：`有序`，元素的插入顺序和迭代顺序一致，按键的自然顺序或自定义比较器进行排序。
  2. 线程安全：线程`不安全`。可以使用 Collections.synchronizedMap() 方法进行同步。
  3. 可否为null：`不允许存储null键`，但`允许存储null值`。
  4. 可否元素重复：`不允许重复`的键，值可以重复。
  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍`，并根据插入顺序或访问顺序进行调整。
  6. 底层原理：使用数组和双向链表作为内部数据结构，通过哈希算法来存储和查找键值对，并使用双向链表维护插入顺序或访问顺序，相比于HashMap会略微增加一些额外的空间和维护链表的开销。但它提供了有序的遍历和按访问顺序进行排序的能力。
  7. 应用场景：常用于需要保留元素插入顺序或访问顺序，并且对元素的查找操作有要求的场景，例如LRU（Least Recently Used）缓存实现、记录最近访问的数据等。
- **常用方法**：
  1. put(K key, V value)：将指定的键值对存储在LinkedHashMap中。 
  2. get(Object key)：根据键获取对应的值。 
  3. remove(Object key)：根据键移除键值对。 
  4. containsKey(Object key)：判断LinkedHashMap是否包含指定的键。 
  5. containsValue(Object value)：判断LinkedHashMap是否包含指定的值。 
  6. size()：获取LinkedHashMap中键值对的数量。 
  7. isEmpty()：检查LinkedHashMap是否为空。 
  8. keySet()：返回LinkedHashMap中所有键的Set集合。 
  9. values()：返回LinkedHashMap中所有值的Collection集合。 
  10. entrySet()：返回LinkedHashMap中所有键值对的Set集合。

## 4.5 HashTable

- **概念**：基于哈希算法实现的数据结构，用于存储键值对。
- **特点**：
  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。
  2. 线程安全：线程`安全`。HashTable中的所有操作都是同步的（synchronized修饰）。
  3. 可否为null：`不允许存储null键和null值`，如果存储会抛出NullPointerException。
  4. 可否元素重复：`不允许重复`的键，值可以重复。
  5. 扩容机制：与HashMap相似，在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。
  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。
  7. 应用场景：由于 HashTable 具有线程安全的特性，适用于多线程环境下需要并发访问的场景。然而，由于使用了synchronized关键字进行同步，性能上可能略逊一筹。
- **常用方法**：
  1. put(K key, V value)：将指定的键值对存储在Hashtable中。 
  2. get(Object key)：根据键获取对应的值。 
  3. remove(Object key)：根据键移除键值对。 
  4. containsKey(Object key)：判断Hashtable是否包含指定的键。 
  5. containsValue(Object value)：判断Hashtable是否包含指定的值。 
  6. size()：获取Hashtable中键值对的数量。 
  7. isEmpty()：检查Hashtable是否为空。 
  8. keys()：返回包含所有键的枚举（Enumeration）对象。 
  9. values()：返回包含所有值的Collection对象。 
  10. clear()：清空Hashtable中的所有键值对。

## 4.6 Properties

- **概念**：继承自Hashtable类，用于处理属性文件（.properties）的操作。
- **特点**：
  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。
  2. 线程安全：线程` 不安全`
  3. 可否为null：`允许存储null键和null值`。
  4. 可否元素重复：`允许重复`的键，值也可以重复。
  5. 扩容机制：在达到负载因子（默认为0.75）时，自动进行扩容，会将容量扩大为原来的`2倍+1`。
  6. 底层原理：使用哈希表作为内部数据结构，通过哈希算法计算键的哈希码，并使用数组和链表解决哈希冲突的问题。
  7. 应用场景：Properties常用于读取和操作属性文件（.properties），属性文件通常被用来存储配置信息，例如数据库连接配置、应用程序设置等。
- **常用方法**：
  1. setProperty(String key, String value)：设置属性的键值对，将键和值存储在属性列表中。 
  2. getProperty(String key)：根据键获取属性的值。 
  3. getProperty(String key, String defaultValue)：根据键获取属性的值，如果键不存在，则返回默认值。 
  4. load(InputStream inStream)：从输入流中加载属性列表，将属性文件的内容读取到Properties对象中。 
  5. store(OutputStream out, String comments)：将属性列表写入输出流，将Properties对象的内容写入属性文件。 
  6. getPropertyNames()：获取所有属性的键名，返回一个枚举类型（Enumeration）。 
  7. stringPropertyNames()：获取所有属性的键名，返回一个Set集合。 
  8. remove(Object key)：根据键移除属性。 
  9. containsKey(Object key)：检查属性列表是否包含指定的键。 
  10. containsValue(Object value)：检查属性列表是否包含指定的值。

# 五、Queue 接口

## 5.1 总述

- **概念**：用于表示队列（先进先出）的接口，即保存元素的集合。
- **特点**：元素按照插入顺序排列，并且每个元素都有一个索引（位置）。
- **常见实现类**：
  1. LinkedList：基于链表实现，具有较快的插入和删除速度，适用于经常需要在队列两端进行操作的场景。
  2. ArrayDeque：基于动态数组实现，具有快速的插入和删除速度，适用于需要高效地操作队列元素的场景。
  3. PriorityQueue：基于堆实现，可以按照特定的顺序来访问队列中的元素，而不仅仅是按照插入顺序。
- **实现类特点**：
  1. 有序
  2. 线程不安全
  3. 可以存储 null 元素
  4. 允许重复元素

## 5.2 LinkedList

- **概念**：基于链表实现的集合类。
- **特点**：
  1. 是否有序：`有序`，按照插入顺序存储元素。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：`不需要扩容`，根据需要动态创建新节点。
  6. 底层原理：使用`双向链表`作为内部数据结构，通过节点之间的指针实现元素的添加、删除和访问。
  7. 应用场景：常用于需要频繁地对集合进行插入和删除操作的场景。
- **常用方法**：
  1. add(E element)：将指定元素添加到链表的末尾。 
  2. addFirst(E element)：将指定元素添加到链表的头部。 
  3. addLast(E element)：将指定元素添加到链表的末尾。 
  4. remove()：移除并返回链表的第一个元素。 
  5. removeFirst()：移除并返回链表的第一个元素。 
  6. removeLast()：移除并返回链表的最后一个元素。 
  7. get(int index)：返回链表指定位置处的元素。 
  8. getFirst()：返回链表的第一个元素，但不移除。 
  9. getLast()：返回链表的最后一个元素，但不移除。 
  10. size()：获取链表的大小（元素个数）。

## 5.3 ArrayDeque

- **概念**：ArrayDeque是一种基于动态数组实现的双端队列（double-ended queue），即允许在队列两端进行插入和删除操作的数据结构。
- **特点**：
  1. 是否有序：`无序`，元素的插入顺序和迭代顺序无关。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：在达到容量限制时，会进行自动扩容。扩容时会将当前容量扩大为原始容量的`2倍`。
  6. 底层原理：使用数组作为内部数据结构，通过循环数组实现元素的插入和删除操作。
  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。
- **常用方法**：
  1. addFirst(E element)：将指定元素插入到双端队列的头部。
  2. addLast(E element)：将指定元素插入到双端队列的尾部。 
  3. offerFirst(E element)：将指定元素插入到双端队列的头部，并返回是否成功。 
  4. offerLast(E element)：将指定元素插入到双端队列的尾部，并返回是否成功。 
  5. removeFirst()：移除并返回双端队列的头部元素。 
  6. removeLast()：移除并返回双端队列的尾部元素。 
  7. pollFirst()：移除并返回双端队列的头部元素，如果队列为空则返回null。 
  8. pollLast()：移除并返回双端队列的尾部元素，如果队列为空则返回null。 
  9. getFirst()：返回双端队列的头部元素，但不移除。 
  10. getLast()：返回双端队列的尾部元素，但不移除。 
  11. peekFirst()：返回双端队列的头部元素，如果队列为空则返回null。 
  12. peekLast()：返回双端队列的尾部元素，如果队列为空则返回null。 
  13. size()：获取双端队列的大小（元素个数）。 
  14. isEmpty()：检查双端队列是否为空。

## 5.4 PriorityQueue

- **概念**：PriorityQueue（优先队列）是一种特殊的队列，其中的元素按照优先级进行排序。具有最高优先级的元素始终位于队列的头部。
- **特点**：
  1. 是否有序：`有序`，元素按照优先级进行排序。
  2. 线程安全：线程`不安全`。
  3. 可否为null：`不允许存储null`元素。
  4. 可否元素重复：`允许重复`元素。
  5. 扩容机制：在达到容量限制时，会根据策略进行自动扩容。
  6. 底层原理：通常使用`堆（Heap）`数据结构来实现，具体可以是`二叉堆`或`斐波那契堆`等。
  7. 应用场景：常用于需要高效地在队列两端进行操作的场景，例如任务调度、广度优先搜索等。
- **常用方法**：
  1. add(E element) / offer(E element)：将指定元素插入到队列中。 
  2. remove() / poll()：移除并返回队列头部的元素。 
  3. peek()：返回队列头部的元素，但不移除。 
  4. size()：获取队列的大小（元素个数）。 
  5. isEmpty()：检查队列是否为空。 
  6. clear()：清空队列中的所有元素。 
  7. iterator()：返回用于遍历队列的迭代器。

# 六、总结

- 当涉及到数据结构和容器的选择时，Java中的List、Set、Map和Queue是四个常用的接口。
  1. `List接口`实现了有序、可重复的集合。它的常见实现类包括ArrayList和LinkedList。ArrayList基于数组实现，在随机访问和遍历方面具有良好的性能；而LinkedList则基于链表实现，在插入和删除操作上更加高效。 
  2. `Set接口`实现了无序、不可重复的集合。它的常见实现类有HashSet和TreeSet。HashSet基于哈希表实现，具有快速的查找操作；而TreeSet基于红黑树实现，可以对元素进行排序。 
  3. `Map接口`实现了键值对（key-value pairs）的集合。常见的实现类有HashMap和TreeMap。HashMap基于哈希表实现，通过键值对的哈希值进行快速查找；而TreeMap基于红黑树实现，可以按照键的顺序进行排序。 
  4. `Queue接口`实现了先进先出（FIFO）的队列。常见的实现类有LinkedList和PriorityQueue。LinkedList作为双端队列可实现队列和栈的功能；PriorityQueue基于堆实现，并允许根据元素的优先级进行排序。
- Java的 List、Set、Map 和 Queue 接口及其实现类提供了丰富的数据结构和容器选择，以满足不同的问题需求。选择正确的接口和实现类可以提高程序的性能和效率。