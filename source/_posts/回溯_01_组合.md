---
title: '组合'
date: '2023-05-10'
description: '回溯算法的经典题目 - 组合'
cover: 'https://www.helloimg.com/images/2023/05/10/oxlhYT.jpg'
categories:

- 数据结构与算法

tags:

- Java
- 数据结构与算法
- 回溯

---

> 回溯算法（Backtracking）是一种在搜索过程中寻找问题解答的方法。顾名思义，回溯算法就是在考虑一个问题的所有选项时，使用回溯（即返回原状态）来尝试每个可能的选项，直到找到符合要求的解决方案。需要注意的是，回溯算法只适用于问题的解空间较小，否则其时间复杂度会非常高。在本篇文章中，我们将通过介绍回溯算法的基本概念和简单应用，来阐述这一算法。为了更好地讲解，我们选择了一个回溯算法经典使用场景作为例子。希望本文能够帮助读者更加深入地理解和掌握回溯算法。

# 一、题目

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 `任何顺序` 返回答案。

示例一：

    输入：n = 4, k = 2
      输出：
      [
      [2,4],
      [3,4],
      [2,3],
      [1,2],
      [1,3],
      [1,4],
      ]

示例二：

    输入：n = 1, k = 1
      输出：[[1]]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/combinations/

# 二、思路

## 2.1 暴力枚举

- 题目读起来易懂，但是题目本身并不简单。在 leetcode 上，只要涉及到使用回溯算法的题目，可以发现难度都为`中等`以上。
- 由于回溯本质上仍然是暴力搜索，所以为了能更好的理解回溯算法，我们先从暴力法入手，尝试解决这个问题。

### 2.1.1 举例分析

- 为了方便理解，我们由浅入深，先来看看`n = 3，k = 1`的情况，即从`[1,2,3]`中选`1`个数出来，有多少种组合？
  这个直接一眼能看出来，即`[1],[2],[3]`共三种组合。代码随便写一下：
```java
class Solution {
    public List<List<Integer>> combine() {
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 1; i <= 3; i++) {
          List<Integer> tmp = new ArrayList<>();
          tmp.add(i);
          result.add(tmp);
        }
        return result;
    }
}
```
- 然后，我们来看看`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？
  有数学基础的小伙伴应该能一眼看出组合的个数，即`3`个，学过排列组合就对这个不陌生。
  $$
    C_3^1 = C_3^2
  $$
  但是题目的要求是输出所有组合，并不是单纯求组合个数，因此我们需要用到下面的暴力算法：
```java
class Solution {
    public List<List<Integer>> combine2() {
        List<List<Integer>> result = new ArrayList<>();
        // 为什么是 3 - 1 ？因为我们需要2个数，i = 3 没必要进入循环了
        for (int i = 1; i <= 3 - 1; i++) {
            for (int j = i + 1; j <= 3; j++) {
                List<Integer> tmp = new ArrayList<>();
                tmp.add(i);
                tmp.add(j);
                result.add(tmp);
            }
        }
        return result;
    }
}

```
- 得出的结果为：`[[1, 2], [1, 3], [2, 3]]`

- 最后，我们来看看`n = 4，k = 3`的情况，即从`[1,2,3,4]`中选`3`个数出来，有多少种组合？
```java
class Solution {
    public List<List<Integer>> combine() {
        List<List<Integer>> result = new ArrayList<>();
            for (int i = 1; i <= 4 - 2; i++) {
                for (int j = i + 1; j <= 4 - 1; j++) {
                    for (int k = j + 1; k <= 4; k++) {
                        List<Integer> tmp = new ArrayList<>();
                        tmp.add(i);
                        tmp.add(j);
                        tmp.add(k);
                        result.add(tmp);
                    }
                }
            }
        return result;
    }
}
```
- 得出的结果为：`[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]`

### 2.1.2 总结

- 发现了吗？随着我们需要的组合的个数(k)增加，for循环的个数也在增加，这意味着时间复杂度将会变得非常糟糕，由于 n 和 k 不确定，我们还需要动态的改变for循环的个数。这无疑又增加了编码难度，简直吃力不讨好。
- 这样一通操作下来，面试官肯定会说让你回家等消息了，不要慌，我们接下来看看回溯是如何操作的。

<img src="https://www.helloimg.com/images/2023/05/10/oxMeKY.jpg">

## 2.2 回溯

### 2.2.1 暴力枚举和回溯的区别

- 前面已经提到过，回溯的本质也是暴力枚举，那和普通的暴力枚举有什么区别？我们为什么还要选择这个算法？
- 首先回答第一个问题：回溯和普通的暴力枚举有什么区别？
  1. 暴力枚举算法。通常采用嵌套循环的方式枚举所有可能的情况。适用于数据规模较小的场景。在数据规模较大的时候，这种暴力枚举算法会存在时间复杂度过高的问题，造成程序运行时间过长，甚至超时。
  2. 回溯算法。通常采用递归的方式实现，通过不断尝试并回溯的方式，从所有可能的情况中搜索出符合要求的解。因为它具有回溯的功能，可以排除掉一些明显不符合要求的情况，从而避免了不必要的计算，从而实现了剪枝的功能，减少了计算的时间和空间复杂度。
- 我们为什么还要选择这个算法？
  很简单，大部分都是因为`没得选`。

### 2.2.2 算法核心

- 回溯算法的核心思想是深度优先搜索（DFS）。具体而言，在每一步搜索时，我们将当前节点加入已选列表中，然后递归地搜索下一个节点，直到满足结束条件时返回。接着我们将当前节点回溯，再搜索下一个节点。重复上述步骤，直到遍历完整个状态空间。其中，回溯过程可以通过撤销当前节点的选择来实现。
- 就拿我们今天的组合问题举例，使用回溯算法求解组合问题的具体步骤如下：
  1. 定义状态：我们将每一步选择的结果视为一个状态，可以使用一个列表来记录已选元素。例如，选择`{1,2,3}`作为当前的组合方案，则当前状态为`[1,2,3]`。
  2. 判断结束条件：当选出`k`个元素时，我们得到了一个组合方案，输出该方案并返回上一层继续搜索。
  3. 递归搜索下一步：对于每一个未被选中的元素，我们将其加入已选列表中，并继续递归搜索下一个元素。然后`回溯撤销选择`，再在下一个节点继续搜索。
  4. 剪枝：由于回溯算法的性质，我们需要在搜索时动态剪枝，避免不必要的搜索。具体而言，在每一步选择时，我们需要判断是否符合条件，如果不符则进行剪枝，直接返回上一层。

### 2.2.3 举例分析

- 光说不练假把式，我们来模拟一遍流程：
  就选择`n = 3，k = 2`的情况，即从`[1,2,3]`中选`2`个数出来，有多少种组合？
- 分析
  1. 定义状态。当前初始状态为`[]`，还没开始选择。
  2. 判断结束条件。我们是选择`k = 2`个数，也就是说，当选出的元素达到`2`个时，就得到了一个组合方案
  3. 递归搜索下一步。下面具体分析
  4. 剪枝。下面具体分析
- 具体操作
  1. 当前状态`[]`，可供选择的有`{1,2,3}`。
  2. 选择`1`，当前状态为`[1]`，可供选择的有`{2,3}`。
  3. 选择`2`，当前状态为`[1,2]`，满足结束条件，得到了一个组合方案`[1,2]`。
  4. `回溯，撤销选择2`，当前状态`[1]`，可供选择的有`{3}`。
  5. 选择`3`，当前状态为`[1,3]`，满足结束条件，得到了一个组合方案`[1,3]`。
  6. `回溯，撤销选择3`，当前状态`[1]`，没有可供选择的元素。
  7. `回溯，撤销选择1`，当前状态`[]`，可供选择的有`{2,3}`。
  8. 选择`2`，当前状态为`[2]`，可供选择的有`{3}`。
  9. 选择`3`，当前状态为`[2,3]`，满足结束条件，得到了一个组合方案`[2,3]`。
  10. `回溯，撤销选择3`，当前状态`[2]`，没有可供选择的元素。
  11. `回溯，撤销选择2`，当前状态`[]`，可供选择的有`{3}`。
  12. 剪枝，由于可供选择的元素个数已经小于需要的组合元素个数`k`，抛弃掉后续所有分支。

- 上面的步骤中，第2步到第5步、第6步到第9步、第8步到第9步都参与了递归，每次选择一个元素后，继续递归搜索下一个元素，直到选出需要的k个元素或剪枝退出。在每次递归结束后，都要进行回溯撤销选择操作，并返回上一层继续搜索下一个元素。
- 用文字来描述递归回溯操作实在太过抽象，本身回溯操作就非常的烧脑子，说得越多越乱，因此读者一定要自己动手画一下流程，加深对每一步操作的理解。

<img src="https://www.helloimg.com/images/2023/07/19/oA2dUh.jpg" width="30%">

### 2.2.4 总结

- 在理解清楚每一个步骤之后，可以发现回溯确实明显是一种暴力枚举方案，但是呢，相比于传统的暴力枚举算法，它更加高效、灵活，具有极强的泛用性。
- 还是没有体会到回溯相比传统暴力枚举算法的好处？没关系，下面的实操代码也许能帮助你感受二者的区别。

# 三、题解

- 一但涉及到递归，对于初学者来说编码都会是灾难级的。但是没关系，我会尽量在所有复杂的地方都写上注释，让代码更容易理解。
- `强烈建议`在IDE中打断点进行 Debug 调试！一步一步观察数据的变化，会极大的帮助你理解递归和回溯的操作。

- 下面就是一个组合问题的Java回溯算法代码：
```Java
class Solution {
    // 用来暂存满足条件的组合
    List<Integer> path = new ArrayList<>();
    // 最终的所有组合集合
    List<List<Integer>> result = new ArrayList<>();
  
    public List<List<Integer>> combine(int n, int k) {
      // 回溯操作，从1开始确认每一个数字是否可选
      backTracking(n, k, 1);
      return result;
    }
  
    // 回溯核心代码
    private void backTracking(int n, int k, int startIndex) {
        // 递归终止条件
        if (path.size() == k) {
          // 满足条件，保存当前结果到result中
          result.add(new ArrayList(path));
          return; // 结束当前函数调用，进行回溯操作
        }
    
        // 剪枝操作，部分叶子结点不可能满足条件，可以不参与回溯操作
        // 这里startIndex表示当前可选择的范围起始数字
        // 由于最终组合的长度为k，所以剩下的数字个数应该 >= 组合还需要的数字个数 (k - path.size())
        // 故剩下的数字范围是 [startIndex, n - (k - path.size()) + 1]
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
          path.add(i); // 处理节点，将当前数字加入path中
          backTracking(n, k, i + 1); // 递归，继续处理下一位数字
          path.remove(path.size() - 1); // 回溯，撤销处理的节点，进行回溯操作
        }
    }
}
```
- 需要注意的地方：
  1. 函数参数startIndex表示当前可选择的范围起始数字，而不是当前处理的数字。
  2. 对于每一次满足条件的结果，需要将结果的一个拷贝new ArrayList(path)添加到最终结果中。如果直接添加path，会在回溯时对结果进行修改，导致最终结果出错（由于回溯操作最后都会清空暂存数组，最终结果将全为空集`[]`）。

# 四、总结

- 回溯算法是求解组合问题的一种常用算法。对于组合问题，我们可以通过深度优先搜索的方式进行求解，并在实现过程中注意剪枝等优化措施。