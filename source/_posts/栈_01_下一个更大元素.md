---
title: '下一个更大元素'
date: '2023-04-28'
description: '使用单调栈辅助解决 Next Greater Element 问题'
cover: 'https://www.helloimg.com/images/2023/05/03/oqwbMt.webp'
categories:

- 数据结构与算法

tags:

- Java
- 栈

---

> 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表，是一种非常常见的数据结构。它具有后进先出（LIFO）的特点，适用于需要实现“先进后出”逻辑的场景，例如撤销操作、函数调用栈以及算法中的一些问题解决等。在今天的博客中，我们将介绍一个基于栈数据结构的算法——单调栈。

# 一、栈和单调栈

## 1.1 栈

- 定义：栈就是一种只允许在一端进行插入或删除操作的线性表。
- 特点：其操作的运算受限，只允许在一端进行插入和删除操作。这一端被称为栈顶（Top），另一端被称为栈底（Bottom）。
- stack 意为整齐的一叠、一摞或者一堆；以一个实际场景为例，我们可以想象一个切菜过程中使用的盘子，菜刀不断地将切好的菜堆在盘子上，当需要用到其中一份菜时，只能从盘子的最顶部取出。
- 与栈相对应的另一种数据结构是队列（Queue）。队列也是一种线性结构，可以简单地理解为是只允许在一端进行插入操作，在另一端进行删除操作的线性表。这个后面再谈论。

<img src="https://www.helloimg.com/images/2023/04/28/oqXd9T.jpg">

## 1.2 单调栈

- 定义：单调栈（Monotonic Stack）是一种特殊的栈，它具有保持栈内元素单调递增或递减的特点。在使用单调栈解决算法问题时，往往需要先将数据压入栈中，然后进行适当的操作来维护栈的单调性。
- 特点：与普通的栈不同的是，单调栈在插入和删除时，需要先判断是否需要将栈内元素进行弹出，以维护栈的单调性质。

<img src="https://img0.baidu.com/it/u=1801279681,3349045423&fm=253&fmt=auto&app=138&f=JPEG?w=555&h=500">

# 二、问题与思路

## 2.1 题目

**下一个更大元素 I**

- nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
  给你两个没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
  对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，
  并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是-1。
  返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/next-greater-element-i

例子：

- 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
  输出：[-1,3,-1]
  解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,**4**,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [**1**,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,**2**]。不存在下一个更大元素，所以答案是 -1 。

我觉得原题目描述得很混乱，我们重新捋一下题目：

- 给定两个数组 nums1 和 nums2，其中 nums1 是 nums2 的子集，且两个数组均不包含重复元素。
- 对于 nums1 中的每个元素 x，在 nums2 中找到其右侧第一个比它大的元素，将这个下一个更大元素存储在数组 ans 中返回。如果不存在这样的下一个更大元素，则将 -1 存储在 ans 中的相应位置。

## 2.2 思路一：暴力法

- 首先，清楚题意之后会觉得题目并不难，看起来两次遍历就能解决问题，正所谓暴力法能解决的问题那都不是问题。
- 所以这里直接放出来暴力模拟算法的代码：

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] ans = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            ans[i] = -1;//先假设不存在后一个最大元素
            boolean b = false;//判断是否找到了目标元素
            for (int j = 0; j < nums2.length; j++) {
                if (nums2[j] == nums1[i]) {//到达了目标元素位置
                    b = true;
                }
                if (b && (nums2[j] > nums1[i])) {//存在后一个最大元素，将答案数组对应位置赋值
                    ans[i] = nums2[j];
                    break;//结束本次循环
                }
            }
        }
        return ans;
    }
}
```

时间复杂度不用说肯定是 **O(n^2)** 了，在数据量大的时候，效率是很差的。

## 2.3 思路二：单调栈

有没有复杂度不那么高的算法呢？如果是 **O(n) 或者 O(m + n)** 级别那就再好不过了。
答案是有的，不过需要一个家伙来辅助我们 —— `单调栈`。

- 在前面已经提到过单调栈的概念，即：一种单调递增或递减的特殊栈。
- 单调栈非常适合用来解决这道题目。主要步骤如下：
    1. 创建一个哈希表 map，用于存储每个元素的下一个更大元素。
    2. 创建一个单调栈 stack。
    3. 从 nums2 的尾部开始遍历，对于遍历到的每个元素 num，执行以下操作：
       a. 如果栈顶元素比当前元素 num 小或等于 num，则弹出栈顶元素，直到栈顶元素比 num 大或者栈为空。
       b. 将当前元素 num 加入栈中。
       c. 如果栈为空，则说明当前元素没有下一个更大元素，将其对应的 value 设为 -1；否则，取出栈顶元素，将其作为当前元素的下一个更大元素。
    4. 遍历 nums1 数组，使用哈希表 map 找到 nums1 中每个元素的下一个更大元素。

我们来举个例子走完上面的步骤，这样更有助于理解：

<img src="https://i.postimg.cc/Hxqght4K/juli.jpg">

`假设 nums1 = [4, 1, 2]，nums2 = [1, 3, 4, 2]，我们想找到 nums1 中每个元素的下一个更大元素。`

- 第一步：创建哈希表和单调栈

```java
        map={}
        stack=[]
```

- 第二步：遍历 nums2，从 nums2 的尾部开始遍历。
    - i = 3，num = 2，当前 stack 为空，map 设为 {2: -1}，stack 变成 [2]
    - i = 2，num = 4，当前 stack 为 [2]，4 比栈顶元素 2 大，因此弹出 2，并将 map 设为 {2: -1, 4: -1}，stack 变成 [4]
    - i = 1，num = 3，当前 stack 为 [4]，3 比栈顶元素 4 小，因此将 3 加入栈中，map 设为 {2: -1, 4: 3, 3: 4}，stack 变成 [4, 3]
    - i = 0，num = 1，当前 stack 为 [4, 3]，1 比栈顶元素 3 小，因此将 1 加入栈中，map 设为 {1: 3, 2: -1, 4: 3, 3: 4}，stack 变成 [4, 3, 1]
      最终得到的 map 为 {1: 3, 2: -1, 4: 3, 3: 4}，表示 nums2 中每个元素的下一个更大元素。

- 第三步：遍历 nums1
    - 对于 4，map 中对应的是 3
    - 对于 1，map 中对应的是 3
    - 对于 2，map 中对应的是 -1
      因此，最终得到的 res 数组为 [3, 3, -1]，即 nums1 中每个元素的下一个更大元素。

# 三、题解

有了上面的分析，直接写出对应的代码，我会在每一步都加上注释：

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // 创建哈希表，用于存储每个元素的下一个更大元素
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        // 创建单调栈
        Deque<Integer> stack = new ArrayDeque<Integer>();
        // 从 nums2 的尾部开始遍历
        for (int i = nums2.length - 1; i >= 0; --i) {
            int num = nums2[i];
            // 如果当前元素比栈顶元素大，则栈顶元素的下一个更大元素就是当前元素
            while (!stack.isEmpty() && num >= stack.peek()) {
                stack.pop();
            }
            // 将当前元素加入栈中
            // 如果栈为空，说明当前元素没有下一个更大元素，将其对应的 value 设为 -1
            map.put(num, stack.isEmpty() ? -1 : stack.peek());
            stack.push(num);
        }
        // 遍历 nums1，使用哈希表找到 nums1 中每个元素的下一个更大元素
        int[] res = new int[nums1.length];
        for (int i = 0; i < nums1.length; ++i) {
            res[i] = map.get(nums1[i]);
        }
        return res;
    }
}
```

# 四、总结

- 本文介绍了一个基于栈数据结构的算法——单调栈，并使用 LeetCode 上的一道题目来说明了单调栈的使用场景和实现方法。通过对暴力枚举算法和单调栈算法的对比，我们可以看出单调栈算法在时间复杂度上有较大优势（O(m + n)）。
- 在实际编程中，如果遇到类似"Next Greater Element"这样的问题时，可以优先考虑单调栈算法的使用。